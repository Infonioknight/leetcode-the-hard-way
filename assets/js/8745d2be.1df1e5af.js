"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[34869],{3905:(e,t,r)=>{r.d(t,{Zo:()=>m,kt:()=>h});var n=r(67294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function a(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var l=n.createContext({}),u=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},m=function(e){var t=u(e.components);return n.createElement(l.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,m=a(e,["components","mdxType","originalType","parentName"]),p=u(r),d=i,h=p["".concat(l,".").concat(d)]||p[d]||c[d]||o;return r?n.createElement(h,s(s({ref:t},m),{},{components:r})):n.createElement(h,s({ref:t},m))}));function h(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=r.length,s=new Array(o);s[0]=d;var a={};for(var l in t)hasOwnProperty.call(t,l)&&(a[l]=t[l]);a.originalType=e,a[p]="string"==typeof e?e:i,s[1]=a;for(var u=2;u<o;u++)s[u]=r[u];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},31870:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>v,frontMatter:()=>o,metadata:()=>a,suggestedProblems:()=>m,toc:()=>u});var n=r(87462),i=(r(67294),r(3905));const o={title:"Tim Sort",description:"Timsort is a fast stable sorting algorithm based upon insertion sort and merge sort.",hide_table_of_contents:!0,keywords:["leetcode","tutorial","sorting","algorithm","tim sort"]},s=void 0,a={unversionedId:"basic-topics/sorting/tim-sort",id:"basic-topics/sorting/tim-sort",title:"Tim Sort",description:"Timsort is a fast stable sorting algorithm based upon insertion sort and merge sort.",source:"@site/tutorials/basic-topics/sorting/tim-sort.md",sourceDirName:"basic-topics/sorting",slug:"/basic-topics/sorting/tim-sort",permalink:"/tutorials/basic-topics/sorting/tim-sort",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/basic-topics/sorting/tim-sort.md",tags:[],version:"current",frontMatter:{title:"Tim Sort",description:"Timsort is a fast stable sorting algorithm based upon insertion sort and merge sort.",hide_table_of_contents:!0,keywords:["leetcode","tutorial","sorting","algorithm","tim sort"]},sidebar:"tutorialSidebar",previous:{title:"Selection Sort",permalink:"/tutorials/basic-topics/sorting/selection-sort"},next:{title:"Time Complexity",permalink:"/tutorials/basic-topics/time-complexity"}},l={},u=[{value:"Overview",id:"overview",level:2},{value:"Algorithm",id:"algorithm",level:2},{value:"Example: 0287 - Find The Duplicate Number",id:"example-0287---find-the-duplicate-number",level:2},{value:"Pseudocode",id:"pseudocode",level:3},{value:"Dry Run",id:"dry-run",level:3},{value:"Complexity",id:"complexity",level:2}],m=[{problemName:"0075 - Sort Colors",difficulty:"Easy",leetCodeLink:"https://leetcode.com/problems/sort-colors/",solutionLink:"../../../solutions/0000-0099/sort-colors-medium"},{problemName:"0268 - Missing Number",difficulty:"Easy",leetCodeLink:"https://leetcode.com/problems/missing-number/",solutionLink:"../../../solutions/0200-0299/missing-number-easy"},{problemName:"0448 - Find All Numbers Disappeared In An Array",difficulty:"Easy",leetCodeLink:"https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/",solutionLink:""}],p=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",t)},c=p("TutorialAuthors"),d=p("Contributors"),h=p("Tabs"),g=p("TabItem"),f=p("SolutionAuthor"),b=p("Table"),y={toc:u,suggestedProblems:m},k="wrapper";function v(e){let{components:t,...r}=e;return(0,i.kt)(k,(0,n.Z)({},y,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)(c,{names:"@Bobliuuu",mdxType:"TutorialAuthors"}),(0,i.kt)(d,{names:"@wingkwong",mdxType:"Contributors"}),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"Timsort is a fast stable sorting algorithm based upon both ",(0,i.kt)("a",{parentName:"p",href:"/tutorials/basic-topics/sorting/insertion-sort"},"insertion sort")," and ",(0,i.kt)("a",{parentName:"p",href:"/tutorials/basic-topics/sorting/merge-sort"},"merge sort"),". The algorithm was first created by Tim Peters in 2002, and is now being used in Python's ",(0,i.kt)("inlineCode",{parentName:"p"},"sort()")," and Java's ",(0,i.kt)("inlineCode",{parentName:"p"},"Arrays.sort()"),".\nThe reason this algorithm is so fast is because it leverages the benefits of both merge sort and insertion sort. Let's see how it works!"),(0,i.kt)("h2",{id:"algorithm"},"Algorithm"),(0,i.kt)("p",null,"Timsort works by first splitting an array into ",(0,i.kt)("strong",{parentName:"p"},"runs"),". A ",(0,i.kt)("strong",{parentName:"p"},"run")," is a subarray of data spliced from the original array.\nThese runs are generated using merge sort (each run has a standard size of 32-64, to split the array into small enough pieces for insertion sort to be fast on each one), and insertion sort is used to sort each run. Finally, merge sort combines these sorted arrays together recursively. "),(0,i.kt)("p",null,"Basically, to run timsort: "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"We split the array into runs."),(0,i.kt)("li",{parentName:"ul"},"For each run, run insertion sort to sort that section."),(0,i.kt)("li",{parentName:"ul"},"Merge runs together one by one using merge sort, by comparing values in each sorted list and combining them. ")),(0,i.kt)("p",null,"This algorithm works because each run is sorted using insertion sort, and merge sort makes sure that each subarray is merged to the original array in the correct position. "),(0,i.kt)("h2",{id:"example-0287---find-the-duplicate-number"},"Example: ",(0,i.kt)("a",{parentName:"h2",href:"https://leetcode.com/problems/find-the-duplicate-number/"},"0287 - Find The Duplicate Number")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"An array of integers in the range ","[1, n]"," is given, where one integer is repeated. We have to find this repeated number.")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Naive Approach"),": Using a Hashmap or a frequency array, we can store the number of times each element comes up. We then return an array by looping through the frequency array finding the value that appears twice. However, this requires $$O(n)$$ space complexity, and the problem requires us to have $O(1)$ space complexity. "),(0,i.kt)("p",null,"For this sort of problem, we can use timsort to lower our space complexity! "),(0,i.kt)("h3",{id:"pseudocode"},"Pseudocode"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Sort the array using timsort"),(0,i.kt)("li",{parentName:"ul"},"Loop through the array"),(0,i.kt)("li",{parentName:"ul"},"If two values are the same, then that value must be repeated. Return that value. ")),(0,i.kt)("h3",{id:"dry-run"},"Dry Run"),(0,i.kt)("p",null,"Let's do a dry run of timsort with the array $","[5, 4, 3, 1, 2, 6, 7, 4]","$, and a run size of $2$. "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Each run is sorted using insertion sort. The array becomes $","[4, 5, 1, 3, 2, 6, 4, 7]","$. "),(0,i.kt)("li",{parentName:"ul"},"The merges happen using recursion. We first attempt to split the array into two parts, down the middle. "),(0,i.kt)("li",{parentName:"ul"},"First, the left part is merged, meaning the first two runs are merged. Then the array becomes $","[1, 3, 4, 5, 2, 6, 4, 7]","$. "),(0,i.kt)("li",{parentName:"ul"},"Then, the right part is merged, meaning the next two runs are merged. The the array becomes $","[1, 3, 4, 5, 2, 4, 6, 7]","$. "),(0,i.kt)("li",{parentName:"ul"},"Finally, the entire array is merged. The array is finally sorted: $","[1, 2, 3, 4, 4, 5, 6, 7]","$.")),(0,i.kt)(h,{mdxType:"Tabs"},(0,i.kt)(g,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)(f,{name:"@Bobliuuu",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    // initalize the size of each run\n    const int RUN = 32; \n    void insertionSort(vector<int>& nums, int left, int right) {\n        for (int i = left; i <= right; i++) {\n            int tmp = nums[i];\n            int j = i - 1;\n            while (j >= left && nums[j] > tmp) {\n                nums[j + 1] = nums[j];\n                j--;\n            }\n            nums[j + 1] = tmp;\n        }\n    }\n\n    void merge(vector<int>& nums, int left, int mid, int right) {\n        // maintain the two previous lists \n        vector<int> lt, rt;\n        int lenlt = mid - left + 1, lenrt = right - mid;\n        for (int i = 0; i < lenlt; i++) {\n            lt.push_back(nums[left + i]);\n        }\n        for (int i = 0; i < lenrt; i++) {\n            rt.push_back(nums[mid + 1 + i]);\n        }\n        // start recreating the correct list, putting the smaller one each time \n        int i = 0, j = 0, k = left;\n        while (i < lenlt && j < lenrt) {\n            if (lt[i] <= rt[j]) {\n                nums[k] = lt[i];\n                i++;\n            } else {\n                nums[k] = rt[j];\n                j++;\n            }\n            k++;\n        }\n        while (i < lenlt) {\n            nums[k] = lt[i];\n            k++; i++;\n        }\n        while (j < lenrt) {\n            nums[k] = rt[j];\n            k++; j++;\n        }\n    }\n    void timSort(vector<int>& nums) {\n        int n = nums.size();\n        // insertion sort on each run\n        for (int i = 0; i < n; i += RUN) {\n            insertionSort(nums, i, min((i + RUN-1), (n - 1))); \n        }\n        for (int size = RUN; size < n; size = 2 * size) {\n            for (int left = 0; left < n; left += 2 * size) {\n                // determine indices for each run for merging\n                int mid = left + size - 1, right = min((left + 2 * size - 1), (n - 1));\n                // merge the two runs if needed\n                if (mid < right) {\n                // use recursion to merge the array\n                    merge(nums, left, mid, right);\n                }\n            }\n        }\n    }\n    int findDuplicate(vector<int>& nums) {\n        // use timsort to sort the array\n        timSort(nums); \n        for (int i = 0; i < nums.size() - 1; i++) {\n            // return the duplicate if found\n            if (nums[i] == nums[i + 1]) {\n                return nums[i];\n            }\n        }\n        return 0;\n    }\n};\n")))),(0,i.kt)("h2",{id:"complexity"},"Complexity"),(0,i.kt)("p",null,"The time complexity of this program is $$O(n log n)$$, since the merging takes $logn$ steps, and merges $n$ values each time. "),(0,i.kt)("p",null,"The space complexity of this program is $$O(1)$$, since we don't need any extra space other than our original array. "),(0,i.kt)(b,{title:"Suggested Problems",data:m,mdxType:"Table"}))}v.isMDXComponent=!0}}]);