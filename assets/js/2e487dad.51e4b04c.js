"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[6112],{3905:(e,t,r)=>{r.d(t,{Zo:()=>m,kt:()=>h});var n=r(67294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var s=n.createContext({}),p=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},m=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=p(r),d=i,h=u["".concat(s,".").concat(d)]||u[d]||c[d]||a;return r?n.createElement(h,o(o({ref:t},m),{},{components:r})):n.createElement(h,o({ref:t},m))}));function h(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=r.length,o=new Array(a);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:i,o[1]=l;for(var p=2;p<a;p++)o[p]=r[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},68909:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>b,frontMatter:()=>a,metadata:()=>l,toc:()=>p});var n=r(87462),i=(r(67294),r(3905));const a={description:"Author: @ColeB2 | https://leetcode.com/problems/spiral-matrix/",tags:["Array","Matrix","Simulation"]},o="0054 - Spiral Matrix (Medium)",l={unversionedId:"0000-0099/spiral-matrix-medium",id:"0000-0099/spiral-matrix-medium",title:"0054 - Spiral Matrix (Medium)",description:"Author: @ColeB2 | https://leetcode.com/problems/spiral-matrix/",source:"@site/solutions/0000-0099/0054-spiral-matrix-medium.md",sourceDirName:"0000-0099",slug:"/0000-0099/spiral-matrix-medium",permalink:"/solutions/0000-0099/spiral-matrix-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0000-0099/0054-spiral-matrix-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Matrix",permalink:"/solutions/tags/matrix"},{label:"Simulation",permalink:"/solutions/tags/simulation"}],version:"current",sidebarPosition:54,frontMatter:{description:"Author: @ColeB2 | https://leetcode.com/problems/spiral-matrix/",tags:["Array","Matrix","Simulation"]},sidebar:"tutorialSidebar",previous:{title:"0053 - Maximum Subarray (Medium)",permalink:"/solutions/0000-0099/maximum-subarray-medium"},next:{title:"0055 - Jump Game (Medium)",permalink:"/solutions/0000-0099/jump-game-medium"}},s={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Spiral Order Search using Set.",id:"approach-1-spiral-order-search-using-set",level:2}],m=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",t)},u=m("Tabs"),c=m("TabItem"),d=m("SolutionAuthor"),h={toc:p},k="wrapper";function b(e){let{components:t,...r}=e;return(0,i.kt)(k,(0,n.Z)({},h,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"0054---spiral-matrix-medium"},"0054 - Spiral Matrix (Medium)"),(0,i.kt)("h2",{id:"problem-link"},"Problem Link"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/spiral-matrix/"},"https://leetcode.com/problems/spiral-matrix/")),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"Given an ",(0,i.kt)("strong",{parentName:"p"},"m x n")," ",(0,i.kt)("strong",{parentName:"p"},"matrix"),", return ",(0,i.kt)("em",{parentName:"p"},"all elements of the")," ",(0,i.kt)("strong",{parentName:"p"},"matrix")," ",(0,i.kt)("em",{parentName:"p"},"in spiral order"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg",alt:null})),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg",alt:null})),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"m == matrix.length")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"n == matrix[i].length")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= m, n <= 10")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-100 <= matrix[i][j] <= 100"))),(0,i.kt)("h2",{id:"approach-1-spiral-order-search-using-set"},"Approach 1: Spiral Order Search using Set."),(0,i.kt)("p",null,"We can just iterate the matrix in a spiral order, starting at the top left, and moving in the 4 cardinal directions, changing the direction if we ever hit a boundary or a previously visited cell."),(0,i.kt)("p",null,"This means we will need a few things, the order of our 4 directions, that is $$((0,1), (1,0), (0,-1), (-1,0))$$ which is right, down, left, up. We will need an index to track where we are in our directions, and a visited set to prevent us from going to the same cell twice."),(0,i.kt)("p",null,"With all that set, we can just loop until our return array reaches the length of $$ROWS * COLUMNS$$ adding each cell to our array and visited set, and then checking our boundaries to make sure we move our position to the proper spot."),(0,i.kt)("p",null,"Time Complexity: $$O(m * n)$$ where m is the number of rows, and n is the number of columns. We have to iterate each cell once in order to return the spiral order."),(0,i.kt)("p",null,"Space Complexity: $$O(m * n)$$, we need an array to return all the numbers in the matrix, and will also utilize a set to prevent revisiting cells."),(0,i.kt)(u,{mdxType:"Tabs"},(0,i.kt)(c,{value:"python",label:"Python",mdxType:"TabItem"},(0,i.kt)(d,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        # INITILIZE the ROWS, COLS of matrix, the directions of\n        # spiral order, and an index to track which direction we are\n        # traversing.\n        ROWS, COLS = len(matrix), len(matrix[0])\n        dirs = ((0,1), (1,0), (0,-1), (-1,0))\n        direction = 0\n        # initialize our return array, our visited set\n        spiral_order = []\n        visited = set()\n        # position in the matrix\n        r, c = 0, 0\n        while not len(spiral_order) == (ROWS * COLS):\n            # For our loop we will always just blindly add to the \n            # array and visited set, then check boundaries after.\n            spiral_order.append(matrix[r][c])\n            visited.add((r,c))\n            # check the next direction\n            dr, dc = dirs[direction]\n            nr, nc = dr + r, dc + c\n            # if next direction doesn't work.\n            if (nr >= ROWS or nr < 0 or\n                nc >= COLS or nc < 0 or\n                (nr, nc) in visited\n                ):\n                # change direction\n                direction = direction + 1 if direction < len(dirs) - 1 else 0\n            # update the next cell using the direction we need to be\n            # travelling. Since we are using a visited, and boundary\n            # checking above, the new cell r,c will always point to an\n            # unvisited, inbounds cell.\n            dr, dc = dirs[direction]\n            r, c = r + dr, c + dc\n        \n        return spiral_order\n")))))}b.isMDXComponent=!0}}]);