"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[70527],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>k});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var d=a.createContext({}),s=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=s(e.components);return a.createElement(d.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,l=e.originalType,d=e.parentName,h=r(e,["components","mdxType","originalType","parentName"]),p=s(n),u=o,k=p["".concat(d,".").concat(u)]||p[u]||m[u]||l;return n?a.createElement(k,i(i({ref:t},h),{},{components:n})):a.createElement(k,i({ref:t},h))}));function k(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var l=n.length,i=new Array(l);i[0]=u;var r={};for(var d in t)hasOwnProperty.call(t,d)&&(r[d]=t[d]);r.originalType=e,r[p]="string"==typeof e?e:o,i[1]=r;for(var s=2;s<l;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},33188:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>g,frontMatter:()=>l,metadata:()=>r,suggestedProblems:()=>h,toc:()=>s});var a=n(87462),o=(n(67294),n(3905));const l={title:"Linked List",description:"A linked list is a linear data structure that consists of nodes. Each node stores some data as well as the address of the next node.",hide_table_of_contents:!1,keywords:["leetcode","tutorial","linked List","data structure"]},i=void 0,r={unversionedId:"basic-topics/linked-list",id:"basic-topics/linked-list",title:"Linked List",description:"A linked list is a linear data structure that consists of nodes. Each node stores some data as well as the address of the next node.",source:"@site/tutorials/basic-topics/linked-list.md",sourceDirName:"basic-topics",slug:"/basic-topics/linked-list",permalink:"/tutorials/basic-topics/linked-list",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/basic-topics/linked-list.md",tags:[],version:"current",frontMatter:{title:"Linked List",description:"A linked list is a linear data structure that consists of nodes. Each node stores some data as well as the address of the next node.",hide_table_of_contents:!1,keywords:["leetcode","tutorial","linked List","data structure"]},sidebar:"tutorialSidebar",previous:{title:"Linear Search",permalink:"/tutorials/basic-topics/linear-search"},next:{title:"MOD (1e9 + 7)",permalink:"/tutorials/basic-topics/mod"}},d={},s=[{value:"Overview",id:"overview",level:2},{value:"Representation of a Linked List",id:"representation-of-a-linked-list",level:2},{value:"Linked List in Memory",id:"linked-list-in-memory",level:2},{value:"Basic Linked list operations",id:"basic-linked-list-operations",level:2},{value:"Traversal",id:"traversal",level:2},{value:"Inserting an element to the Linked list",id:"inserting-an-element-to-the-linked-list",level:2},{value:"Inserting at the beginning",id:"inserting-at-the-beginning",level:3},{value:"Inserting at the middle",id:"inserting-at-the-middle",level:3},{value:"Inserting at the end",id:"inserting-at-the-end",level:3},{value:"Deleting an element from the Linked list",id:"deleting-an-element-from-the-linked-list",level:2},{value:"Deleting from the beginning",id:"deleting-from-the-beginning",level:3},{value:"Deleting from the end",id:"deleting-from-the-end",level:3},{value:"Deleting from any position in the middle",id:"deleting-from-any-position-in-the-middle",level:3},{value:"Search for an item in the list",id:"search-for-an-item-in-the-list",level:2},{value:"Complexity Analysis",id:"complexity-analysis",level:2},{value:"Example: 0237 - Delete Node in a Linked List",id:"example-0237---delete-node-in-a-linked-list",level:2},{value:"Example: 0019 - Remove Nth Node From End of List",id:"example-0019---remove-nth-node-from-end-of-list",level:2},{value:"Approach",id:"approach",level:4},{value:"Example: 0234 - Palindrome Linked List",id:"example-0234---palindrome-linked-list",level:2},{value:"Approach",id:"approach-1",level:4},{value:"Example: 0328 - Odd Even Linked List",id:"example-0328---odd-even-linked-list",level:2},{value:"Approach",id:"approach-2",level:4}],h=[{problemName:"206. Reverse Linked List",difficulty:"Easy",leetCodeLink:"https://leetcode.com/problems/reverse-linked-list/",solutionLink:""},{problemName:"86. Partition List",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/partition-list/",solutionLink:""},{problemName:"148. Sort List",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/sort-list/",solutionLink:""}],p=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",t)},m=p("TutorialAuthors"),u=p("Tabs"),k=p("TabItem"),c=p("SolutionAuthor"),v=p("Table"),f={toc:s,suggestedProblems:h},$="wrapper";function g(e){let{components:t,...n}=e;return(0,o.kt)($,(0,a.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)(m,{names:"@itsmenikhill",mdxType:"TutorialAuthors"}),(0,o.kt)("h2",{id:"overview"},"Overview"),(0,o.kt)("p",null,"In this tutorial you will learn about Linked Lists, and its implementation using Java. "),(0,o.kt)("p",null,"Problem with using Arrays was that we have to have some idea about the size of the array that we require. To counter this we learnt about dynamic arrays. Linked list is another approach to tackle this problem. In linked lists we do not have to worry about the size at all."),(0,o.kt)("p",null,"A linked list is a linear data structure that has a series of connected nodes. Each node has two fields, $data$ and an $address$.\nWe call the start of a linked list, $head$. We can all it anything but by convention, we'll call it $head$. "),(0,o.kt)("h2",{id:"representation-of-a-linked-list"},"Representation of a Linked List"),(0,o.kt)("p",null,"Each node in a linked list contains:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A data item"),(0,o.kt)("li",{parentName:"ul"},"Address of next node")),(0,o.kt)("p",null,"Both of these items are wrapped together in a class:"),(0,o.kt)(u,{mdxType:"Tabs"},(0,o.kt)(k,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)(c,{name:"@itsmenikhill",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"class Node {\n  int data;  \n  Node next;  \n\n  public Node(){\n    this.data = data;\n    this.next = null;\n  }\n}\n")))),(0,o.kt)("p",null,"Now we will create a Linked list using this Node class:"),(0,o.kt)(u,{mdxType:"Tabs"},(0,o.kt)(k,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)(c,{name:"@itsmenikhill",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"class LinkedList {\n  Node node1 = new Node();\n  Node node2 = new Node();\n  Node node3 = new Node();\n  // set 10 as the value for 1st node\n  node1.data = 10;  \n  // set node2 as the next node for node1\n  node1.next = node2;  \n  // set 20 as the value for 2nd node\n  node2.data = 20;  \n  // set node3 as the next node for node2\n  node2.next = node3;  \n  // set 30 as the value for 3rd node\n  node3.data = 30;  \n  // this is not required. By default next of a node is NULL\n  node3.next = null; \n\n}\n")))),(0,o.kt)("p",null,"So now we have our first linked list."),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/44477975/197191483-6b75032c-503c-42e6-9b23-171c090e6974.png",alt:"image"})),(0,o.kt)("p",null,"The asterisk (*) signifies the address of the node, and not the value of that node."),(0,o.kt)("h2",{id:"linked-list-in-memory"},"Linked List in Memory"),(0,o.kt)("p",null,"In arrays the elements are contiguous, which means they are placed one after the other in the memory. However, in linked lists, the elements are scattered in the memory."),(0,o.kt)("p",null,"When we declare an integer array of size $15$, we would require 60 bytes of contiguous space in the memory to store the elements of that array. But in linked list we would only have to find $4$ bytes to store the first element and from there, we look for another $4$ bytes to store the next element. So, we see that the linked list items are scattered in memory unlike arrays."),(0,o.kt)("p",null,"That is the advantage linked lists have over array when it comes to memory. We have to look for smaller spaces to store the items, rather than chunks of contiguous space."),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/44477975/197190434-c302adcf-72de-4192-98d1-3df4339215d4.png",alt:"image"})),(0,o.kt)("p",null,"Numbers with # behind them are the addresses in memory where these nodes are stored. Here, $head$ stores the address for $node1$ and $node1$ stores the address for $node2$. Notice that the address are not sequential."),(0,o.kt)("h2",{id:"basic-linked-list-operations"},"Basic Linked list operations"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Traversal"),(0,o.kt)("li",{parentName:"ul"},"Insertion"),(0,o.kt)("li",{parentName:"ul"},"Deletion"),(0,o.kt)("li",{parentName:"ul"},"Search")),(0,o.kt)("p",null,"Let's see their implementation in a linked list."),(0,o.kt)("h2",{id:"traversal"},"Traversal"),(0,o.kt)("p",null,"We have to access each element of the linked list. Remember, the $head$ points to the first node, and the $next$ pointer of the last node points to $null$."),(0,o.kt)("p",null,"Traversing through the linked list is fairly simple. We keep moving from the head towards the end of the list. We would know we have reached the last node when $next$ points to $null$."),(0,o.kt)(u,{mdxType:"Tabs"},(0,o.kt)(k,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)(c,{name:"@itsmenikhill",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"// temp pointer that points to head initially\nNode temp = head; \n// check if next points to null\nwhile (temp.next != null) { \n  // print the data stored in the current node\n  System.out.println(temp.data); \n  // move temp to the next node\n  temp = temp.next; \n}\n")))),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"}," You are given the head of a linked list and a number. Check if the given number is present in the linked list or not. Return true if present, else return false.")),(0,o.kt)("p",null,"We will traverse the list and at each node we will check if we have the required element in the current node or not. If we found the element, return true. If we have iterated over the list and not not found the number, we will return false."),(0,o.kt)(u,{mdxType:"Tabs"},(0,o.kt)(k,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)(c,{name:"@itsmenikhill",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public static boolean findElement(Node head, int target){\n  Node ptr = head;\n  while (ptr != null) {\n    // compare the node element and the target number\n    if (ptr.data == target) { \n        // number found \n        return true; \n    }\n    // move pointer to the next node\n    ptr = ptr.next; \n  }\n  // number not found\n  return false; \n}\n")))),(0,o.kt)("h2",{id:"inserting-an-element-to-the-linked-list"},"Inserting an element to the Linked list"),(0,o.kt)("p",null,"We can add element to the beginning, middle or at the end of the linked list."),(0,o.kt)("h3",{id:"inserting-at-the-beginning"},"Inserting at the beginning"),(0,o.kt)("p",null,"You are given a linked list $","[3]","$ -> $","[4]","$ -> $","[5]","$ -> $null$ and we have to add another node $","[1]","$ to the front. How would you do this?"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Approach:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Allocate memory for a new node"),(0,o.kt)("li",{parentName:"ul"},"Store the data"),(0,o.kt)("li",{parentName:"ul"},"Point $next$ of new node to $head$"),(0,o.kt)("li",{parentName:"ul"},"Point $head$ to the ",(0,o.kt)("strong",{parentName:"li"},"new")," node")),(0,o.kt)(u,{mdxType:"Tabs"},(0,o.kt)(k,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)(c,{name:"@itsmenikhill",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"// allocate memory\nNode newNode = new Node(); \n// store data\nnewNode.data = 1; \n// point next of new node to head\nnewNode.next = head; \n// make head point to new node\nhead = newNode; \n")))),(0,o.kt)("h3",{id:"inserting-at-the-middle"},"Inserting at the middle"),(0,o.kt)("p",null,"You are given a linked list $","[3]","$ -> $","[4]","$ -> $","[5]","$ -> $","[6]","$ -> $null$. Insert a new node $","[7]","$ at the 3rd place to make the final list as $","[3]","$ -> $","[4]","$ -> $","[7]","$ -> $","[5]","$ -> $","[6]","$ -> $null$. "),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Approach:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Allocate memory for the new node"),(0,o.kt)("li",{parentName:"ul"},"Store the data in the new node"),(0,o.kt)("li",{parentName:"ul"},"Traverse to the node just before the required index"),(0,o.kt)("li",{parentName:"ul"},"Change the pointers")),(0,o.kt)(u,{mdxType:"Tabs"},(0,o.kt)(k,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)(c,{name:"@itsmenikhill",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"Node newNode = new Node();\nnewNode.data = 7;\nNode temp = head;\n\n// position at which we want to insert the new element\nint pos = 3;  \n\n// loop runs only for i=2. when i=3, pos=3 as well, hence loop terminates.\nfor (int i = 2; i < pos; i++) { \n  if(temp.next!=null) { \n    temp = temp.next;\n  }\n}\n// here temp points to the 2nd node\nnewNode.next = temp.next;  \n // new node inserted after temp. \ntemp.next = newNode;\n")))),(0,o.kt)("p",null,"One important thing to note here is that before breaking any connection in the linked list, we must first make the new connections. Make first, break later."),(0,o.kt)("h3",{id:"inserting-at-the-end"},"Inserting at the end"),(0,o.kt)("p",null,"You are given a linked list $","[3]","$ -> $","[4]","$ -> $","[5]","$ -> $","[6]","$ -> $null$. Insert a new node $","[7]","$ at the end to make the final list as $","[3]","$ -> $","[4]","$ -> $","[5]","$ -> $","[6]","$ -> $","[7]","$ -> $null$"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Approach:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Allocate memory for the new node"),(0,o.kt)("li",{parentName:"ul"},"Store the data in the new node"),(0,o.kt)("li",{parentName:"ul"},"Traverse till the end of the list"),(0,o.kt)("li",{parentName:"ul"},"Make the $next$ of the last node point to the new node")),(0,o.kt)(u,{mdxType:"Tabs"},(0,o.kt)(k,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)(c,{name:"@itsmenikhill",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"Node newNode = new Node();\nnewNode.data = 7;\nNode temp = head;\n\n// when temp.next is null, we'll know we are at the last node\nwhile (temp.next != null) { \n  // move pointer to the next node\n  temp = temp.next; \n}\n\n// temp is now at the last node.\n// point $next$ of the last node to the new node \ntemp.next = newNode; \n")))),(0,o.kt)("h2",{id:"deleting-an-element-from-the-linked-list"},"Deleting an element from the Linked list"),(0,o.kt)("p",null,"We can delete the first node, or the last node, or some other position in the middle."),(0,o.kt)("h3",{id:"deleting-from-the-beginning"},"Deleting from the beginning"),(0,o.kt)("p",null,"To delete from the beginning we just have to move the $head$ to its next, so that no pointer would be pointing to the first node."),(0,o.kt)(u,{mdxType:"Tabs"},(0,o.kt)(k,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)(c,{name:"@itsmenikhill",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"// change the pointer from the head node, to the next node.\nhead = head.next;\n")))),(0,o.kt)("h3",{id:"deleting-from-the-end"},"Deleting from the end"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Move the pointer to the second last node"),(0,o.kt)("li",{parentName:"ul"},"Set the $next$ pointer of second last node to point to $null$")),(0,o.kt)(u,{mdxType:"Tabs"},(0,o.kt)(k,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)(c,{name:"@itsmenikhill",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"Node temp = head;\n// move the pointer to the second last node\nwhile (temp.next.next != null) {\n  // move the current pointer to the next node\n  temp = temp.next;\n}\ntemp.next = null;\n")))),(0,o.kt)("h3",{id:"deleting-from-any-position-in-the-middle"},"Deleting from any position in the middle"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Traverse to the element just before the node to delete"),(0,o.kt)("li",{parentName:"ul"},"Change the next of this node to point to next of the node to delete")),(0,o.kt)(u,{mdxType:"Tabs"},(0,o.kt)(k,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)(c,{name:"@itsmenikhill",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"Node temp = head;\n// we are running the loop from 2 node because we have to move to the node \n// just before the node we want to remove\nfor (int i = 2; i < pos; i++) {\n  // change pointer from current node to the next node\n  temp = temp.next;\n}\ntemp.next = temp.next.next;\n")))),(0,o.kt)("h2",{id:"search-for-an-item-in-the-list"},"Search for an item in the list"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Make a temporary pointer $ptr$ point to $head$"),(0,o.kt)("li",{parentName:"ul"},"Move $ptr$ to next node until $ptr$ is $null$"),(0,o.kt)("li",{parentName:"ul"},"At each iteration, check if the data in $ptr$ is same as the number we want. If yes, then return $true$"),(0,o.kt)("li",{parentName:"ul"},"Return $false$ if number not found")),(0,o.kt)(u,{mdxType:"Tabs"},(0,o.kt)(k,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)(c,{name:"@itsmenikhill",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"Node ptr = head;  \nwhile (ptr != null) {\n  // check if data in current node matches the number we are looking for\n  if (ptr.data == num) {  \n    // return true if number found\n    return true;   \n  }\n  // move ptr to the next node\n  ptr = ptr.next;  \n}\n// return false if number not found\nreturn false;  \n")))),(0,o.kt)("h2",{id:"complexity-analysis"},"Complexity Analysis"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Operation"),(0,o.kt)("th",{parentName:"tr",align:null},"Complexity"),(0,o.kt)("th",{parentName:"tr",align:null},"Explanation"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Look up"),(0,o.kt)("td",{parentName:"tr",align:null},"$$O(N)$$"),(0,o.kt)("td",{parentName:"tr",align:null},"We will have to iterate from head till the element we want")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Insertion at beginning"),(0,o.kt)("td",{parentName:"tr",align:null},"$$O(1)$$"),(0,o.kt)("td",{parentName:"tr",align:null},"Simply change the head pointer")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Insertion at the end"),(0,o.kt)("td",{parentName:"tr",align:null},"$$O(N)$$"),(0,o.kt)("td",{parentName:"tr",align:null},"Move from the head to the last item then change the pointers")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Deletion from the beginning"),(0,o.kt)("td",{parentName:"tr",align:null},"$$O(1)$$"),(0,o.kt)("td",{parentName:"tr",align:null},"Simply change the head pointer")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Deletion from the end"),(0,o.kt)("td",{parentName:"tr",align:null},"$$O(N)$$"),(0,o.kt)("td",{parentName:"tr",align:null},"Move from the head to the node just before the item you want to delete")))),(0,o.kt)("h2",{id:"example-0237---delete-node-in-a-linked-list"},"Example: ",(0,o.kt)("a",{parentName:"h2",href:"https://leetcode.com/problems/delete-node-in-a-linked-list/"},"0237 - Delete Node in a Linked List")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"There is a singly linked list. You have to delete a $node$ from the list. You are given the $node$ to delete but not the $head$ of the > list. Delete the given $node$. Note that by deleting the $node$, we $do not$ mean removing it from memory. We mean:"),(0,o.kt)("ul",{parentName:"blockquote"},(0,o.kt)("li",{parentName:"ul"},"The value of the given node should not exist in the linked list."),(0,o.kt)("li",{parentName:"ul"},"The number of nodes in the linked list should decrease by one."),(0,o.kt)("li",{parentName:"ul"},"All the values before node should be in the same order."),(0,o.kt)("li",{parentName:"ul"},"All the values after node should be in the same order."))),(0,o.kt)("p",null,"Change the value of the $current node$ to the value of the $next$ node. Do this until the last node."),(0,o.kt)(u,{mdxType:"Tabs"},(0,o.kt)(k,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)(c,{name:"@itsmenikhill",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    // we are given a node to delete\n    public void deleteNode(ListNode node) {\n        // check if the current node is second last node\n        while(node.next.next!=null){\n            // change the value of current node to the value of next node\n            node.val = node.next.val;\n            // move node to the next node\n            node=node.next;\n        }\n\n        // we are at the second last node\n        // change value of the last node to the value of next node\n        node.val = node.next.val;\n        // change the next of last node to null\n        node.next = null;\n    }\n}\n")))),(0,o.kt)("h2",{id:"example-0019---remove-nth-node-from-end-of-list"},"Example: ",(0,o.kt)("a",{parentName:"h2",href:"https://leetcode.com/problems/remove-nth-node-from-end-of-list/"},"0019 - Remove Nth Node From End of List")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Given the head of a linked list, remove the nth node from the end of the list and return its head. Given Linked list: $","[1]","$ -> $","[2]","$ -> $","[3]","$ -> $","[4]","$ -> $","[5]","$ for $n = 2$ change the list to $","[1]","$ -> $","[2]","$ -> $","[3]","$ -> $","[5]","$.")),(0,o.kt)("h4",{id:"approach"},"Approach"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"First we find the size of the list"),(0,o.kt)("li",{parentName:"ul"},"$nth$ node from the $end$ is the $size - (n + 1)th$ node from the $front$"),(0,o.kt)("li",{parentName:"ul"},"Once we have the size, we can iterate over the list till the node just before the node to remove"),(0,o.kt)("li",{parentName:"ul"},"Change the pointers to remove the node")),(0,o.kt)(u,{mdxType:"Tabs"},(0,o.kt)(k,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)(c,{name:"@itsmenikhill",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode ptr = head;\n        // find the size\n        int size = findSize(head);\n        ptr = head;\n\n        // if size is equal to the n, remove node at head\n        if (size == n) {\n            ptr = ptr.next;\n            head = ptr;\n            return head;\n        }\n\n        // move ptr to the node just before the node to remove\n        for (int i = 0; i< size - n - 1; i++) {\n            ptr = ptr.next;\n        }\n\n        // check if the node to remove is the last node\n        if (ptr.next.next != null){\n            ptr.next = ptr.next.next;\n        } else {\n            ptr.next=null;\n        }\n        return head;\n    }\n    \n    // method to find the size of the list\n    public int findSize(ListNode head) {\n      // temporary pointer at head\n        ListNode ptr = head;\n        int size = 0;\n        // increase the size till we reach the end of the list\n        while (ptr != null) {\n            size += 1;\n            ptr = ptr.next;\n        }\n        return size;\n    }\n}\n")))),(0,o.kt)("h2",{id:"example-0234---palindrome-linked-list"},"Example: ",(0,o.kt)("a",{parentName:"h2",href:"https://leetcode.com/problems/palindrome-linked-list/"},"0234 - Palindrome Linked List")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Given the $head$ of a singly linked list, return $true$ if it is a $palindrome$ or $false$ otherwise. ")),(0,o.kt)("h4",{id:"approach-1"},"Approach"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"We use $two pointer$ method and $recursion$ to solve this problem"),(0,o.kt)("li",{parentName:"ul"},"We keep a $global$ left pointer, that points to the current left node"),(0,o.kt)("li",{parentName:"ul"},"As we go deep in recursion we move our $right$ pointer forward towards the end of the list"),(0,o.kt)("li",{parentName:"ul"},"When $right$ pointer is at the end we compare its value to the $left$ node"),(0,o.kt)("li",{parentName:"ul"},"If they are same we move $left$ pointer forward and come out of the recursion"),(0,o.kt)("li",{parentName:"ul"},"As we come out of the recursive call, out $right$ pointer would move towards $left$"),(0,o.kt)("li",{parentName:"ul"},"If at any point the values are not same, we return $false$")),(0,o.kt)(u,{mdxType:"Tabs"},(0,o.kt)(k,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)(c,{name:"@itsmenikhill",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    // global left pointer\n    static ListNode left;\n    public boolean isPalindrome(ListNode head) {\n      // point the left to head\n        left = head;\n        boolean b = check(head);\n        return b;   \n    }\n    \n    // recursive method that moves pointer towards right and compares values\n    private boolean check(ListNode right){\n        // if right is null, we have reached the end of the list\n        if(right == null){\n            return true;\n        }\n        \n        boolean b = check(right.next);\n        // if at any point b is false, we return false. If this happens even once, \n        // no further comparisons would happen and each recursive call would return false\n        if(b == false){\n            return false;\n        } else {\n            // else compare the values \n            // if values are equal, move left towards right and return true to the previous call\n            if (left.val == right.val) {\n                left = left.next;\n                return true;\n            }  else {\n                // if values not same, return false\n                return false;\n            }\n        }\n    }\n}\n")))),(0,o.kt)("h2",{id:"example-0328---odd-even-linked-list"},"Example: ",(0,o.kt)("a",{parentName:"h2",href:"https://leetcode.com/problems/odd-even-linked-list/"},"0328 - Odd Even Linked List")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Given the $head$ of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list."),(0,o.kt)("p",{parentName:"blockquote"},"The $first$ node is considered $odd$, and the $second$ node is $even$, and so on."),(0,o.kt)("p",{parentName:"blockquote"},"Note that the relative order inside both the even and odd groups should remain as it was in the input."),(0,o.kt)("p",{parentName:"blockquote"},"You must solve the problem in O(1) extra space complexity and O(n) time complexity.")),(0,o.kt)("h4",{id:"approach-2"},"Approach"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"We maintain three pointers, $odd$ at the first node, $even$ at the second node and $evenhead$ also at the second node."),(0,o.kt)("li",{parentName:"ul"},"$evenhead$ will not be changed. It will point to the starting of the list of even nodes."),(0,o.kt)("li",{parentName:"ul"},"The node after every even node, is an odd node. "),(0,o.kt)("li",{parentName:"ul"},"So, $next$ node for current $odd$ node, would be $next$ node of the current $even$ node."),(0,o.kt)("li",{parentName:"ul"},"And $next$ node for the current $even$ node, would be $next$ node of the just changed $odd$ node.")),(0,o.kt)(u,{mdxType:"Tabs"},(0,o.kt)(k,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)(c,{name:"@itsmenikhill",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public ListNode oddEvenList(ListNode head) {\n        // we check if there are at least three nodes in the list\n        // if there are only two nodes, then first node is even and second node is odd\n        // if only one node, then first node is odd \n        // so just return head\n        if (head == null || head.next == null || head.next.next == null) {\n            return head;\n        }\n        \n        // odd is at head\n        ListNode odd = head;\n        // make second node as even\n        ListNode even = head.next;\n        // keep a pointer evenhead at even. This will not be changed.\n        ListNode evenHead = even;\n        \n        // we have to move odd to next of even\n        // so we check is even.next is null of even is null\n        while (even != null && even.next != null) {\n            // if not, then make odd.next point to even.next\n            odd.next = even.next;\n            // move odd to odd.next\n            odd = odd.next;\n            // even.next to odd.next\n            even.next = odd.next;\n            // move even to even.next\n            even = even.next;\n        }\n\n        // at this point we have connected all the even nodes together, and all odd nodes together\n        // now we connect the odd nodes, and even nodes\n        odd.next = evenHead;\n        return head;\n    }\n}\n")))),(0,o.kt)(v,{title:"Suggested Problems",data:h,mdxType:"Table"}))}g.isMDXComponent=!0}}]);