"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[82981],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>d});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),s=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},h=function(e){var t=s(e.components);return i.createElement(l.Provider,{value:t},e.children)},p="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,h=c(e,["components","mdxType","originalType","parentName"]),p=s(n),m=a,d=p["".concat(l,".").concat(m)]||p[m]||f[m]||r;return n?i.createElement(d,o(o({ref:t},h),{},{components:n})):i.createElement(d,o({ref:t},h))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=m;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c[p]="string"==typeof e?e:a,o[1]=c;for(var s=2;s<r;s++)o[s]=n[s];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},14786:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>g,frontMatter:()=>r,metadata:()=>c,toc:()=>s});var i=n(87462),a=(n(67294),n(3905));const r={description:"Author: @wingkwong, @radojicic23, @ColeB2 | https://leetcode.com/problems/pacific-atlantic-water-flow/",tags:["Array","Depth-First Search","Breadth-First Search","Matrix"]},o="0417 - Pacific Atlantic Water Flow (Medium)",c={unversionedId:"0400-0499/pacific-atlantic-water-flow-medium",id:"0400-0499/pacific-atlantic-water-flow-medium",title:"0417 - Pacific Atlantic Water Flow (Medium)",description:"Author: @wingkwong, @radojicic23, @ColeB2 | https://leetcode.com/problems/pacific-atlantic-water-flow/",source:"@site/solutions/0400-0499/0417-pacific-atlantic-water-flow-medium.md",sourceDirName:"0400-0499",slug:"/0400-0499/pacific-atlantic-water-flow-medium",permalink:"/solutions/0400-0499/pacific-atlantic-water-flow-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0400-0499/0417-pacific-atlantic-water-flow-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Depth-First Search",permalink:"/solutions/tags/depth-first-search"},{label:"Breadth-First Search",permalink:"/solutions/tags/breadth-first-search"},{label:"Matrix",permalink:"/solutions/tags/matrix"}],version:"current",sidebarPosition:417,frontMatter:{description:"Author: @wingkwong, @radojicic23, @ColeB2 | https://leetcode.com/problems/pacific-atlantic-water-flow/",tags:["Array","Depth-First Search","Breadth-First Search","Matrix"]},sidebar:"tutorialSidebar",previous:{title:"0416 - Partition Equal Subset Sum (Medium)",permalink:"/solutions/0400-0499/partition-equal-subset-sum-medium"},next:{title:"0421 - Maximum XOR of Two Numbers in an Array",permalink:"/solutions/0400-0499/maximum-xor-of-two-numbers-in-an-array"}},l={},s=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: DFS",id:"approach-1-dfs",level:2},{value:"Approach 2: Breadth-First Search",id:"approach-2-breadth-first-search",level:2}],h=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",t)},p=h("Tabs"),f=h("TabItem"),m=h("SolutionAuthor"),d={toc:s},u="wrapper";function g(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"0417---pacific-atlantic-water-flow-medium"},"0417 - Pacific Atlantic Water Flow (Medium)"),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"There is an ",(0,a.kt)("inlineCode",{parentName:"p"},"m x n")," rectangular island that borders both the ",(0,a.kt)("strong",{parentName:"p"},"Pacific Ocean")," and ",(0,a.kt)("strong",{parentName:"p"},"Atlantic Ocean"),". The ",(0,a.kt)("strong",{parentName:"p"},"Pacific Ocean")," touches the island's left and top edges, and the ",(0,a.kt)("strong",{parentName:"p"},"Atlantic Ocean")," touches the island's right and bottom edges."),(0,a.kt)("p",null,"The island is partitioned into a grid of square cells. You are given an ",(0,a.kt)("inlineCode",{parentName:"p"},"m x n")," integer matrix ",(0,a.kt)("inlineCode",{parentName:"p"},"heights")," where ",(0,a.kt)("inlineCode",{parentName:"p"},"heights[r][c]")," represents the ",(0,a.kt)("strong",{parentName:"p"},"height above sea level")," of the cell at coordinate ",(0,a.kt)("inlineCode",{parentName:"p"},"(r, c)"),"."),(0,a.kt)("p",null,"The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is ",(0,a.kt)("strong",{parentName:"p"},"less than or equal to")," the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean."),(0,a.kt)("p",null,"Return ",(0,a.kt)("em",{parentName:"p"},"a ",(0,a.kt)("strong",{parentName:"em"},"2D list")," of grid coordinates"),(0,a.kt)("inlineCode",{parentName:"p"},"result"),(0,a.kt)("em",{parentName:"p"},"where"),(0,a.kt)("inlineCode",{parentName:"p"},"result[i] = [ri, ci]"),(0,a.kt)("em",{parentName:"p"},"denotes that rain water can flow from cell"),(0,a.kt)("inlineCode",{parentName:"p"},"(ri, ci)"),(0,a.kt)("em",{parentName:"p"},"to ",(0,a.kt)("strong",{parentName:"em"},"both")," the Pacific and Atlantic oceans"),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\nExplanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:\n[0,4]: [0,4] -> Pacific Ocean \n\xa0      [0,4] -> Atlantic Ocean\n[1,3]: [1,3] -> [0,3] -> Pacific Ocean \n\xa0      [1,3] -> [1,4] -> Atlantic Ocean\n[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean \n\xa0      [1,4] -> Atlantic Ocean\n[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean \n\xa0      [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean\n[3,0]: [3,0] -> Pacific Ocean \n\xa0      [3,0] -> [4,0] -> Atlantic Ocean\n[3,1]: [3,1] -> [3,0] -> Pacific Ocean \n\xa0      [3,1] -> [4,1] -> Atlantic Ocean\n[4,0]: [4,0] -> Pacific Ocean \n       [4,0] -> Atlantic Ocean\nNote that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: heights = [[1]]\nOutput: [[0,0]]\nExplanation: The water can flow from the only cell to the Pacific and Atlantic oceans.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"m == heights.length")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"n == heights[r].length")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= m, n <= 200")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"0 <= heights[r][c] <= 10^5"))),(0,a.kt)("h2",{id:"approach-1-dfs"},"Approach 1: DFS"),(0,a.kt)(p,{mdxType:"Tabs"},(0,a.kt)(f,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(m,{name:"@wingkwonmg",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    void dfs(vector<vector<int>>& M, vector<vector<int>>& vis, int i, int j) {\n        int m = M.size(), n = M[0].size();\n        // marked this cell (i, j) as visited\n        // so that we won't visit it again\n        vis[i][j] = 1;\n        // perform DFS on the left cell\n        if (i - 1 >= 0 && !vis[i - 1][j] && M[i - 1][j] >= M[i][j]) dfs(M, vis, i - 1, j);\n        // perform DFS on the right cell\n        if (i + 1 < m && !vis[i + 1][j] && M[i + 1][j] >= M[i][j]) dfs(M, vis, i + 1, j);\n        // perform DFS on the top cell\n        if (j - 1 >= 0 && !vis[i][j - 1] && M[i][j - 1] >= M[i][j]) dfs(M, vis, i, j - 1);\n        // perform DFS on the bottom cell\n        if (j + 1 < n && !vis[i][j + 1] && M[i][j + 1] >= M[i][j]) dfs(M, vis, i, j + 1);\n    }\n    \n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& M) {\n        vector<vector<int>> ans;\n        int m = M.size(), n = M[0].size();\n        // P[i][j] = 1 means it is able to flow to pacific ocean\n        vector<vector<int>> P(m, vector<int>(n));\n        // A[i][j] = 1 means it is able to flow to atlantic ocean\n        vector<vector<int>> A(m, vector<int>(n));\n        for(int i = 0; i < m; i++) {\n            // perform dfs starting from the left-most column \n            dfs(M, P, i, 0);\n            // perform dfs starting from the right-most column \n            dfs(M, A, i, n - 1);\n        }\n        for(int i = 0; i < n; i++) {\n            // perform dfs starting from the top-most row\n            dfs(M, P, 0, i);\n            // perform dfs starting from the bottom-most row\n            dfs(M, A, m - 1, i);\n        }\n        // iterate each row\n        for(int i = 0; i < m; i++) {\n            // iterate each column\n            for(int j = 0; j < n; j++) {\n                // if both P[i][j] & A[i][j] are visited\n                // that means this cell can flow to both ocean\n                if(P[i][j] && A[i][j]) {\n                    // then put the coordinate (i, j) to answer\n                    ans.push_back(vector<int>{i, j});\n                }\n            }\n        }\n        return ans;\n    }\n};\n"))),(0,a.kt)(f,{value:"python",label:"Python",mdxType:"TabItem"},(0,a.kt)(m,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"class Solution:\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n        rows, cols = len(heights), len(heights[0]) \n        # 2 hashsets to maintain all the positions that can reach two oceans\n        pac, atl = set(), set() \n        \n        def dfs(r, c, visit, prev_height):\n            # if position is already been visited or \n            # if it's out of bounds or if height is to small\n            if ((r, c) in visit or \n                r < 0 or c < 0 or r == rows or c == cols or\n                heights[r][c] < prev_height): \n                return\n            # visit new cell\n            visit.add((r, c)) \n            # run dfs on all four of those neighbours\n            dfs(r + 1, c, visit, heights[r][c])\n            dfs(r - 1, c, visit, heights[r][c])\n            dfs(r, c + 1, visit, heights[r][c])   \n            dfs(r, c - 1, visit, heights[r][c])         \n        \n        # go through every single column in the first row\n        # for the first row and the last row\n        for c in range(cols): \n            dfs(0, c, pac, heights[0][c])\n            dfs(rows - 1, c, atl, heights[rows - 1][c])\n        # for the first column and the last column\n        for r in range(rows): \n            dfs(r, 0, pac, heights[r][0])\n            dfs(r, cols - 1, atl, heights[r][cols - 1])\n        \n        res = []\n        for r in range(rows):\n            for c in range(cols):\n                if (r, c) in pac and (r, c) in atl:\n                    res.append([r, c])\n        return res\n")))),(0,a.kt)("h2",{id:"approach-2-breadth-first-search"},"Approach 2: Breadth-First Search"),(0,a.kt)("p",null,'We will start at the "beaches" of each ocean, and find the highest point they reach using BFS. By storing those values in a set and doing it for both oceans, we can return the intersecting points of each set as we know if it rained, those high points will run off into both oceans.'),(0,a.kt)("p",null,"Note: Since we are finding the highest point we can reach from the beaches, we need to check that the cell we are looking at is either taller, or even in height than the cell we came from. If it is shorter, we would avoid continuing."),(0,a.kt)("p",null,"Time Complexity: $$O(m*n)$$ where m is the number of rows, and n is the number of columns. Our BFS will traverse each cell, check where they can reach, and will use a set to avoid repeated work."),(0,a.kt)("p",null,"Space Complexity: $$O(m",(0,a.kt)("em",{parentName:"p"},"n)$$. We will maintain 2 hash sets of points we can reach, as well as our queue will take up to $$O(m"),"n)$$ space."),(0,a.kt)(p,{mdxType:"Tabs"},(0,a.kt)(f,{value:"python",label:"Python",mdxType:"TabItem"},(0,a.kt)(m,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},'class Solution:\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n        # initialize the number of rows, cols and our visited sets.\n        ROWS, COLS = len(heights), len(heights[0])\n        pacific = set()\n        atlantic = set()\n        # BFS algorithm, takes an initial row, column starting point\n        # as well as a reference to which visited set we are using.\n        def bfs(r, c, visited):\n            # initialize q with starting row, col and the height\n            # of the current cell.\n            q = deque([(r,c, heights[r][c])])\n\n            while q:\n                # get row, col of current cell, and height of prev cell.\n                row, col, height = q.popleft()\n                # check we are in bounds, that we haven\'t visited the\n                # cell before and that if the current cells height\n                # is shorter than the previous cells height.\n                if (row < 0 or row >= ROWS\n                    or col < 0 or col >= COLS\n                    or (row,col) in visited\n                    or heights[row][col] < height):\n                    continue\n                # passed our check above we can add cell to visited\n                visited.add((row,col))\n                # check 4 adjacent cells to add to the queue.\n                for dr, dc in ((1,0), (-1,0), (0,1), (0,-1)):\n                    q.append((row + dr, col + dc, heights[row][col]))\n        # Our 2 loops here start our algorithm only from  the "beach squares.\n        # Every column in the first/last rows\n        for col in range(COLS):\n            # BFS for each column at the pacific and atlantic "beach".\n            # Pass a reference of the set we are starting our bfs from\n            # to our algorithm.\n            bfs(0, col, pacific)\n            bfs(ROWS - 1, col, atlantic)\n        # Every row in the first and last columns.\n        for row in range(ROWS):\n            # BFS for each row at the pacific and atlantic "beach."\n            bfs(row, 0, pacific)\n            bfs(row, COLS - 1, atlantic)\n        # Return the intersection of points inside our row.\n        # If they both reached the same high point, we know rain would\n        # run off into either ocean.\n        return pacific.intersection(atlantic)\n')))))}g.isMDXComponent=!0}}]);