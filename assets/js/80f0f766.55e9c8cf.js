"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[31514],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function m(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?m(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):m(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},m=Object.keys(e);for(a=0;a<m.length;a++)t=m[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var m=Object.getOwnPropertySymbols(e);for(a=0;a<m.length;a++)t=m[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var o=a.createContext({}),l=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=l(e.components);return a.createElement(o.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,m=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=l(t),c=r,h=p["".concat(o,".").concat(c)]||p[c]||d[c]||m;return t?a.createElement(h,i(i({ref:n},u),{},{components:t})):a.createElement(h,i({ref:n},u))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var m=t.length,i=new Array(m);i[0]=c;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var l=2;l<m;l++)i[l]=t[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},24020:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>y,frontMatter:()=>m,metadata:()=>s,toc:()=>l});var a=t(87462),r=(t(67294),t(3905));const m={description:"Author: @deepanshu-rawat6, @vigneshshiv, @radojicic23 | https://leetcode.com/problems/merge-sorted-array/",tags:["Array","Two Pointers","Sorting"]},i="0088 - Merge Sorted Array (Easy)",s={unversionedId:"0000-0099/merge-sorted-array-easy",id:"0000-0099/merge-sorted-array-easy",title:"0088 - Merge Sorted Array (Easy)",description:"Author: @deepanshu-rawat6, @vigneshshiv, @radojicic23 | https://leetcode.com/problems/merge-sorted-array/",source:"@site/solutions/0000-0099/0088-merge-sorted-array-easy.md",sourceDirName:"0000-0099",slug:"/0000-0099/merge-sorted-array-easy",permalink:"/solutions/0000-0099/merge-sorted-array-easy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0000-0099/0088-merge-sorted-array-easy.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Two Pointers",permalink:"/solutions/tags/two-pointers"},{label:"Sorting",permalink:"/solutions/tags/sorting"}],version:"current",sidebarPosition:88,frontMatter:{description:"Author: @deepanshu-rawat6, @vigneshshiv, @radojicic23 | https://leetcode.com/problems/merge-sorted-array/",tags:["Array","Two Pointers","Sorting"]},sidebar:"tutorialSidebar",previous:{title:"0084 - Largest Rectangle in Histogram (Hard)",permalink:"/solutions/0000-0099/largest-rectangle-in-histogram-hard"},next:{title:"0090 - Subsets II (Medium)",permalink:"/solutions/0000-0099/subsets-ii-medium"}},o={},l=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Brute Force",id:"approach-1-brute-force",level:2},{value:"Approach 2: Two Pointers",id:"approach-2-two-pointers",level:2},{value:"Approach 3: Two Pointers In-place (Optimal)",id:"approach-3-two-pointers-in-place-optimal",level:2}],u=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",n)},p=u("Tabs"),d=u("TabItem"),c=u("SolutionAuthor"),h={toc:l},g="wrapper";function y(e){let{components:n,...t}=e;return(0,r.kt)(g,(0,a.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"0088---merge-sorted-array-easy"},"0088 - Merge Sorted Array (Easy)"),(0,r.kt)("h2",{id:"problem-link"},"Problem Link"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/merge-sorted-array/"},"https://leetcode.com/problems/merge-sorted-array/")),(0,r.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.kt)("p",null,"You are given two integer arrays ",(0,r.kt)("inlineCode",{parentName:"p"},"nums1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"nums2"),", sorted in ",(0,r.kt)("strong",{parentName:"p"},"non-decreasing order"),", and two integers ",(0,r.kt)("inlineCode",{parentName:"p"},"m")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),", representing the number of elements in ",(0,r.kt)("inlineCode",{parentName:"p"},"nums1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"nums2")," respectively."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Merge")," ",(0,r.kt)("inlineCode",{parentName:"p"},"nums1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"nums2")," into a single array sorted in ",(0,r.kt)("strong",{parentName:"p"},"non-decreasing order"),"."),(0,r.kt)("p",null,"The final sorted array should not be returned by the function, but instead be ",(0,r.kt)("em",{parentName:"p"},"stored inside the array")," ",(0,r.kt)("inlineCode",{parentName:"p"},"nums1"),". To accommodate this, ",(0,r.kt)("inlineCode",{parentName:"p"},"nums1")," has a length of ",(0,r.kt)("inlineCode",{parentName:"p"},"m + n"),", where the first ",(0,r.kt)("inlineCode",{parentName:"p"},"m")," elements denote the elements that should be merged, and the last ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," elements are set to ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," and should be ignored. ",(0,r.kt)("inlineCode",{parentName:"p"},"nums2")," has a length of ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\nOutput: [1,2,2,3,5,6]\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: nums1 = [1], m = 1, nums2 = [], n = 0\nOutput: [1]\nExplanation: The arrays we are merging are [1] and [].\nThe result of the merge is [1].\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 3:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: nums1 = [0], m = 0, nums2 = [1], n = 1\nOutput: [1]\nExplanation: The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Constraints:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"nums1.length == m + n")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"nums2.length == n")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"0 <= m, n <= 200")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"1 <= m + n <= 200")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"-10^9 <= nums1[i], nums2[j] <= 10^9"))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Follow up:")," Can you come up with an algorithm that runs in ",(0,r.kt)("inlineCode",{parentName:"p"},"O(m + n)")," time?"),(0,r.kt)("h2",{id:"approach-1-brute-force"},"Approach 1: Brute Force"),(0,r.kt)("p",null,"Since, this problem is under easy category, we know $nums1$ has length $m + n$ so we add the elements of $nums2$ in the empty spaces of $nums1$. Finally, we sort the $nums1$ with any standard sorting algorithm. This solution gives $O(N log N)$ time complexity and $O(1)$ space complexity."),(0,r.kt)(p,{mdxType:"Tabs"},(0,r.kt)(d,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)(c,{name:"@deepanshu-rawat6",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        // adding elements of nums2 at empty places of nums1\n        // starting at index m\n        for(int i = 0; i < n; i++) {\n            nums1[m + i] = nums2[i];\n        }\n        // sorting nums1 in an ascending order\n        Arrays.sort(nums1);\n    }\n}\n"))),(0,r.kt)(d,{value:"python",label:"Python",mdxType:"TabItem"},(0,r.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        # adding elements of nums2 at empty places of nums1\n        for i in range(n):\n            nums1[m + i] = nums2[i]\n        # sort nums1\n        nums1.sort()\n"))),(0,r.kt)(d,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,r.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n * @param {number} n\n * @return {void} Do not return anything, modify nums1 in-place instead.\n */\nvar merge = function(nums1, m, nums2, n) {\n    for (i = 0; i < n; i++) {\n        nums1[m + i] = nums2[i];\n    }\n    nums1.sort(function(a, b) {return a - b});\n};\n"))),(0,r.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        for (int i = 0; i < n; i++) {\n            nums1[m + i] = nums2[i];\n        }\n        sort(nums1.begin(), nums1.end());\n    }\n};\n")))),(0,r.kt)("h2",{id:"approach-2-two-pointers"},"Approach 2: Two Pointers"),(0,r.kt)("p",null,"A better way to do it is using one-pass two pointer approach. We make a copy of $nums1$ into $temp$, then iterate through both arrays $nums2$ and $temp$ comparing their elements in ",(0,r.kt)("strong",{parentName:"p"},"ascending fashion")," with the help of two pointers $i$ and $j$,simultaneouslty adding the smaller elements into $nums1$. Finally, the bigger elements out of either $nums2$ or $temp$ are going to be added by seperately iterating over them if $i$ or $j$ satisfies the conditions.\nThis solution gives $O(m + n)$ or $O(n)$ time complexity and $O(m)$ or $O(n)$ space complexity."),(0,r.kt)(p,{mdxType:"Tabs"},(0,r.kt)(d,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)(c,{name:"@deepanshu-rawat6",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public void merge(int[] nums1 , int m , int[] nums2 , int n) {\n        int i = 0, j = 0, k = 0;\n        // making a temp copy of nums1, for easier swapping of elements\n        int[] temp = Arrays.copyOfRange(nums1 , 0 , m);\n        // loop till anyone array elements exhausts\n        while (i < m && j < n) {\n            // adding the elements into nums1 in ascending order\n            if (temp[i] < nums2[j]) {\n                nums1[k] = temp[i];\n                i++;\n            } else {\n                nums1[k] = nums2[j];\n                j++;\n            }\n            k++;\n        }\n        // now adding the left out elements either of temp or nums2\n        // Either one of the loops will execute because every time one array's length\n        // would come out to be shorter than the other one\n        while (i < m) {\n            nums1[k] = temp[i];\n            k++;\n            i++;\n        }\n        while (j < n) {\n            nums1[k] = nums2[j];\n            k++;\n            j++;\n        }\n    }\n}\n"))),(0,r.kt)(d,{value:"python",label:"Python",mdxType:"TabItem"},(0,r.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        # last element of nums1\n        last = m + n - 1\n        # merge them in reverse order \n        while m > 0 and n > 0:\n            # find the largest value \n            if nums1[m - 1] > nums2[n - 1]:\n                nums1[last] = nums1[m - 1]\n                m -= 1\n            else:\n                nums1[last] = nums2[n - 1]\n                n -= 1\n            last -= 1\n        # edge case \n        # fill nums1 with leftover of nums2 elements\n        while n > 0:\n            nums1[last] = nums2[n - 1]\n            n -= 1\n            last -= 1\n"))),(0,r.kt)(d,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,r.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n * @param {number} n\n * @return {void} Do not return anything, modify nums1 in-place instead.\n */\nvar merge = function(nums1, m, nums2, n) {\n    // last element of nums1\n    let last = m + n - 1;\n    // merge them in reverse order\n    while (m > 0 && n > 0) {\n        // find the largest value \n        if (nums1[m - 1] > nums2[n - 1]) {\n            nums1[last] = nums1[m - 1];\n            m--;\n        } else {\n            nums1[last] = nums2[n - 1];\n            n--;\n        }\n        last--;\n    }\n    // edge case\n    // fill nums1 with leftover of nums2 elements\n    while (n > 0) {\n        nums1[last] = nums2[n - 1];\n        n--;\n        last--;\n    }\n};\n"))),(0,r.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        // last element  of nums1\n        int last = m + n - 1;\n        // merge them in reverse order\n        while (m > 0 && n > 0) {\n            // find the largest value \n            if (nums1[m - 1] > nums2[n - 1]) {\n                nums1[last] = nums1[m - 1];\n                m--;\n            } else {\n                nums1[last] = nums2[n - 1];\n                n--;\n            }\n            last--;\n        }\n        // fill nums1 with leftover of nums2 elements\n        while (n > 0) {\n            nums1[last] = nums2[n - 1];\n            n--;\n            last--;\n        }\n    }\n};\n")))),(0,r.kt)("h2",{id:"approach-3-two-pointers-in-place-optimal"},"Approach 3: Two Pointers In-place (Optimal)"),(0,r.kt)("p",null,"As we know, $nums1$ can hold size of $m + n$ array, which can have empty slots at the end to move $nums2$ array. "),(0,r.kt)("p",null,"Since the array is already sorted, we can place the elements from highest to lowest in $nums1$ by moving from last slot to first. "),(0,r.kt)("p",null,"Time Complexity: $O(m + n)$, where, $m$ - length of nums1, $n$ - length of nums2"),(0,r.kt)("p",null,"Space complexity: $O(1)$"),(0,r.kt)(p,{mdxType:"Tabs"},(0,r.kt)(d,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)(c,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        // index position for array placements\n        int idx = nums1.length - 1; m -= 1; n -= 1;\n        while (n >= 0) {\n            // Place elements from right direction to left. \n            if (m >= 0 && nums1[m] > nums2[n]) {\n                nums1[idx] = nums1[m--];\n            } else {\n                nums1[idx] = nums2[n--];\n            }\n            idx--;\n        }\n    }\n}\n"))),(0,r.kt)(d,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,r.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"/**\n * @param {number[]} nums1\n * @param {number} m\n * @param {number[]} nums2\n * @param {number} n\n * @return {void} Do not return anything, modify nums1 in-place instead.\n */\nvar merge = function(nums1, m, nums2, n) {\n    let index = m + n - 1;\n    let a = m - 1;\n    let b = n - 1;\n    while (b >= 0) {\n        if (a >= 0 && nums1[a] > nums2[b]) {\n            nums1[index] = nums1[a--];\n        } else {\n            nums1[index] = nums2[b--];\n        }\n        index--;\n    }\n}\n"))),(0,r.kt)(d,{value:"py",label:"Python",mdxType:"TabItem"},(0,r.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        index = m + n - 1\n        a = m - 1\n        b = n - 1\n        while b >= 0:\n            if a >= 0 and nums1[a] > nums2[b]:\n                nums1[index] = nums1[a]\n                a -= 1\n            else:\n                nums1[index] = nums2[b]\n                b -= 1\n            index -= 1\n"))),(0,r.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int index = m + n - 1;\n        int a = m - 1, b = n - 1;\n        while (b >= 0) {\n            if (a >= 0 && nums1[a] > nums2[b]) {\n                nums1[index] = nums1[a--];\n            } else {\n                nums1[index] = nums2[b--];\n            }\n            index--;\n        }\n    }\n};\n")))))}y.isMDXComponent=!0}}]);