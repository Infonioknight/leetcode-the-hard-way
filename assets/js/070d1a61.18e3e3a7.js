"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[14671],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>k});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),p=u(n),d=r,k=p["".concat(l,".").concat(d)]||p[d]||c[d]||i;return n?a.createElement(k,s(s({ref:t},m),{},{components:n})):a.createElement(k,s({ref:t},m))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[p]="string"==typeof e?e:r,s[1]=o;for(var u=2;u<i;u++)s[u]=n[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},70949:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>k,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var a=n(87462),r=(n(67294),n(3905));const i={description:"Author: @wingkwong | https://leetcode.com/problems/maximum-students-taking-exam/"},s="1349 - Maximum Students Taking Exam (Hard)",o={unversionedId:"1300-1399/maximum-students-taking-exam-hard",id:"1300-1399/maximum-students-taking-exam-hard",title:"1349 - Maximum Students Taking Exam (Hard)",description:"Author: @wingkwong | https://leetcode.com/problems/maximum-students-taking-exam/",source:"@site/solutions/1300-1399/1349-maximum-students-taking-exam-hard.md",sourceDirName:"1300-1399",slug:"/1300-1399/maximum-students-taking-exam-hard",permalink:"/solutions/1300-1399/maximum-students-taking-exam-hard",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1300-1399/1349-maximum-students-taking-exam-hard.md",tags:[],version:"current",sidebarPosition:1349,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/maximum-students-taking-exam/"},sidebar:"tutorialSidebar",previous:{title:"1347 - Minimum Number of Steps to Make Two Strings Anagram (Easy)",permalink:"/solutions/1300-1399/minimum-number-of-steps-to-make-two-strings-anagram-medium"},next:{title:"1356 - Sort Integers by The Number of 1 Bits (Easy)",permalink:"/solutions/1300-1399/sort-integers-by-the-number-of-1-bits-easy"}},l={},u=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Bit Masking",id:"approach-1-bit-masking",level:2}],m=(p="SolutionAuthor",function(e){return console.warn("Component "+p+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",e)});var p;const c={toc:u},d="wrapper";function k(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"1349---maximum-students-taking-exam-hard"},"1349 - Maximum Students Taking Exam (Hard)"),(0,r.kt)("h2",{id:"problem-link"},"Problem Link"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/maximum-students-taking-exam/"},"https://leetcode.com/problems/maximum-students-taking-exam/")),(0,r.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.kt)("p",null,"Given a ",(0,r.kt)("inlineCode",{parentName:"p"},"m * n")," matrix ",(0,r.kt)("inlineCode",{parentName:"p"},"seats"),"  that represent seats distributions in a classroom. If a seat is broken, it is denoted by ",(0,r.kt)("inlineCode",{parentName:"p"},"'#'")," character otherwise it is denoted by a ",(0,r.kt)("inlineCode",{parentName:"p"},"'.'")," character."),(0,r.kt)("p",null,"Students can see the answers of those sitting next to the left, right, upper left and upper right, but he cannot see the answers of the student sitting directly in front or behind him. Return the ",(0,r.kt)("strong",{parentName:"p"},"maximum")," number of students that can take the exam together without any cheating being possible.."),(0,r.kt)("p",null,"Students must be placed in seats in good condition."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1:")),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2020/01/29/image.png",alt:null})),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Input: seats = [["#",".","#","#",".","#"],\n                [".","#","#","#","#","."],\n                ["#",".","#","#",".","#"]]\nOutput: 4\nExplanation: Teacher can place 4 students in available seats so they don\'t cheat on the exam. \n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Input: seats = [[".","#"],\n                ["#","#"],\n                ["#","."],\n                ["#","#"],\n                [".","#"]]\nOutput: 3\nExplanation: Place all students in available seats. \n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 3:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Input: seats = [["#",".",".",".","#"],\n                [".","#",".","#","."],\n                [".",".","#",".","."],\n                [".","#",".","#","."],\n                ["#",".",".",".","#"]]\nOutput: 10\nExplanation: Place students in available seats in column 1, 3 and 5. \n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Constraints:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"seats")," contains only characters ",(0,r.kt)("inlineCode",{parentName:"li"},"'.' and'#'.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"m == seats.length")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"n == seats[i].length")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"1 <= m <= 8")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"1 <= n <= 8"))),(0,r.kt)("h2",{id:"approach-1-bit-masking"},"Approach 1: Bit Masking"),(0,r.kt)("p",null,"We can use bit masking approach in this problem where $$1$$ means a student is sitting at $$j$$-th place and $$0$$ means the seat at $$j$$-th place is empty. For example, $$10001_2$$ means there are two students sitting in leftmost and rightmost place while the middle three seats are empty."),(0,r.kt)("p",null,"First we need to know where are the broken seats for each row first. We can simply iterate each seats and store the result in $$broken","[i]","$$ where $$i$$ is the row number. Then We can use DP to calculate the answer row by row. We iterate each row, iterate each mask $$curMask$$ and iterate each previous mask $$prevMask$$."),(0,r.kt)("p",null,"For $$curMask$$, we need to skip some cases."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"If there is a student sitting on a broken seat"),(0,r.kt)("li",{parentName:"ol"},"If there is a student sitting next to the left of another student"),(0,r.kt)("li",{parentName:"ol"},"If there is a student sitting next to the right of another student")),(0,r.kt)("p",null,"For $$prevMask$$, we also need to skip some cases."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"If there is a student sitting on upper left"),(0,r.kt)("li",{parentName:"ol"},"If there is a student sitting on upper right")),(0,r.kt)("p",null,"Otherwise, we can calculate $$dp","[row][curMask]","$$ by taking the previous row with previous mask value plus the number of students who can seat on $$row$$ (i.e. number of $$1s$$ in $$curMask$$). The answer is the maximum mask of $$dp","[n]","$$."),(0,r.kt)(m,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int maxStudents(vector<vector<char>>& seats) {\n        int n = seats.size(), m = seats[0].size();\n        vector<int> broken(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (seats[i][j] == '#') {\n                    broken[i] |= 1 << j;\n                }\n            }\n        }\n        // dp[i][j]: \n        // the maximum number of students that can take the exam together \n        // without any cheating being possible at row i with j mask\n        vector<vector<int>> dp(n + 1, vector<int>(1 << m, 0));\n        for (int row = 1; row <= n; row++) {\n            for (int curMask = 0; curMask < 1 << m; curMask++) {\n                if (\n                    // there is a student sitting on a broken seat\n                    curMask & broken[row - 1] || \n                    // there is a student sitting next to the left of another student\n                    curMask & (curMask >> 1) ||\n                    // If there is a student sitting next to the right of another student\n                    curMask & (curMask << 1)\n                   ) {\n                    continue;\n                }\n                for (int prevMask = 0; prevMask < 1 << m; prevMask++) {\n                    if (\n                        // there is a student sitting on upper left \n                        (prevMask >> 1) & curMask || \n                        // there is a student sitting on upper right\n                        (prevMask << 1) & curMask\n                    ) {\n                        continue;\n                    }\n                    // previous result + the number of students who can seat on this row\n                    dp[row][curMask] = max(dp[row][curMask], dp[row - 1][prevMask] + __builtin_popcount(curMask));\n                }\n            }\n        }\n        // return the max mask on the last row\n        return *max_element(dp[n].begin(), dp[n].end());\n    }\n};\n")))}k.isMDXComponent=!0}}]);