"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[52165],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>g});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),m=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=m(e.components);return r.createElement(s.Provider,{value:n},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=m(t),d=a,g=p["".concat(s,".").concat(d)]||p[d]||c[d]||i;return t?r.createElement(g,o(o({ref:n},u),{},{components:t})):r.createElement(g,o({ref:n},u))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[p]="string"==typeof e?e:a,o[1]=l;for(var m=2;m<i;m++)o[m]=t[m];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},94865:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>k,frontMatter:()=>i,metadata:()=>l,toc:()=>m});var r=t(87462),a=(t(67294),t(3905));const i={description:"Author: @wingkwong, @ganajayant, @deepanshu-rawat6 | https://leetcode.com/problems/sort-an-array/",tags:["sorting"]},o="0912 - Sort an Array (Medium)",l={unversionedId:"0900-0999/sort-an-array-medium",id:"0900-0999/sort-an-array-medium",title:"0912 - Sort an Array (Medium)",description:"Author: @wingkwong, @ganajayant, @deepanshu-rawat6 | https://leetcode.com/problems/sort-an-array/",source:"@site/solutions/0900-0999/0912-sort-an-array-medium.md",sourceDirName:"0900-0999",slug:"/0900-0999/sort-an-array-medium",permalink:"/solutions/0900-0999/sort-an-array-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0900-0999/0912-sort-an-array-medium.md",tags:[{label:"sorting",permalink:"/solutions/tags/sorting"}],version:"current",sidebarPosition:912,frontMatter:{description:"Author: @wingkwong, @ganajayant, @deepanshu-rawat6 | https://leetcode.com/problems/sort-an-array/",tags:["sorting"]},sidebar:"tutorialSidebar",previous:{title:"0909 - Snakes and Ladders (Medium)",permalink:"/solutions/0900-0999/snakes-and-ladders-medium"},next:{title:"0918 - Maximum Sum Circular Subarray (Medium)",permalink:"/solutions/0900-0999/maximum-sum-circular-subarray-medium"}},s={},m=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: STL",id:"approach-1-stl",level:2},{value:"Standard STL Sort",id:"standard-stl-sort",level:3},{value:"Stable STL Sort",id:"stable-stl-sort",level:3},{value:"Approach 2: Quick Sort",id:"approach-2-quick-sort",level:2},{value:"Quick Sort with Fixed Pivot (TLE)",id:"quick-sort-with-fixed-pivot-tle",level:3},{value:"Quick Sort with Randomised Pivot (TLE)",id:"quick-sort-with-randomised-pivot-tle",level:3},{value:"Approach 3: Merge Sort",id:"approach-3-merge-sort",level:2},{value:"Merge Sort with Outplace Merging",id:"merge-sort-with-outplace-merging",level:3},{value:"In mergeSort() function:",id:"in-mergesort-function",level:4},{value:"In merge() function:",id:"in-merge-function",level:4},{value:"Merge Sort using In-place Merging",id:"merge-sort-using-in-place-merging",level:3},{value:"In mergeSort() function:",id:"in-mergesort-function-1",level:4},{value:"In mergeInPlace() function:",id:"in-mergeinplace-function",level:4},{value:"Approach 4: Couting Sort",id:"approach-4-couting-sort",level:2}],u=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",n)},p=u("Tabs"),c=u("TabItem"),d=u("SolutionAuthor"),g={toc:m},h="wrapper";function k(e){let{components:n,...t}=e;return(0,a.kt)(h,(0,r.Z)({},g,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"0912---sort-an-array-medium"},"0912 - Sort an Array (Medium)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/sort-an-array/"},"https://leetcode.com/problems/sort-an-array/")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"Given an array of integers ",(0,a.kt)("inlineCode",{parentName:"p"},"nums"),", sort the array in ascending order."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: nums = [5,2,3,1]\nOutput: [1,2,3,5]\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: nums = [5,1,1,2,0,0]\nOutput: [0,0,1,1,2,5]\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= nums.length <= 5 * 10^4")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"-5 * 10^4 <= nums[i] <= 5 * 10^4"))),(0,a.kt)("h2",{id:"approach-1-stl"},"Approach 1: STL"),(0,a.kt)("h3",{id:"standard-stl-sort"},"Standard STL Sort"),(0,a.kt)(p,{mdxType:"Tabs"},(0,a.kt)(c,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"void standardSTLSort(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n}\n"))),(0,a.kt)(c,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.kt)(d,{name:"@ganajayant",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public int[] sortArray(int[] nums) {\n        Arrays.sort(nums);\n        return nums;\n    }\n}\n")))),(0,a.kt)("h3",{id:"stable-stl-sort"},"Stable STL Sort"),(0,a.kt)(p,{mdxType:"Tabs"},(0,a.kt)(c,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"void stableSTLSort(vector<int>& nums) {\n    stable_sort(nums.begin(), nums.end());\n}\n")))),(0,a.kt)("h2",{id:"approach-2-quick-sort"},"Approach 2: Quick Sort"),(0,a.kt)("h3",{id:"quick-sort-with-fixed-pivot-tle"},"Quick Sort with Fixed Pivot (TLE)"),(0,a.kt)(p,{mdxType:"Tabs"},(0,a.kt)(c,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"int partition(vector<int>& nums, int l, int r) {\n    int pivot = nums[r];\n    int i = l - 1;\n    for (int j = l; j <= r - 1; j++) {\n        if (nums[j] < pivot) {\n            i++;\n            swap(nums[i], nums[j]);\n        }\n    }\n    swap(nums[i + 1], nums[r]);\n    return i + 1;\n}\n\nvoid quickSort(vector<int>& nums, int l, int r) {\n    if (l < r) {\n        int pivot = partition(nums, l, r);\n        quickSort(nums, l, pivot - 1);\n        quickSort(nums, pivot + 1, r);\n    }\n}\n"))),(0,a.kt)(c,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.kt)(d,{name:"@ganajayant",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public static void quicksort(int l, int r) {\n        if (l < r) {\n            int mid = partition(l, r);\n            quicksort(l, mid - 1);\n            quicksort(mid + 1, r);\n        }\n    }\n\n    public static int partition(int l, int r) {\n        int pivot = ar[r];\n        int i = (l - 1);\n\n        for (int j = l; j <= r - 1; j++) {\n            if (ar[j] < pivot) {\n                i++;\n                int temp = ar[i];\n                ar[i] = ar[j];\n                ar[j] = temp;\n            }\n        }\n        int temp = ar[i + 1];\n        ar[i + 1] = ar[r];\n        ar[r] = temp;\n        return (i + 1);\n    }\n}\n")))),(0,a.kt)("h3",{id:"quick-sort-with-randomised-pivot-tle"},"Quick Sort with Randomised Pivot (TLE)"),(0,a.kt)(p,{mdxType:"Tabs"},(0,a.kt)(c,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"int partition(vector<int>& nums, int l, int r) {\n    int pivot = nums[r];\n    int i = l - 1;\n    for (int j = l; j <= r - 1; j++) {\n        if (nums[j] < pivot) {\n            i++;\n            swap(nums[i], nums[j]);\n        }\n    }\n    swap(nums[i + 1], nums[r]);\n    return i + 1;\n}\n\nvoid quickSort(vector<int>& nums, int l, int r) {\n    if (l < r) {\n        swap(nums[l + rand() % (r - l)], nums[r]);\n        int pivot = partition(nums, l, r);\n        quickSort(nums, l, pivot - 1);\n        quickSort(nums, pivot + 1, r);\n    }\n}\n")))),(0,a.kt)("h2",{id:"approach-3-merge-sort"},"Approach 3: Merge Sort"),(0,a.kt)("p",null,"Standard merge sort algorithm, following a divide and conquer approach, division of sub-array by mid values till sub-array length\nreaches one, then merging parts by either out-place or in-place merging in either ascending or descending order. "),(0,a.kt)("h3",{id:"merge-sort-with-outplace-merging"},"Merge Sort with Outplace Merging"),(0,a.kt)("p",null,"In this approach, merging happen in seperate array of size, then it is passed on in the above function calls."),(0,a.kt)("h4",{id:"in-mergesort-function"},"In mergeSort() function:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Dividing the array into 2 subarrays(one is $left$ and other is $right$) till their length reaches one(because no futher division can take place)"),(0,a.kt)("li",{parentName:"ul"},"Then passing left and right parts into merge() function for sorting in correct order.")),(0,a.kt)("h4",{id:"in-merge-function"},"In merge() function:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"We merge the two subarrays( $left$ and $right$ ) into another array $mix$ . "),(0,a.kt)("li",{parentName:"ul"},"This merge operation stores elements from  $left$ and $right$ in an ascending order, by comparing elements from individual subarrays. "),(0,a.kt)("li",{parentName:"ul"},"Finally, since one subarray would have greater elements then the other one, so we add those elements seperately. Then, we return the sorted subarray into the above function call.")),(0,a.kt)("p",null,"This solution gives $O(n log n)$ time complexity and $O(n)$ space complexity."),(0,a.kt)(p,{mdxType:"Tabs"},(0,a.kt)(c,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.kt)(d,{name:"@deepanshu-rawat6",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public int[] sortArray(int[] nums) {\n        return mergeSort(nums);\n    }\n    public static int[] mergeSort(int[] arr) {\n        if (arr.length == 1) {\n            return arr;\n        }\n\n        int mid = arr.length / 2;\n        // copying and sorting sub-array by division on the basis of mid value\n        int[] left = mergeSort(Arrays.copyOfRange(arr, 0, mid));\n        int[] right = mergeSort(Arrays.copyOfRange(arr, mid, arr.length));\n\n        // now merging the two subarrays into one sorted subarray\n        return merge(left, right);\n    }\n\n    public static int[] merge(int[] first, int[] second) {\n        int[] mix = new int[first.length + second.length];\n\n        int i = 0;\n        int j = 0;\n        int k = 0;\n        // adding elements in the mix array in ascending order\n        while (i < first.length && j < second.length) {\n            if (first[i] < second[j]) {\n                mix[k] = first[i];\n                i++;    \n            } else {\n                mix[k] = second[j];\n                j++;\n            }\n            k++;\n        }\n\n        // it may be possible that one of the arrays is not complete\n        // copy the remaining elements\n        while (i < first.length) {\n            mix[k] = first[i];\n            i++;\n            k++;\n        }\n\n        while (j < second.length) {\n            mix[k] = second[j];\n            j++;\n            k++;\n        }\n\n        return mix;\n    }\n}\n")))),(0,a.kt)("h3",{id:"merge-sort-using-in-place-merging"},"Merge Sort using In-place Merging"),(0,a.kt)("p",null,"In this approach, merging happens in-place, changes are made in the original arrays itself by modifying the reference variables. "),(0,a.kt)("h4",{id:"in-mergesort-function-1"},"In mergeSort() function:"),(0,a.kt)("p",null,"Dividing the array into 2 subarrays(by calling mergeSort() function recursively) till their length reaches one."),(0,a.kt)("h4",{id:"in-mergeinplace-function"},"In mergeInPlace() function:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"We merge the two subarrays(one from s to mid and another from mid to e) into another array $mix$ . "),(0,a.kt)("li",{parentName:"ul"},"This merge operation stores elements from the two sub-arrays in an ascending order, by comparing elements from individual subarrays. - - Finally, since one subarray would have greater elements then the other one, so we add those elements seperately. "),(0,a.kt)("li",{parentName:"ul"},"Then, we place the sorted elements from $mix$ into $arr$ , finally changes in $arr$ have been made in-place.")),(0,a.kt)("p",null,"This solution gives $O(n log n)$ time complexity and $O(1)$ space complexity."),(0,a.kt)(p,{mdxType:"Tabs"},(0,a.kt)(c,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.kt)(d,{name:"@deepanshu-rawat6",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public int[] sortArray(int[] nums) {\n        mergeSort(nums, 0, nums.length);\n        return nums;\n    }\n    public void mergeSort(int[] arr, int s, int e) {\n        if (e - s == 1) {\n            return;\n        }\n\n        int mid = (s + e) / 2;\n        // dividing sub-arrays by mid values till, sub-array length reaches one\n        mergeSort(arr, s, mid);\n        mergeSort(arr, mid, e);\n\n        // sorting the left portion(s to mid) and right portion(mid to e) into the same array arr\n        mergeInPlace(arr, s, mid, e);\n    }\n\n    public static void mergeInPlace(int[] arr, int s, int m, int e) {\n        int[] mix = new int[e - s];\n\n        int i = s;\n        int j = m;\n        int k = 0;\n        // adding elements in the mix array in ascending order\n        while (i < m && j < e) {\n            if (arr[i] < arr[j]) {\n                mix[k] = arr[i];\n                i++;\n            } else {\n                mix[k] = arr[j];\n                j++;\n            }\n            k++;\n        }\n\n        // it may be possible that one of the arrays is not complete\n        // copy the remaining elements\n        while (i < m) {\n            mix[k] = arr[i];\n            i++;\n            k++;\n        }\n\n        while (j < e) {\n            mix[k] = arr[j];\n            j++;\n            k++;\n        }\n\n        // modifying the original arrays by replacing elements into their correct indices\n        for (int l = 0; l < mix.length; l++) {\n            arr[s + l] = mix[l];\n        }\n    }\n}\n")))),(0,a.kt)("h2",{id:"approach-4-couting-sort"},"Approach 4: Couting Sort"),(0,a.kt)(p,{mdxType:"Tabs"},(0,a.kt)(c,{value:"py",label:"Python",mdxType:"TabItem"},(0,a.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        b = [0] * 100005\n        for x in nums:\n            b[x + 50000] += 1\n        ans = []\n        for i, v in enumerate(b, -50000):\n            ans.extend([i] * v)\n        return ans\n")))))}k.isMDXComponent=!0}}]);