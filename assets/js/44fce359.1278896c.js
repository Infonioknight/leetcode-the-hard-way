"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[78918],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=c(n),h=o,d=m["".concat(l,".").concat(h)]||m[h]||p[h]||i;return n?a.createElement(d,r(r({ref:t},u),{},{components:n})):a.createElement(d,r({ref:t},u))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[m]="string"==typeof e?e:o,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},94227:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>g,frontMatter:()=>i,metadata:()=>s,suggestedProblems:()=>u,toc:()=>c});var a=n(87462),o=(n(67294),n(3905));const i={title:"Combinatorics",description:"Combinatorics is the branch of mathematics dealing with counting and enumerating the possibilities for a certain event to occur. It is heavily used as it enables us to find very short and concise answers to many problems.",hide_table_of_contents:!1,keywords:["leetcode","tutorial","combinatorics"]},r=void 0,s={unversionedId:"math/combinatorics",id:"math/combinatorics",title:"Combinatorics",description:"Combinatorics is the branch of mathematics dealing with counting and enumerating the possibilities for a certain event to occur. It is heavily used as it enables us to find very short and concise answers to many problems.",source:"@site/tutorials/math/combinatorics.md",sourceDirName:"math",slug:"/math/combinatorics",permalink:"/tutorials/math/combinatorics",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/math/combinatorics.md",tags:[],version:"current",frontMatter:{title:"Combinatorics",description:"Combinatorics is the branch of mathematics dealing with counting and enumerating the possibilities for a certain event to occur. It is heavily used as it enables us to find very short and concise answers to many problems.",hide_table_of_contents:!1,keywords:["leetcode","tutorial","combinatorics"]},sidebar:"tutorialSidebar",previous:{title:"Bit Manipulation",permalink:"/tutorials/math/bit-manipulation"},next:{title:"Strings",permalink:"/tutorials/category/strings"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Finding $n choose r$",id:"finding-n-choose-r",level:2},{value:"Example #1: 2221 - Find Triangular Sum of an Array",id:"example-1-2221---find-triangular-sum-of-an-array",level:3},{value:"Finding the $n^{th}$ catalan number",id:"finding-the-nth-catalan-number",level:2},{value:"Example #2: 1863 - Sum of All Subset XOR Totals",id:"example-2-1863---sum-of-all-subset-xor-totals",level:3},{value:"Example #3: 0062 - Unique Paths",id:"example-3-0062---unique-paths",level:3},{value:"Example #4: 2400 - Number of Ways to Reach a Position After Exactly k Steps",id:"example-4-2400---number-of-ways-to-reach-a-position-after-exactly-k-steps",level:3},{value:"References",id:"references",level:2}],u=[{problemName:"920 - Number of Music Playlists",difficulty:"Hard",leetCodeLink:"https://leetcode.com/problems/number-of-music-playlists/",solutionLink:""},{problemName:"1916 - Count Ways to Build Rooms in an Ant Colony",difficulty:"Hard",leetCodeLink:"https://leetcode.com/problems/count-ways-to-build-rooms-in-an-ant-colony/",solutionLink:"../../solutions/1900-1999/count-ways-to-build-rooms-in-an-ant-colony"},{problemName:"1467 - Probability of a Two Boxes Having The Same Number of Distinct Balls",difficulty:"Hard",leetCodeLink:"https://leetcode.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/",solutionLink:""}],m=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",t)},p=m("TutorialAuthors"),h=m("Tabs"),d=m("TabItem"),f=m("Table"),b={toc:c,suggestedProblems:u},$="wrapper";function g(e){let{components:t,...n}=e;return(0,o.kt)($,(0,a.Z)({},b,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)(p,{names:"@BlackPanther112358",mdxType:"TutorialAuthors"}),(0,o.kt)("h2",{id:"overview"},"Overview"),(0,o.kt)("p",null,"Combinatorics is primarily involved with art of counting. This includes counting number of ways for a certain position to occur, to arrange some objects according to given rules or choosing some objects from a collection. Quite often, the required number takes a very large value, thus it is a very common practice to return the answer by taking modulo with some prime number $p$ (which is $1e9 + 7$ quite often, and quite recently $998244353$ also has become prominent). You can read more about modulo ",(0,o.kt)("a",{parentName:"p",href:"/tutorials/basic-topics/mod"},"here"),"."),(0,o.kt)("h2",{id:"finding-n-choose-r"},"Finding $n \\choose r$"),(0,o.kt)("p",null,'Pronounced "n choose r", this is the mathematical notation to represent number of ways to choose r objects out of a collection of n objects. The analytical formula can be written as $n \\choose r$ $=$ $\\frac{n!}{r!\\,(n - r)!}$.'),(0,o.kt)("p",null,"This leads to a neat recurrence relation: $n \\choose r$ $=$ $n - 1 \\choose r$ + $n - 1 \\choose r - 1$ $","\\","$"),(0,o.kt)("p",null,"We can precompute all the required values using the above formula in $O(n^2)$ and then perform lookup in $O(1)$ time. The resulting values also form ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Pascal%27s_triangle"},"Pascal's Triangle"),"."),(0,o.kt)("h3",{id:"example-1-2221---find-triangular-sum-of-an-array"},"Example #1: ",(0,o.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/find-triangular-sum-of-an-array/"},"2221 - Find Triangular Sum of an Array")),(0,o.kt)("p",null,"The important insight here is that the figure provided is nothing but an inverted Pascal's Triangle and contribution of each cell in the final sum is the value of cell multiplied by the binomial coefficient at the particular position in Pascal's Triangle."),(0,o.kt)("p",null,"Thus for the cell at $i^{th}$ index in the topmost row, it's value is multiplied by $n - 1 \\choose i$ and added to the final sum $modulo\\,10$.\nTime Complexity of the program is $O(n^2)$ for computing the binomial coefficient and $O(n)$ Space complexity."),(0,o.kt)(h,{mdxType:"Tabs"},(0,o.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int triangularSum(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> pascalTriangleRow = {1};\n        // calculate the ith row using (i - 1)th row\n        for (int i = 0; i < n; i++) {\n            vector<int> nextRow = {1};\n            for(int j = 1; j < i; j++){\n                nextRow.push_back((pascalTriangleRow[j] + pascalTriangleRow[j - 1]) % 10);\n            }\n            nextRow.push_back(1);\n            pascalTriangleRow = nextRow;\n        }\n        // calculate the final answer as discussed above\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            ans += (nums[i] * pascalTriangleRow[i]) % 10;\n        }\n        return ans%10;\n    }\n};\n")))),(0,o.kt)("p",null,"Sometimes it is not possible to calculate the entirety of Pascal's Triangle due to larger values of $n$. In this case, we begin by precomputing\n$x!$$\\,$ $\\forall$$\\,$$x \\in ","[{0, n}]","$. Similarly, we will also ",(0,o.kt)("a",{parentName:"p",href:"https://cp-algorithms.com/algebra/module-inverse.html#mod-inv-all-num"},"precompute")," the modular inverses.  This can be achieved in $O(n)$ time. Thus we can now compute $n \\choose r$ using the analytical equation presented earlier. You can read about modular inverses ",(0,o.kt)("a",{parentName:"p",href:"/tutorials/basic-topics/mod"},"here")),(0,o.kt)("p",null,"The implementation of above can be as follows:"),(0,o.kt)(h,{mdxType:"Tabs"},(0,o.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"struct comb{\n    int mod;\n    // make arrays to store the factorial and inverse factorial modulo m\n    vector<long long int> factorial;\n    vector<long long int> inverse_factorial;\n\n    // N is the maximum value possible of input\n    comb (int N, int mod_in = 1e9 + 7) {\n        // calculate values for factorial\n        mod = mod_in;\n        factorial.push_back(1);\n        for(int i = 1; i <= N; i++) factorial.push_back((factorial.back() * i) % mod);\n\n        // calculate values for inverse factorial\n        vector<long long int> inverse;\n        inverse.push_back(1);\n        inverse.push_back(1);\n        inverse_factorial.push_back(1);\n        inverse_factorial.push_back(1);\n        for (int i = 2; i <= N; i++) {\n            inverse.push_back((mod - ((mod/i) * inverse[mod%i]) % mod) % mod);\n            inverse_factorial.push_back((inverse_factorial[i - 1] * inverse[i]) % mod);\n        }\n    }\n\n    // function to calculate nCr(n, r)\n    long long int nCr(int n, int r){\n        if ((r < 0) || (r > n)) return 0;\n        return ((factorial[n] * inverse_factorial[r]) % mod * inverse_factorial[n - r]) % mod;\n    }\n};\n")))),(0,o.kt)("p",null,"For further reading, you can visit ",(0,o.kt)("a",{parentName:"p",href:"https://cp-algorithms.com/combinatorics/binomial-coefficients.html"},"cp-algorithms"),"."),(0,o.kt)("h2",{id:"finding-the-nth-catalan-number"},"Finding the $n^{th}$ catalan number"),(0,o.kt)("p",null,"This is a very famous sequence of natural numbers and has a variety of applications."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Number of ways to make balanced bracket sequences using $n$ left and $n$ right brackets."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://leetcode.com/problems/unique-binary-search-trees/description/"},"Number of ways to make binary trees")),(0,o.kt)("li",{parentName:"ul"},"Number of ways to form a mountain range with $n$ upstrokes and downstrokes. $","\\","$")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Catalan_number#Applications_in_combinatorics"},"Here")," is a more exhastive list."),(0,o.kt)("p",null,"The $n^{th}$ Catalan number can be found using the formula:\n$C_n$ $=$ $\\frac{1}{n + 1}$$2n \\choose n$"),(0,o.kt)("h3",{id:"example-2-1863---sum-of-all-subset-xor-totals"},"Example #2: ",(0,o.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/sum-of-all-subset-xor-totals/description/"},"1863 - Sum of All Subset XOR Totals")),(0,o.kt)("p",null,"This is an example of a very tricky problem which heavily simplifies after using some Combinatorics and ",(0,o.kt)("a",{parentName:"p",href:"/tutorials/math/bit-manipulation"},"Bit Manipulation")),(0,o.kt)("p",null,"Here we will consider the $i^{th}$ bit from the right. Let's say that the $i^{th}$ bit is set in $k$ out of $n$ numbers in some given subset. If $k$ is odd, then $i^{th}$ bit is set in the XOR of all numbers of the subset, otherwise, it is not set."),(0,o.kt)("p",null,"Hence if there are $m$ numbers out of $n$ with $i^{th}$ bit set, then the contribution of the bit is $Place\\,value\\,of\\,the\\,bit$ $*$ $number\\,of\\,ways\\,to\\,get\\,odd\\,k$ "),(0,o.kt)("p",null,"Thus we can find $\\sum_{k = 1}^{k <= m}$ $m \\choose k$ for all odd values of $k$, which comes out to $2^{m - 1}$. Furthermore, we can choose the remaining elements in the subset in $2^{n - m}$ ways by similar logic. Hence total ways to get odd values of $k$ are $2^{n - 1}$, which is independent of both $m$ and $k$."),(0,o.kt)("p",null,"Hence all we need to do is find bits which are set atleast once (by computing OR) and then multiply the final answer with $2^{n - 1}$.\nTime Complexity of the program is $O(n)$ with $O(1)$ Space Complexity."),(0,o.kt)(h,{mdxType:"Tabs"},(0,o.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int subsetXORSum(vector<int>& nums) {\n        int arrayOR = 0;\n        // do OR of whole array to obtain bits which are set atleast once\n        for (int num : nums) arrayOR |= num;\n        // compute the final answer using the formula discussed\n        return arrayOR * (1 << (nums.size() - 1));\n    }\n};\n")))),(0,o.kt)("h3",{id:"example-3-0062---unique-paths"},"Example #3: ",(0,o.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/unique-paths/"},"0062 - Unique Paths")),(0,o.kt)("p",null,"Here our robot always goes either down or right. We know that we have to go down $m - 1$ times and go left $n - 1$ times. Thus we need to find the number of ways to arrange these. One way to visualize this is if we have $m + n - 2$ blank spaces, and we have to fill $n - 1$ of them using $R$ (representing going right) and remaining using $D$ (representing going down). Then we can just choose the number of spaces to fill with $L$ from total number of spaces. The the final solution is simply $m + n - 2 \\choose n - 1$."),(0,o.kt)("p",null,"Notice that we are not required to return the value after taking modulo and the constraints allow for a $O(n^2)$ precomputation. Thus, we will\nsimply construct the entire Pascal's Triangle and query it everytime to calculate the answer."),(0,o.kt)(h,{mdxType:"Tabs"},(0,o.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        // the upper limit is m + n - 2 = 198\n        vector<vector<long long int>> PascalTriangle(199, vector<long long int> ());\n        PascalTriangle[0] = {1};\n        // calculating every row of the triangle\n        for (int i = 1; i <= 198; i++) {\n            PascalTriangle[i].push_back(1);\n            // using the recurrence relation.\n            for (int j = 1; j < i; j++) {\n                // take mod with INT_MAX as otherwise some values may overflow.\n                PascalTriangle[i].push_back((PascalTriangle[i - 1][j] + PascalTriangle[i - 1][j - 1]) % INT_MAX);\n            }\n            PascalTriangle[i].push_back(1);\n        }\n        // query the final answer\n        return PascalTriangle[m + n - 2][n - 1];\n    }\n};\n")))),(0,o.kt)("p",null,'NOTE: Since every testcase only asks us to find $n \\choose r$ for particular values of $n$ and $r$, we can instead of precomputing the entire\nPascal\'s Triangle, just compute the paricular value of $n \\choose r$ using the recurrence relation and memoization. This will lead to less time\nand space complexity, as we only calculate the values we need. Also, then we no longer need to take modulo with INT_MAX as all the values will\nfit in the "int" type as mentioned in the question.'),(0,o.kt)("p",null,"You can check the complete solution for this problem ",(0,o.kt)("a",{parentName:"p",href:"../../solutions/0000-0099/unique-paths-medium"},"here")),(0,o.kt)("h3",{id:"example-4-2400---number-of-ways-to-reach-a-position-after-exactly-k-steps"},"Example #4: ",(0,o.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/"},"2400 - Number of Ways to Reach a Position After Exactly k Steps")),(0,o.kt)("p",null,"Let's represent going left as $-1$ and going right as $+1$. Thus, following the same idea as before, we have $k$ blanks to fill with $+1$ and\n$-1$ such that there sum is equal to $endPos - startPos$."),(0,o.kt)("p",null,"Here we can immediately see that such will be impossible in only 2 cases:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The parity of $k$ and $endPos - startPos$ is different."),(0,o.kt)("li",{parentName:"ul"},"The magnitude of $k$ is less than magnitude of $endPos - startPos$.")),(0,o.kt)("p",null,"After checking for above 2 cases, we know for sure that there exists a solution. Now we can just find the number of $1's$ and $-1's$ required\nto sum to $endPos - startPos$. Expressing this as an equation:"),(0,o.kt)("p",null,"$(1) ",(0,o.kt)("em",{parentName:"p"}," a + (-1) ")," b = endPos - startPos$, such that $a + b = k$"),(0,o.kt)("p",null,"Here $a$ represents the number of $1$, i.e., the right steps and similarly $b$ represents number of $-1$, i.e., the number of left steps. We\nare now interested in finding the number of possible values of $a$ and $b$ such that the above equations are satisfied."),(0,o.kt)("p",null,"Adding both equations, "),(0,o.kt)("p",null,"$2a$ $=$ $endPos - startPos + k$"),(0,o.kt)("p",null,"Thus, "),(0,o.kt)("p",null,"$a$ $=$ $\\frac{k \\, + \\, endPos \\, - \\, startPos}{2}$"),(0,o.kt)("p",null,"Similarly, by subtracting the equations and simplifying,"),(0,o.kt)("p",null,"$b$ $=$ $\\frac{k \\, - \\, endPos \\, + \\, startPos}{2}$"),(0,o.kt)("p",null,"Then the solution is $k \\choose a$ $=$ $k \\choose b$ as we need to find number of ways to choose $a$ or $b$ moves, out of $k$ moves."),(0,o.kt)("p",null,"Thus, we need to find $nCr$$(k, \\frac{k - endPos + startPos}{2})$."),(0,o.kt)("p",null,"To implement this, you can both precompute the entire Pascal's Triangle, or use concept of mudular inverses to find the required value."),(0,o.kt)("p",null,"You can check the complete solution for this problem ",(0,o.kt)("a",{parentName:"p",href:"../../solutions/2400-2499/number-of-ways-to-reach-a-position-after-exactly-k-steps-medium"},"here")),(0,o.kt)(f,{title:"Suggested Problems",data:u,mdxType:"Table"}),(0,o.kt)("h2",{id:"references"},"References"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("a",{parentName:"li",href:"https://cp-algorithms.com/"},"cp-algorithms"))))}g.isMDXComponent=!0}}]);