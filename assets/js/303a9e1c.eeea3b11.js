"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[45169],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),d=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=d(e.components);return r.createElement(s.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,u=a(e,["components","mdxType","originalType","parentName"]),p=d(n),m=i,h=p["".concat(s,".").concat(m)]||p[m]||c[m]||l;return n?r.createElement(h,o(o({ref:t},u),{},{components:n})):r.createElement(h,o({ref:t},u))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,o=new Array(l);o[0]=m;var a={};for(var s in t)hasOwnProperty.call(t,s)&&(a[s]=t[s]);a.originalType=e,a[p]="string"==typeof e?e:i,o[1]=a;for(var d=2;d<l;d++)o[d]=n[d];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},31691:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>f,frontMatter:()=>l,metadata:()=>a,toc:()=>d});var r=n(87462),i=(n(67294),n(3905));const l={description:"Author: @Kavita613, @vigneshshiv | https://leetcode.com/problems/add-two-numbers-ii/",tags:["Linked List","Math","Stack"]},o="0445 - Add two Numbers II (Medium)",a={unversionedId:"0400-0499/Add-Two-Numbers-II",id:"0400-0499/Add-Two-Numbers-II",title:"0445 - Add two Numbers II (Medium)",description:"Author: @Kavita613, @vigneshshiv | https://leetcode.com/problems/add-two-numbers-ii/",source:"@site/solutions/0400-0499/0445-Add-Two-Numbers-II.md",sourceDirName:"0400-0499",slug:"/0400-0499/Add-Two-Numbers-II",permalink:"/solutions/0400-0499/Add-Two-Numbers-II",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0400-0499/0445-Add-Two-Numbers-II.md",tags:[{label:"Linked List",permalink:"/solutions/tags/linked-list"},{label:"Math",permalink:"/solutions/tags/math"},{label:"Stack",permalink:"/solutions/tags/stack"}],version:"current",sidebarPosition:445,frontMatter:{description:"Author: @Kavita613, @vigneshshiv | https://leetcode.com/problems/add-two-numbers-ii/",tags:["Linked List","Math","Stack"]},sidebar:"tutorialSidebar",previous:{title:"0441 - Arranging Coins (Easy)",permalink:"/solutions/0400-0499/arranging-coins-easy"},next:{title:"0452 - Minimum Number of Arrows to Burst Balloons (Medium)",permalink:"/solutions/0400-0499/minimum-number-of-arrows-to-burst-balloons-medium"}},s={},d=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Recursion",id:"approach-1-recursion",level:2},{value:"Approach 2: Stack",id:"approach-2-stack",level:2}],u=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",t)},p=u("Tabs"),c=u("TabItem"),m=u("SolutionAuthor"),h={toc:d},k="wrapper";function f(e){let{components:t,...n}=e;return(0,i.kt)(k,(0,r.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"0445---add-two-numbers-ii-medium"},"0445 - Add two Numbers II (Medium)"),(0,i.kt)("h2",{id:"problem-link"},"Problem Link"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/add-two-numbers-ii/"},"https://leetcode.com/problems/add-two-numbers-ii/")),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit.\nAdd the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("img",{src:"https://assets.leetcode.com/uploads/2021/04/09/sumii-linked-list.jpg",alt:"Photo",height:"160"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: l1 = [7,2,4,3], l2 = [5,6,4]\nOutput: [7,8,0,7] \n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [8,0,7]\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 3:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: l1 = [0], l2 = [0]\nOutput: [0]\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The number of nodes in each linked list is in the range ",(0,i.kt)("inlineCode",{parentName:"li"},"[1, 100]"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0 <= Node.val <= 9")),(0,i.kt)("li",{parentName:"ul"},"It is guaranteed that the list represents a number that does not have leading zeros.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Follow up:"),(0,i.kt)("br",{parentName:"p"}),"\n","Could you solve it without reversing the input lists?"),(0,i.kt)("h2",{id:"approach-1-recursion"},"Approach 1: Recursion"),(0,i.kt)("p",null,"First, we will add zeros to the start of the smaller linked list such that both the lists become of equal size and then we will use recursion to perform and addition start to end."),(0,i.kt)("p",null,"For example - "),(0,i.kt)("p",null,"$list1: 7 -> 2 -> 4 -> 3$",(0,i.kt)("br",{parentName:"p"}),"\n","$list2: 5 -> 6 -> 4$"),(0,i.kt)("p",null,"After Adding zeros to the smaller linked list "),(0,i.kt)("p",null,"$list1: 7 -> 2 -> 4 -> 3$",(0,i.kt)("br",{parentName:"p"}),"\n","$list2: 0 -> 5 -> 6 -> 4$"),(0,i.kt)("p",null,"Now, we will use recursion (like reverse traversal) to the end of both the lists and start addition from the end. After each recursion ends, $l1$ and $l2$ will be at their last nodes. We will add the both node values and pass $carry$ from current recursive function to the previous recursive function, and each recursive call add the sum along with carry from the last previous call and builds the nodes in a reverse order."),(0,i.kt)("p",null,"For the above example, We traversed both linked list nodes till end of the list and added sum, passing the result to previous call."),(0,i.kt)("p",null,"$sum = l1 -> val + l2 -> val + carry$, and new_node -> val = sum%10, and $carry$ = sum/10  "),(0,i.kt)("p",null,"$sum = 3 + 4 + 0 = 7$, and new_node -> val = $7$, and recursive function will return with $carry = 0$  (last node of final linked list).\n$sum = 6 + 4 + 0 = 10$, and new_node -> val = $0$, and recursive function will return with $carry = 1$,\n$sum = 5 + 2 + 1 = 8$, and new_node -> val = $8$, and recursive function will return with $carry = 0$,\n$sum = 7 + 0 + 0 = 7$, and new_node -> val = $7$, and recursive function will return with $carry = 0$ (Head node of final linked list)"),(0,i.kt)("p",null,"Finally, our result will be $7 -> 8 -> 0 -> 7$"),(0,i.kt)("p",null,"Time Complexity is $O(n)$, where $n$ is the length of longest linked list."),(0,i.kt)("p",null,"Space Complexity is $O(n)$, where $n$ is the recursive call stack of the linked list."),(0,i.kt)(p,{mdxType:"Tabs"},(0,i.kt)(c,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)(m,{name:"@Kavita613",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"  /**  \n  * Definition for singly-linked list.  \n  * struct ListNode {  \n  *     int val;  \n  *     ListNode * next;  \n  *     ListNode() : val(0), next(nullptr) {}  \n  *     ListNode(int x) : val(x), next(nullptr) {}  \n  *     ListNode(int x, ListNode * next) : val(x), next(next) {}  \n  * };  \n  */\n\nclass Solution {\npublic:\n     ListNode * addDigits (ListNode * l1, ListNode * l2, int &carry) {\n        // First, we will check if our both linked list's node is NULL or not\n        if (l1 == NULL && l2 == NULL) \n            return NULL;\n        // Creating new_node for store the sum of digits\n        ListNode * new_node = new ListNode(-1);\n        // Here, we are making link between nodes which are having the sum of digits \n        new_node -> next = addDigits(l1 -> next, l2 -> next, carry);\n        \n        // Sum up both node values and assign the current node\n        new_node -> val = (l1 -> val + l2 -> val + carry) % 10;\n        // Calculate carry if the current sum > 9\n        carry = (l1 -> val + l2 -> val + carry) / 10;  \n        return new_node;\n    }\n  \n    ListNode * addTwoNumbers (ListNode * l1, ListNode * l2) {\n        // Adding zeros to the start of the smaller list:\n        ListNode * first = l1, * second = l2;\n        \n        while (first != NULL || second != NULL) {\n            // Add leading zero's to the nodes to the one is smaller, till both nodes length becomes equal\n            if (first == NULL) {\n                // Create new node ( value of new node is 0  \n                ListNode * new_node = new ListNode(0);\n                \n                // Connecting new node to head of linkedlist l1\n                new_node -> next = l1;\n                // Now, we assign new_node as head of linked list l1 \n                l1 = new_node;\n                second = second -> next;\n            } else if (second == NULL) {\n                ListNode * new_node = new ListNode(0);\n                new_node -> next = l2;\n                l2 = new_node;  \n                first = first -> next;\n            } else {\n                first = first -> next;\n                second = second -> next;\n            }\n        }\n        int carry = 0;\n        \n        // Create a new node temp (Head of the linked list) for sum of two linked list's l1 and l2\n        ListNode * temp = new ListNode(-1);\n        \n        // Call recursion function for traversing of the linked list and Calculating the sum of digits \n        temp -> next = addDigits(l1, l2, carry);\n        \n        // If carry is remaining, then add it to the last node (will be the Head)\n        if (carry != 0) {\n            ListNode * new_node = new ListNode(carry);\n            new_node -> next = temp -> next;\n            temp -> next = new_node;\n        }\n        return temp -> next;\n    }\n}; \n  \n")))),(0,i.kt)("h2",{id:"approach-2-stack"},"Approach 2: Stack"),(0,i.kt)("p",null,"Numbers are stored forward order, so keep traversing the nodes and add it to the stack. Now at the last, the last node will be at top of the stack. Pop top of the stack one by one and add the digits and create a node and keep the last node for the next node pointer (same as ",(0,i.kt)("a",{parentName:"p",href:"/solutions/0200-0299/reverse-linked-list-easy"},"Reverse LinkedList"),"). In each iteration, the current node will be set to prev node next pointer. Finally if carry is remaining then add it to head. "),(0,i.kt)("p",null,"Time Complexity is $O(n)$, where $n$ is the length of longest linked list."),(0,i.kt)("p",null,"Space Complexity is $O(n)$"),(0,i.kt)(p,{mdxType:"Tabs"},(0,i.kt)(c,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)(m,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        Stack<Integer> s1 = new Stack<>();\n        Stack<Integer> s2 = new Stack<>();\n        while (l1 != null || l2 != null) {\n            if (l1 != null) {\n                s1.push(l1.val);\n                l1 = l1.next;\n            }\n            if (l2 != null) {\n                s2.push(l2.val);\n                l2 = l2.next;\n            }\n        }\n        ListNode head = new ListNode();\n        ListNode current = null, prev = null;\n        int carry = 0;\n        while (!s1.isEmpty() || !s2.isEmpty()) {\n            int sum = carry;\n            if (!s1.isEmpty()) sum += s1.pop().intValue();\n            if (!s2.isEmpty()) sum += s2.pop().intValue();\n            carry = sum / 10;\n            current = new ListNode(sum % 10);\n            // Set current node next pointer to prev node\n            current.next = prev;\n            // Head is point to current and last previous node\n            head.next = current;\n            prev = current;\n        }\n        if (carry == 1) {\n            current = new ListNode(carry);\n            current.next = prev;\n            head.next = current;\n        }\n        return head.next;\n    }\n}\n")))))}f.isMDXComponent=!0}}]);