"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[52107],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),m=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},u=function(e){var n=m(e.components);return a.createElement(l.Provider,{value:n},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=m(t),d=i,h=p["".concat(l,".").concat(d)]||p[d]||c[d]||o;return t?a.createElement(h,r(r({ref:n},u),{},{components:t})):a.createElement(h,r({ref:n},u))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,r=new Array(o);r[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[p]="string"==typeof e?e:i,r[1]=s;for(var m=2;m<o;m++)r[m]=t[m];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},33313:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>m});var a=t(87462),i=(t(67294),t(3905));const o={description:"Author: @heiheihang, @wingkwong | https://leetcode.com/problems/maximum-and-sum-of-array/"},r="2172 - Maximum AND Sum of Array (Hard)",s={unversionedId:"2100-2199/maximum-and-sum-of-array-hard",id:"2100-2199/maximum-and-sum-of-array-hard",title:"2172 - Maximum AND Sum of Array (Hard)",description:"Author: @heiheihang, @wingkwong | https://leetcode.com/problems/maximum-and-sum-of-array/",source:"@site/solutions/2100-2199/2172-maximum-and-sum-of-array-hard.md",sourceDirName:"2100-2199",slug:"/2100-2199/maximum-and-sum-of-array-hard",permalink:"/solutions/2100-2199/maximum-and-sum-of-array-hard",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2100-2199/2172-maximum-and-sum-of-array-hard.md",tags:[],version:"current",sidebarPosition:2172,frontMatter:{description:"Author: @heiheihang, @wingkwong | https://leetcode.com/problems/maximum-and-sum-of-array/"},sidebar:"tutorialSidebar",previous:{title:"2171 - Removing Minimum Number of Magic Beans (Medium)",permalink:"/solutions/2100-2199/removing-minimum-number-of-magic-beans-medium"},next:{title:"2176 - Count Equal and Divisible Pairs in an Array (Easy)",permalink:"/solutions/2100-2199/count-equal-and-divisible-pairs-in-an-array-easy"}},l={},m=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Brute Force",id:"approach-1-brute-force",level:2},{value:"Approach 2: Bitmask DP",id:"approach-2-bitmask-dp",level:2},{value:"Approach 3: MCMF",id:"approach-3-mcmf",level:2}],u=(p="SolutionAuthor",function(e){return console.warn("Component "+p+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",e)});var p;const c={toc:m},d="wrapper";function h(e){let{components:n,...t}=e;return(0,i.kt)(d,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"2172---maximum-and-sum-of-array-hard"},"2172 - Maximum AND Sum of Array (Hard)"),(0,i.kt)("h2",{id:"problem-link"},"Problem Link"),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"You are given an integer array ",(0,i.kt)("inlineCode",{parentName:"p"},"nums")," of length ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," and an integer ",(0,i.kt)("inlineCode",{parentName:"p"},"numSlots")," such that ",(0,i.kt)("inlineCode",{parentName:"p"},"2 * numSlots >= n"),". There are ",(0,i.kt)("inlineCode",{parentName:"p"},"numSlots")," slots numbered from ",(0,i.kt)("inlineCode",{parentName:"p"},"1")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"numSlots"),"."),(0,i.kt)("p",null,"You have to place all ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," integers into the slots such that each slot contains at ",(0,i.kt)("strong",{parentName:"p"},"most")," two numbers. The ",(0,i.kt)("strong",{parentName:"p"},"AND sum")," of a given placement is the sum of the ",(0,i.kt)("strong",{parentName:"p"},"bitwise")," ",(0,i.kt)("inlineCode",{parentName:"p"},"AND")," of every number with its respective slot number."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"For example, the ",(0,i.kt)("strong",{parentName:"li"},"AND sum")," of placing the numbers ",(0,i.kt)("inlineCode",{parentName:"li"},"[1, 3]")," into slot ",(0,i.kt)("inlineCode",{parentName:"li"},"1")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"[4, 6]")," into slot ",(0,i.kt)("inlineCode",{parentName:"li"},"2")," is equal to ",(0,i.kt)("inlineCode",{parentName:"li"},"(1 AND 1) + (3 AND 1) + (4 AND 2) + (6 AND 2) = 1 + 1 + 0 + 2 = 4"),".")),(0,i.kt)("p",null,"Return ",(0,i.kt)("em",{parentName:"p"},"the maximum possible ",(0,i.kt)("strong",{parentName:"em"},"AND sum")," of")," ",(0,i.kt)("inlineCode",{parentName:"p"},"nums")," ",(0,i.kt)("em",{parentName:"p"},"given")," ",(0,i.kt)("inlineCode",{parentName:"p"},"numSlots")," ",(0,i.kt)("em",{parentName:"p"},"slots.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: nums = [1,2,3,4,5,6], numSlots = 3\nOutput: 9\nExplanation: One possible placement is [1, 4] into slot 1, [2, 6] into slot 2, and [3, 5] into slot 3. \nThis gives the maximum AND sum of (1 AND 1) + (4 AND 1) + (2 AND 2) + (6 AND 2) + (3 AND 3) + (5 AND 3) = 1 + 0 + 2 + 2 + 3 + 1 = 9.\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: nums = [1,3,10,4,7,1], numSlots = 9\nOutput: 24\nExplanation: One possible placement is [1, 1] into slot 1, [3] into slot 3, [4] into slot 4, [7] into slot 7, and [10] into slot 9.\nThis gives the maximum AND sum of (1 AND 1) + (1 AND 1) + (3 AND 3) + (4 AND 4) + (7 AND 7) + (10 AND 9) = 1 + 1 + 3 + 4 + 7 + 8 = 24.\nNote that slots 2, 5, 6, and 8 are empty which is permitted.\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"n == nums.length")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= numSlots <= 9")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= n <= 2 * numSlots")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= nums[i] <= 15"))),(0,i.kt)("h2",{id:"approach-1-brute-force"},"Approach 1: Brute Force"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"This approach is prepared by @heiheihang.")),(0,i.kt)("p",null,"Naive backtracking"),(0,i.kt)(u,{name:"@heiheihang",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class Solution:\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\n        \n        #store the number of elements in each slot\n        slots = defaultdict(int)\n        val = 0\n        res = 0\n        \n        def backtrack(idx):\n            \n            #return 0 when reaches the end of nums\n            if(idx == len(nums)):\n                return 0\n            \n            #store the maximum result    \n            res = 0\n            \n            #iterate all slots\n            for i in range(numSlots):\n                \n                #naive pruning for trivial results\n                if(nums[idx] & (i+1) == 0 or slots[i+1] == 2):\n                    continue\n                \n                #update if we want to take that number at ith slot\n                slots[i+1] += 1\n                \n                #backtrack\n                res = max(res, backtrack(idx+1) + ((i+1) & nums[idx]))\n                \n                #resume state\n                slots[i+1] -= 1\n            \n            #final backtrack for not using the current number\n            backtrack(idx+1) \n                \n        return backtrack(0)\n")),(0,i.kt)("h2",{id:"approach-2-bitmask-dp"},"Approach 2: Bitmask DP"),(0,i.kt)("p",null,"We notice that the naive approach is too inefficient. There are some repetitions in the combination of numbers in slots. We can take advantage of that by storing the state of the slots (utilizing the ",(0,i.kt)("inlineCode",{parentName:"p"},"slots")," dictionary from brute force!)"),(0,i.kt)("p",null,"To do this, we use bits. Each slot has 3 states: 0 element, 1 element, 2 elements. We need to use 2 bits to represent each slot. We can use a single integer to cover potentially 18 bits, but its implementation is more complicated than using two separate bit masks."),(0,i.kt)("p",null,"We can use the ",(0,i.kt)("em",{parentName:"p"},"ith")," bit ",(0,i.kt)("inlineCode",{parentName:"p"},"mask1")," to represent if the ",(0,i.kt)("em",{parentName:"p"},"ith")," slot has 0 or 1 element. We can use the ",(0,i.kt)("em",{parentName:"p"},"ith")," bit of ",(0,i.kt)("inlineCode",{parentName:"p"},"mask2")," to represent if the ",(0,i.kt)("em",{parentName:"p"},"ith")," slot has 2 elements."),(0,i.kt)("p",null,"We need to use some bit manipulation to update the states."),(0,i.kt)(u,{name:"@heiheihang",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"class Solution:\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\n        \n        \n        #mask 1 represents if the slot has 0 or 1 element\n        #mask 2 represents if the slot has 2 element \n        @lru_cache(None)\n        def dp(i, mask1, mask2):\n            \n            #reached the end of nums\n            if(i == len(nums)):\n                return 0\n            \n            #set the initial result\n            res = 0\n            \n            #iterate all slots\n            for j in range(numSlots):\n                \n                #check if slot is full\n                #both slots are filled\n                if(mask2 & (1 << j) != 0):\n                    continue\n                else:\n                    newMask1 = mask1\n                    newMask2 = mask2\n                    \n                    #slot is empty\n                    if(mask1 & (1 << j) == 0):\n                        #set mask 1 to \n                        newMask1 = mask1 | (1 << j)\n                    #slot has 1 element\n                    else:\n                        #clear mask 1 \n                        newMask1 = mask1 ^ (1 << j)\n                        newMask2 = mask2 | (1 << j)\n                        \n                    res = max(res, dp(i+1, newMask1, newMask2) + (nums[i] & (j+1)))\n                    \n            return res\n        \n        return dp(0,0,0)\n")),(0,i.kt)("h2",{id:"approach-3-mcmf"},"Approach 3: MCMF"),(0,i.kt)("admonition",{title:"Prerequisite",type:"info"},(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"MCMF"))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"MCMF tutorial will not be included here. Please check out ",(0,i.kt)("a",{parentName:"p",href:"https://cp-algorithms.com/graph/min_cost_flow.html"},"https://cp-algorithms.com/graph/min","_","cost","_","flow.html")," for more.")),(0,i.kt)("p",null,"We can think of $$nums$$ as the source of a bipartite graph and $$slots$$ as the destination. If we add two more vertices $$source$$ before $$nums$$ and $$sink$$ after $$slots$$, then we can easily solve it using standard MCMF template."),(0,i.kt)("details",null,(0,i.kt)("summary",null,"MCMF Template"),(0,i.kt)("p",null,"This ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ShahjalalShohag/code-library/blob/master/Graph%20Theory/Min%20Cost%20Max%20Flow.cpp"},"template")," is created by Shahjalal Shohag."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"using T = long long;\nconst T inf = 1LL << 61;\nstruct MCMF {\n  struct edge {\n    int u, v;\n    T cap, cost;\n    int id;\n    edge(int _u, int _v, T _cap, T _cost, int _id) {\n      u = _u;\n      v = _v;\n      cap = _cap;\n      cost = _cost;\n      id = _id;\n    }\n  };\n  int n, s, t, mxid;\n  T flow, cost;\n  vector<vector<int>> g;\n  vector<edge> e;\n  vector<T> d, potential, flow_through;\n  vector<int> par;\n  bool neg;\n  MCMF() {}\n  MCMF(int _n) { // 0-based indexing\n    n = _n + 10;\n    g.assign(n, vector<int> ());\n    neg = false;\n    mxid = 0;\n  }\n  void add_edge(int u, int v, T cap, T cost, int id = -1, bool directed = true) {\n    if(cost < 0) neg = true;\n    g[u].push_back(e.size());\n    e.push_back(edge(u, v, cap, cost, id));\n    g[v].push_back(e.size());\n    e.push_back(edge(v, u, 0, -cost, -1));\n    mxid = max(mxid, id);\n    if(!directed) add_edge(v, u, cap, cost, -1, true);\n  }\n  bool dijkstra() {\n    par.assign(n, -1);\n    d.assign(n, inf);\n    priority_queue<pair<T, T>, vector<pair<T, T>>, greater<pair<T, T>> > q;\n    d[s] = 0;\n    q.push(pair<T, T>(0, s));\n    while (!q.empty()) {\n      int u = q.top().second;\n      T nw = q.top().first;\n      q.pop();\n      if(nw != d[u]) continue;\n      for (int i = 0; i < (int)g[u].size(); i++) {\n        int id = g[u][i];\n        int v = e[id].v;\n        T cap = e[id].cap;\n        T w = e[id].cost + potential[u] - potential[v];\n        if (d[u] + w < d[v] && cap > 0) {\n          d[v] = d[u] + w;\n          par[v] = id;\n          q.push(pair<T, T>(d[v], v));\n        }\n      }\n    }\n    for (int i = 0; i < n; i++) { // update potential\n      if(d[i] < inf) potential[i] += d[i];\n    }\n    return d[t] != inf;\n  }\n  T send_flow(int v, T cur) {\n    if(par[v] == -1) return cur;\n    int id = par[v];\n    int u = e[id].u;\n    T w = e[id].cost;\n    T f = send_flow(u, min(cur, e[id].cap));\n    cost += f * w;\n    e[id].cap -= f;\n    e[id ^ 1].cap += f;\n    return f;\n  }\n  //returns {maxflow, mincost}\n  pair<T, T> solve(int _s, int _t, T goal = inf) {\n    s = _s;\n    t = _t;\n    flow = 0, cost = 0;\n    potential.assign(n, 0);\n    if (neg) {\n      // run Bellman-Ford to find starting potential\n      d.assign(n, inf);\n      for (int i = 0, relax = true; i < n && relax; i++) {\n        for (int u = 0; u < n; u++) {\n          for (int k = 0; k < (int)g[u].size(); k++) {\n            int id = g[u][k];\n            int v = e[id].v;\n            T cap = e[id].cap, w = e[id].cost;\n            if (d[v] > d[u] + w && cap > 0) {\n              d[v] = d[u] + w;\n              relax = true;\n            }\n          }\n        }\n      }\n      for(int i = 0; i < n; i++) if(d[i] < inf) potential[i] = d[i];\n    }\n    while (flow < goal && dijkstra()) flow += send_flow(t, goal - flow);\n    flow_through.assign(mxid + 10, 0);\n    for (int u = 0; u < n; u++) {\n      for (auto v : g[u]) {\n        if (e[v].id >= 0) flow_through[e[v].id] = e[v ^ 1].cap;\n      }\n    }\n    return make_pair(flow, cost);\n  }\n}\n"))),(0,i.kt)("p",null,"Let's build the graph. We have $$len(nums) + len(slots) + 2$$ vertices in total (including $$source$$ and $$sink$$). You may treat all vertices in a 1D array in the following order with 0-base indexing."),(0,i.kt)("p",null,"$$\nsource, nums","[0]",", nums","[1]",", ... ,nums","[n - 1]",", slot_1, slot_2, .., slot_k, sink\n$$"),(0,i.kt)("p",null,"Now we need to create the edges from $$source$$ to each element in $$nums$$ with $$1$$ capacity and $$0$$ cost. Then we create the edges from each element in $$nums$$ to each slot with $$1$$ capacity and $$-(nums","[i - 1]"," & slot)$$. The minus sign is here because this MCMF template is to calculate the minimum cost and this problem is asking for the maximum one. Similarly, we create edges from each slot to $$sink$$ with $$2$$ capacities (because each slot at most contains 2 elements) and $$0$$ cost."),(0,i.kt)(u,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int maximumANDSum(vector<int>& nums, int slots) {\n        int n = (int) nums.size();\n        // n + slots + 1 (source) + 1 (sink)\n        int vertices = n + slots + 2; \n        // [source, ...nums..., ...slots..., sink]\n        int source = 0, sink = vertices - 1; // 0-based indexing\n        MCMF F(vertices);\n        for (int i = 1; i <= n; i++) {\n            // from source (0) to each element in nums (i)\n            // with 1 capacity and 0 cost\n            F.add_edge(0, i, 1, 0);\n            for (int slot = 1; slot <= slots; slot++) {\n                // from each element in nums (i) to each slot (slot)\n                // with 1 capacity and -(nums[i - 1] & slot) cost\n                // negative sign for getting the max cost\n                F.add_edge(i, slot + n, 1, -(nums[i - 1] & slot));\n            }\n        }\n        for (int slot = 1; slot <= slots; slot++) {\n            // from each slot to sink\n            // with 2 capacities and 0 cost\n            F.add_edge(slot + n, sink, 2, 0);\n        }\n        // get the cost from source to sink\n        // solve() return {max_flow, min_cost} \n        // we just need the latter one\n        return -F.solve(source, sink, n).second;\n    }\n};\n")))}h.isMDXComponent=!0}}]);