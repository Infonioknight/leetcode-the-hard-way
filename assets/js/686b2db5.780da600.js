"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[89537],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),h=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=h(e.components);return r.createElement(s.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),p=h(n),u=a,d=p["".concat(s,".").concat(u)]||p[u]||c[u]||i;return n?r.createElement(d,o(o({ref:t},m),{},{components:n})):r.createElement(d,o({ref:t},m))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:a,o[1]=l;for(var h=2;h<i;h++)o[h]=n[h];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},55724:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>k,frontMatter:()=>i,metadata:()=>l,suggestedProblems:()=>m,toc:()=>h});var r=n(87462),a=(n(67294),n(3905));const i={title:"Binary Search",description:"Binary search is the searching strategy that reduces the search space by half every iteration until you have found the target.",hide_table_of_contents:!1,keywords:["leetcode","tutorial","binary search","algorithm"]},o=void 0,l={unversionedId:"basic-topics/binary-search",id:"basic-topics/binary-search",title:"Binary Search",description:"Binary search is the searching strategy that reduces the search space by half every iteration until you have found the target.",source:"@site/tutorials/basic-topics/binary-search.md",sourceDirName:"basic-topics",slug:"/basic-topics/binary-search",permalink:"/tutorials/basic-topics/binary-search",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/basic-topics/binary-search.md",tags:[],version:"current",frontMatter:{title:"Binary Search",description:"Binary search is the searching strategy that reduces the search space by half every iteration until you have found the target.",hide_table_of_contents:!1,keywords:["leetcode","tutorial","binary search","algorithm"]},sidebar:"tutorialSidebar",previous:{title:"Backtracking",permalink:"/tutorials/basic-topics/backtracking"},next:{title:"Brute Force",permalink:"/tutorials/basic-topics/brute-force"}},s={},h=[{value:"Overview",id:"overview",level:2},{value:"Example: 0704. Binary Search",id:"example-0704-binary-search",level:2},{value:"Tips",id:"tips",level:2}],m=[{problemName:"0704 - Binary Search",difficulty:"Easy",leetCodeLink:"https://leetcode.com/problems/binary-search/",solutionLink:"../../solutions/0700-0799/binary-search-easy"},{problemName:"0153 - Find Minimum in Rotated Sorted Array",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",solutionLink:""},{problemName:"0154 - Find Minimum in Rotated Sorted Array II",difficulty:"Hard",leetCodeLink:"https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/",solutionLink:""},{problemName:"0162 - Find Peak Element",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/find-peak-element/",solutionLink:""}],p=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",t)},c=p("TutorialAuthors"),u=p("Tabs"),d=p("TabItem"),y=p("SolutionAuthor"),f=p("Table"),b={toc:h,suggestedProblems:m},g="wrapper";function k(e){let{components:t,...n}=e;return(0,a.kt)(g,(0,r.Z)({},b,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)(c,{names:"@heiheihang, @wingkwong",mdxType:"TutorialAuthors"}),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"Binary search is a widely used algorithm for searching an element in a sorted array or list. The basic idea of binary search is to divide the search space in half with each iteration and compare the middle element with the target element. If the middle element is greater than the target element, the search space is reduced to the left half of the array, otherwise, it is reduced to the right half. This process is repeated until the target element is found or the search space is exhausted."),(0,a.kt)("p",null,"The time complexity of binary search is $O(log n)$, which is more efficient than the linear search algorithm $O(n)$, which checks all elements one by one. However, for binary search to work, the array or list must be sorted."),(0,a.kt)("p",null,"Binary search can be implemented using a while loop, recursion, or a combination of both. The implementation details may vary, but the basic idea remains the same. The basic steps for a binary search algorithm are:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Initialize two pointers, one pointing to the start of the array and the other pointing to the end."),(0,a.kt)("li",{parentName:"ol"},"Find the middle element of the array by calculating the average of the two pointers."),(0,a.kt)("li",{parentName:"ol"},"Compare the middle element with the target element."),(0,a.kt)("li",{parentName:"ol"},"If the middle element is equal to the target element, the search is complete and the index of the target element is returned."),(0,a.kt)("li",{parentName:"ol"},"If the middle element is less than the target element, move the left pointer to the middle element + 1 and repeat step 2."),(0,a.kt)("li",{parentName:"ol"},"If the middle element is greater than the target element, move the right pointer to the middle element - 1 and repeat step 2."),(0,a.kt)("li",{parentName:"ol"},"If the left pointer is greater than the right pointer, the target element is not found and the function returns -1.")),(0,a.kt)("p",null,"In conclusion, binary search is a fast and efficient algorithm for searching an element in a sorted array or list. Its time complexity is $O(log n)$, which is much better than the linear search algorithm. However, it requires the array or list to be sorted for it to work."),(0,a.kt)("p",null,"Let's look at the most basic form of binary search:"),(0,a.kt)("h2",{id:"example-0704-binary-search"},"Example: ",(0,a.kt)("a",{parentName:"h2",href:"https://leetcode.com/problems/binary-search/"},"0704. Binary Search")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Given an array of integers ",(0,a.kt)("inlineCode",{parentName:"p"},"nums")," which is sorted in ascending order, and an integer ",(0,a.kt)("inlineCode",{parentName:"p"},"target"),", write a function to search ",(0,a.kt)("inlineCode",{parentName:"p"},"target")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"nums"),". If ",(0,a.kt)("inlineCode",{parentName:"p"},"target")," exists, then return its index. Otherwise, return ",(0,a.kt)("inlineCode",{parentName:"p"},"-1"),"."),(0,a.kt)("p",{parentName:"blockquote"},"You must write an algorithm with ",(0,a.kt)("inlineCode",{parentName:"p"},"O(log n)")," runtime complexity.")),(0,a.kt)("p",null,"For example, given the sorted input:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"nums = [-1,0,3,5,9,12], target = 9\n")),(0,a.kt)("p",null,"The index of the element 9 is 4. We can use the following template to find the target"),(0,a.kt)(u,{mdxType:"Tabs"},(0,a.kt)(d,{value:"py",label:"Python",mdxType:"TabItem"},(0,a.kt)(y,{name:"@heiheihang",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"def binarySearch(nums, target):\n    lp, rp = 0, len(nums) - 1\n    while (lp <= rp):\n        mid = (lp + rp) // 2\n        if (nums[mid] == target):\n            return mid\n        elif (nums[mid] < target):\n            lp = mid + 1\n        else:\n            rp = mid - 1\n    return -1 \n"))),(0,a.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(y,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"int binarySearch(vector<int>& nums, int target) {\n    int lp = 0, rp = nums.size() - 1;\n    while (lp <= rp) {\n        int mid = lp + (rp - lp) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            lp = mid + 1;\n        } else {\n            rp = mid - 1;\n        }\n    }\n    return -1;\n}\n"))),(0,a.kt)(d,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.kt)(y,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"int binarySearch(int[] nums, int target) {\n    int lp = 0, rp = nums.length - 1;\n    while (lp <= rp) {\n        int mid = lp + (rp - lp) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            lp = mid + 1;\n        } else {\n            rp = mid - 1;\n        }\n    }\n    return -1;\n}\n\n")))),(0,a.kt)("p",null,"There can be very challenging questions using binary search, but we should focus on the basic application first."),(0,a.kt)("h2",{id:"tips"},"Tips"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"When the input is sorted, it's probably a hint to use binary search.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"When you need to find the first / last index of something, then it may be another hint to use binary search (as index is sorted).")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"When initialising the boundary, we may think about the possible range (sometimes $r$ may not necessarily be the max of the constraint")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"In while condition, you may see some people write $while (l < r)$ , $while (r > l)$,  $while (l <= r)$ , or $while (l >= r)$.  either one works depending on how to write the logic - just personal preference. See ",(0,a.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/35613574/when-to-use-in-binary-search-condition"},"here")," for more.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Think about the mid - if there are even elements, should we pick the left or the right mid? e.g. ","[1,2,3,4]"," like choosing $2$ or $3$?")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Think about how to shrink - if $mid$ is never be the answer, then we can exclude it ($l = m + 1$ / $r = m - 1$).")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"If you are using C++, most people use $l + (r - l) / 2$ to avoid integer overflow problem. Let's say $l$ & $r$ are large enough like ~INT_MAX, when u sum them up, it causes overflow. "),(0,a.kt)("p",{parentName:"li"},"We know that $m$ is actually somewhere in between $l$ and $r$ so let $m = l + x$ where $x$ is an arbitrary value. Since we know that $m = (l + r) / 2$, we can substitute to have the following\n$$$\nl + x = (l + r) / 2 ","\\","\nx = (l + r) / 2 - l ","\\","\nx ",(0,a.kt)("em",{parentName:"p"}," 2 = (l + r) - 2 ")," l ","\\","\nx * 2 = (r - l)  ","\\","\nx = (r - l) / 2 ","\\","\n$$$\nso putting x back to the first equation, we would have\n$$$\nm = l + x ","\\","\nm = l + (r - l) / 2\n$$$"))),(0,a.kt)(f,{title:"Suggested Problems",data:m,mdxType:"Table"}))}k.isMDXComponent=!0}}]);