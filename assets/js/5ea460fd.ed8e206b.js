"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[72187],{3905:(e,t,r)=>{r.d(t,{Zo:()=>s,kt:()=>m});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var d=n.createContext({}),p=function(e){var t=n.useContext(d),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},s=function(e){var t=p(e.components);return n.createElement(d.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,d=e.parentName,s=i(e,["components","mdxType","originalType","parentName"]),u=p(r),c=a,m=u["".concat(d,".").concat(c)]||u[c]||h[c]||o;return r?n.createElement(m,l(l({ref:t},s),{},{components:r})):n.createElement(m,l({ref:t},s))}));function m(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,l=new Array(o);l[0]=c;var i={};for(var d in t)hasOwnProperty.call(t,d)&&(i[d]=t[d]);i.originalType=e,i[u]="string"==typeof e?e:a,l[1]=i;for(var p=2;p<o;p++)l[p]=r[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,r)}c.displayName="MDXCreateElement"},88288:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>f,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var n=r(87462),a=(r(67294),r(3905));const o={title:"Binary Tree",description:"Binary Tree is a tree structure in which eacho node only contains at most two children",keywords:["leetcode","tutorial","binary tree","data structure"]},l=void 0,i={unversionedId:"graph-theory/binary-tree",id:"graph-theory/binary-tree",title:"Binary Tree",description:"Binary Tree is a tree structure in which eacho node only contains at most two children",source:"@site/tutorials/graph-theory/binary-tree.md",sourceDirName:"graph-theory",slug:"/graph-theory/binary-tree",permalink:"/tutorials/graph-theory/binary-tree",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/graph-theory/binary-tree.md",tags:[],version:"current",frontMatter:{title:"Binary Tree",description:"Binary Tree is a tree structure in which eacho node only contains at most two children",keywords:["leetcode","tutorial","binary tree","data structure"]},sidebar:"tutorialSidebar",previous:{title:"Bellman Ford Algorithm",permalink:"/tutorials/graph-theory/bellman-ford-algorithm"},next:{title:"Breadth First Search (BFS)",permalink:"/tutorials/graph-theory/breadth-first-search"}},d={},p=[{value:"Overview",id:"overview",level:2},{value:"Properties",id:"properties",level:2},{value:"Traversal",id:"traversal",level:2},{value:"Pre-order",id:"pre-order",level:3},{value:"In-order",id:"in-order",level:3},{value:"Post-order",id:"post-order",level:3},{value:"Summary",id:"summary",level:2}],s=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",t)},u=s("TutorialAuthors"),h=s("Tabs"),c=s("TabItem"),m={toc:p},y="wrapper";function f(e){let{components:t,...r}=e;return(0,a.kt)(y,(0,n.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)(u,{names:"@wingkwong",mdxType:"TutorialAuthors"}),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child. The root node is the topmost node in the tree and the leaf nodes are the nodes at the bottom with no children. Binary trees are commonly used to implement data structures such as binary search trees, which are used for efficient searching and sorting. The height of the binary tree is the number of edges from the root to the deepest leaf node. The depth of a node is the number of edges from the root to that node."),(0,a.kt)("h2",{id:"properties"},"Properties"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The number of nodes on level $l$ is equal to the $2^l$, like on level $0$ (root node) we got $2 ^ 0 >= 1$ node only."),(0,a.kt)("li",{parentName:"ul"},"The Maximum number of nodes in a binary tree of height $h$ is $2^h - 1$. ")),(0,a.kt)("h2",{id:"traversal"},"Traversal"),(0,a.kt)("p",null,"There are different ways to traverse trees - In-order, Pre-order, and Post-order. Supposing we have a binary tree with $5$ nodes,"),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/35857179/180000691-7634f6e6-1c2b-4e6e-a52a-83f3218e2d6b.png",alt:"image"})),(0,a.kt)("h3",{id:"pre-order"},"Pre-order"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Visit the root"),(0,a.kt)("li",{parentName:"ul"},"Traverse the left sub-tree"),(0,a.kt)("li",{parentName:"ul"},"Traverse the right sub-tree")),(0,a.kt)(h,{mdxType:"Tabs"},(0,a.kt)(c,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"void preorder(TreeNode* node) {\n    if (node == NULL) return;\n    s.push_back(node->val);\n    preorder(node->left);\n    preorder(node->right);\n}\n"))),(0,a.kt)(c,{value:"py",label:"Python",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"def preorder(node):\n    if (node == None): return\n    s.append(node.val)    \n    preorder(node.left)\n    preorder(node.right)\n")))),(0,a.kt)("h3",{id:"in-order"},"In-order"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Traverse the left sub-tree"),(0,a.kt)("li",{parentName:"ul"},"Visit the root"),(0,a.kt)("li",{parentName:"ul"},"Traverse the right sub-tree")),(0,a.kt)(h,{mdxType:"Tabs"},(0,a.kt)(c,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"void inorder(TreeNode* node) {\n    if (node == NULL) return;\n    inorder(node->left);\n    s.push_back(node->val);\n    inorder(node->right);\n}\n"))),(0,a.kt)(c,{value:"py",label:"Python",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"def inorder(node):\n    if (node == None): return\n    inorder(node.left)\n    s.append(node.val)\n    inorder(node.right)\n")))),(0,a.kt)("h3",{id:"post-order"},"Post-order"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Traverse the left sub-tree"),(0,a.kt)("li",{parentName:"ul"},"Traverse the right sub-tree"),(0,a.kt)("li",{parentName:"ul"},"Visit the root")),(0,a.kt)(h,{mdxType:"Tabs"},(0,a.kt)(c,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"void postorder(TreeNode* node) {\n    if (node == NULL) return;\n    postorder(node->left);\n    postorder(node->right);\n    s.push_back(node->val);\n}\n"))),(0,a.kt)(c,{value:"py",label:"Python",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"def postorder(node):\n    if (node == None): return\n    postorder(node.left)\n    postorder(node.right)\n    s.append(node.val)  \n")))),(0,a.kt)("h2",{id:"summary"},"Summary"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Traversal"),(0,a.kt)("th",{parentName:"tr",align:null},"Path"),(0,a.kt)("th",{parentName:"tr",align:null},"Order"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Pre-order"),(0,a.kt)("td",{parentName:"tr",align:null},"1 -> 2 -> 4 -> 5 -> 3"),(0,a.kt)("td",{parentName:"tr",align:null},"Root -> Left -> Right")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"In-order"),(0,a.kt)("td",{parentName:"tr",align:null},"4 -> 2 -> 5 -> 1 -> 3"),(0,a.kt)("td",{parentName:"tr",align:null},"Left -> Root -> Right")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Post-order"),(0,a.kt)("td",{parentName:"tr",align:null},"4 -> 5 -> 2 -> 3 -> 1"),(0,a.kt)("td",{parentName:"tr",align:null},"Left -> Right -> Root")))))}f.isMDXComponent=!0}}]);