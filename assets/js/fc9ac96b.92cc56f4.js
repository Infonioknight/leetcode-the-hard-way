"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[82989],{3905:(e,n,t)=>{t.d(n,{Zo:()=>s,kt:()=>u});var o=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var d=o.createContext({}),p=function(e){var n=o.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},s=function(e){var n=p(e.components);return o.createElement(d.Provider,{value:n},e.children)},h="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},m=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,d=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),h=p(t),m=a,u=h["".concat(d,".").concat(m)]||h[m]||c[m]||i;return t?o.createElement(u,r(r({ref:n},s),{},{components:t})):o.createElement(u,r({ref:n},s))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,r=new Array(i);r[0]=m;var l={};for(var d in n)hasOwnProperty.call(n,d)&&(l[d]=n[d]);l.originalType=e,l[h]="string"==typeof e?e:a,r[1]=l;for(var p=2;p<i;p++)r[p]=t[p];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}m.displayName="MDXCreateElement"},86636:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>y,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var o=t(87462),a=(t(67294),t(3905));const i={description:"Author: @ColeB2 | https://leetcode.com/problems/copy-list-with-random-pointer/",tags:["Hash Table","Linked List"]},r="0138 - Copy List with Random Pointer (Medium)",l={unversionedId:"0100-0199/copy-list-with-random-pointer-medium",id:"0100-0199/copy-list-with-random-pointer-medium",title:"0138 - Copy List with Random Pointer (Medium)",description:"Author: @ColeB2 | https://leetcode.com/problems/copy-list-with-random-pointer/",source:"@site/solutions/0100-0199/0138-copy-list-with-random-pointer-medium.md",sourceDirName:"0100-0199",slug:"/0100-0199/copy-list-with-random-pointer-medium",permalink:"/solutions/0100-0199/copy-list-with-random-pointer-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0100-0199/0138-copy-list-with-random-pointer-medium.md",tags:[{label:"Hash Table",permalink:"/solutions/tags/hash-table"},{label:"Linked List",permalink:"/solutions/tags/linked-list"}],version:"current",sidebarPosition:138,frontMatter:{description:"Author: @ColeB2 | https://leetcode.com/problems/copy-list-with-random-pointer/",tags:["Hash Table","Linked List"]},sidebar:"tutorialSidebar",previous:{title:"0136 - Single Number (Easy)",permalink:"/solutions/0100-0199/single-number-easy"},next:{title:"0139 - Word Break (Medium)",permalink:"/solutions/0100-0199/word-break-medium"}},d={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: 2 Passes",id:"approach-1-2-passes",level:2},{value:"Approach 2: Single Pass",id:"approach-2-single-pass",level:2}],s=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",n)},h=s("Tabs"),c=s("TabItem"),m=s("SolutionAuthor"),u={toc:p},k="wrapper";function y(e){let{components:n,...t}=e;return(0,a.kt)(k,(0,o.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"0138---copy-list-with-random-pointer-medium"},"0138 - Copy List with Random Pointer (Medium)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/copy-list-with-random-pointer/"},"https://leetcode.com/problems/copy-list-with-random-pointer/")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"A linked list of length ",(0,a.kt)("inlineCode",{parentName:"p"},"n")," is given such that each node contains an additional random pointer, which could point to any node in the list, or ",(0,a.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,a.kt)("p",null,"Construct a deep copy of the list. The ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Object_copying#Deep_copy"},"deep copy")," should consist of exactly ",(0,a.kt)("inlineCode",{parentName:"p"},"n")," ",(0,a.kt)("strong",{parentName:"p"},"brand new")," nodes, where each new node has its value set to the value of its corresponding original node. Both the ",(0,a.kt)("inlineCode",{parentName:"p"},"next")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"random")," pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. ",(0,a.kt)("strong",{parentName:"p"},"None of the pointers in the new list should point to nodes in the original list"),"."),(0,a.kt)("p",null,"For example, if there are two nodes ",(0,a.kt)("inlineCode",{parentName:"p"},"X")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Y")," in the original list, where ",(0,a.kt)("inlineCode",{parentName:"p"},"X.random --\x3e Y"),", then for the corresponding two nodes x and y in the copied list, ",(0,a.kt)("inlineCode",{parentName:"p"},"x.random --\x3e y"),"."),(0,a.kt)("p",null,"Return ",(0,a.kt)("em",{parentName:"p"},"the head of the copied linked list"),"."),(0,a.kt)("p",null,"The linked list is represented in the input/output as a list of ",(0,a.kt)("inlineCode",{parentName:"p"},"n")," nodes. Each node is represented as a pair of ",(0,a.kt)("inlineCode",{parentName:"p"},"[val, random_index]")," where:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"val"),": an integer representing Node.val"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"random_index"),": the index of the node (range from ",(0,a.kt)("inlineCode",{parentName:"li"},"0")," to ",(0,a.kt)("inlineCode",{parentName:"li"},"n-1"),") that the ",(0,a.kt)("inlineCode",{parentName:"li"},"random")," pointer points to, or ",(0,a.kt)("inlineCode",{parentName:"li"},"null")," if it does not point to any node.")),(0,a.kt)("p",null,"Your code will ",(0,a.kt)("strong",{parentName:"p"},"only")," be given the ",(0,a.kt)("inlineCode",{parentName:"p"},"head")," of the original linked list."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2019/12/18/e1.png",alt:null})),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\nOutput: [[7,null],[13,0],[11,4],[10,2],[1,0]]\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2019/12/18/e2.png",alt:null})),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: head = [[1,1],[2,1]]\nOutput: [[1,1],[2,1]]\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 3:")),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2019/12/18/e3.png",alt:null})),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: head = [[3,null],[3,0],[3,null]]\nOutput: [[3,null],[3,0],[3,null]]\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"0 <= n <= 1000")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"-10^4 <= Node.val <= 10^4")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Node.random")," is ",(0,a.kt)("inlineCode",{parentName:"li"},"null")," or is pointing to some node in the linked list.")),(0,a.kt)("h2",{id:"approach-1-2-passes"},"Approach 1: 2 Passes"),(0,a.kt)("p",null,"We can break this problem down into 2 easy steps. "),(0,a.kt)("p",null,"Step 1 is to loop through the linked list and make a copy of each node, we will place the nodes into a hash map with the original node as the key and the created node as the value. We do this for $$O(1)$$ access later."),(0,a.kt)("p",null,"Step 2 is to loop through the linked list a second time, this time knowing that all the nodes have been created, we can access the nodes inside our hash map, and then set our pointers."),(0,a.kt)("p",null,"Time Complexity: $$O(n)$$ we are going to do 2 passes through our linked list of size n."),(0,a.kt)("p",null,"Space Complexity: $$O(n)$$ we need to create a hash map of size n, to map each node to."),(0,a.kt)(h,{mdxType:"Tabs"},(0,a.kt)(c,{value:"python",label:"Python",mdxType:"TabItem"},(0,a.kt)(m,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},'"""\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: \'Node\' = None, random: \'Node\' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n"""\nclass Solution:\n    def copyRandomList(self, head: "Node") -> "Node":\n        # Base case, return early\n        if not head:\n            return head\n        # Hash map, default with None for when we reach a null node.\n        # {key:value} --\x3e {original_node: copy_node}\n        original_to_copy = {None: None}\n        # node variable to loop through each node in the linked list\n        node = head\n        # while our node exists, ie. we haven\'t reached the end.\n        while node:\n            # create a copy node, using the original linked lists value\n            copy = Node(node.val)\n            # put the copied node into our hash map\n            original_to_copy[node] = copy\n            # move forward in our linked list\n            node = node.next\n        # node variable to loop through each node in the linked list\n        node = head\n        # while our node exists, ie. we haven\'t reached the end.\n        while node:\n            # get the copy, next and random nodes we created in the above loop.\n            copy = original_to_copy[node]\n            nxt = original_to_copy[node.next]\n            random = original_to_copy[node.random]\n            # set the next, and random for our copied node to proper nodes.\n            copy.next, copy.random = nxt, random\n            # more vorward in our linked list\n            node = node.next\n        # return head of our linked list. Since it exists in hash map, we can\n        # retrieve it using the original head as the key.\n        return original_to_copy[head]\n')))),(0,a.kt)("h2",{id:"approach-2-single-pass"},"Approach 2: Single Pass"),(0,a.kt)("p",null,"Now a slightly trickier approach, is it possible to do the above in a single pass? Of course. To do that though, we are going to have to be careful to make sure we are reusing any node that has already been created, and creating nodes that don't exist. That can simply be done though by using a hash map again for $$O(1)$$ access to see if the node exists, and then creating the node if it doesn't exist."),(0,a.kt)("p",null,"We can do all this, by making sure at each iteration of our loop through the list that all nodes exists and then setting the pointers."),(0,a.kt)("p",null,"To do that, we check if the node as been created before, if not create it and put it in the hash map, with the key as the original node, and the value as the created node. Note that we are looping only through valid nodes, so while for our current node we don't need to check if it is a null node, we will have to handle null node cases for our next and random nodes."),(0,a.kt)("p",null,"Time Complexity: $$O(n)$$ we are going to do a single pass through all nodes in the linked list."),(0,a.kt)("p",null,"Space Complexity: $$O(n)$$ we need to create a hash map of size n, to map each node to."),(0,a.kt)(h,{mdxType:"Tabs"},(0,a.kt)(c,{value:"python",label:"Python",mdxType:"TabItem"},(0,a.kt)(m,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        # Base case, given empty head\n        if not head:\n            return head\n        # Create our hash map for O(1) access\n        # {key:value} --\x3e {original_node: copy_node}\n        original_to_copy = {}\n        # Set a node variable to loop through all the nodes in linked list.\n        node = head\n        while node:\n            #Get/Create current node.\n            if node in original_to_copy:\n                # Node exists, get the node\n                n = original_to_copy[node]\n            else:\n                # node doesn't exist, create it, add to the hash map.\n                n = Node(node.val)\n                original_to_copy[node] = n\n            #Get/Create node.next. Default it to None to handle the case in which\n            # the node actually is a null node.\n            nxt = None\n            if node.next in original_to_copy:\n                # Next copy exists, get the node\n                nxt = original_to_copy[node.next]\n            elif node.next:\n                # next copy doesn't exist, create it and add it to the hash map.\n                nxt = Node(node.next.val)\n                original_to_copy[node.next] = nxt\n            #Get/Create node.random. Default it to None to handle the case in which\n            # the node actually is a null node.\n            rand = None\n            if node.random in original_to_copy:\n                # random copy exists, get the node.\n                rand = original_to_copy[node.random]\n            elif node.random:\n                # random copy doesn't exist, create it and add it to the hash map.\n                rand = Node(node.random.val)\n                original_to_copy[node.random] = rand\n            # Got/Created all our nodes, now set the pointers\n            n.next = nxt\n            n.random = rand\n            # move our pointer up.\n            node = node.next\n        # return head of our linked list. Since it exists in the hash map, we can\n        # retrieve it using the original head as the key.\n        return original_to_copy[head]\n")))))}y.isMDXComponent=!0}}]);