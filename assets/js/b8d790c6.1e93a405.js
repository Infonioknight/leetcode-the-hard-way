"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[85128],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var i=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var m=i.createContext({}),s=function(e){var t=i.useContext(m),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=s(e.components);return i.createElement(m.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,m=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=s(n),u=o,h=c["".concat(m,".").concat(u)]||c[u]||d[u]||a;return n?i.createElement(h,r(r({ref:t},p),{},{components:n})):i.createElement(h,r({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,r=new Array(a);r[0]=u;var l={};for(var m in t)hasOwnProperty.call(t,m)&&(l[m]=t[m]);l.originalType=e,l[c]="string"==typeof e?e:o,r[1]=l;for(var s=2;s<a;s++)r[s]=n[s];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},982:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>s});var i=n(87462),o=(n(67294),n(3905));const a={description:"Authors: @heiheihang, @wingkwong | https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/"},r="2167 - Minimum Time to Remove All Cars Containing Illegal Goods (Hard)",l={unversionedId:"2100-2199/minimum-time-to-remove-all-cars-containing-illegal-goods-hard",id:"2100-2199/minimum-time-to-remove-all-cars-containing-illegal-goods-hard",title:"2167 - Minimum Time to Remove All Cars Containing Illegal Goods (Hard)",description:"Authors: @heiheihang, @wingkwong | https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/",source:"@site/solutions/2100-2199/2167-minimum-time-to-remove-all-cars-containing-illegal-goods-hard.md",sourceDirName:"2100-2199",slug:"/2100-2199/minimum-time-to-remove-all-cars-containing-illegal-goods-hard",permalink:"/solutions/2100-2199/minimum-time-to-remove-all-cars-containing-illegal-goods-hard",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2100-2199/2167-minimum-time-to-remove-all-cars-containing-illegal-goods-hard.md",tags:[],version:"current",sidebarPosition:2167,frontMatter:{description:"Authors: @heiheihang, @wingkwong | https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/"},sidebar:"tutorialSidebar",previous:{title:"2166 - Design Bitset (Medium)",permalink:"/solutions/2100-2199/design-bitset-medium"},next:{title:"2169 - Count Operations to Obtain Zero (Easy)",permalink:"/solutions/2100-2199/count-operations-to-obtain-zero-easy"}},m={},s=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Minimum Sum of Subarray",id:"approach-1-minimum-sum-of-subarray",level:2},{value:"Approach 2: Dynamic Programming",id:"approach-2-dynamic-programming",level:2}],p=(c="SolutionAuthor",function(e){return console.warn("Component "+c+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",e)});var c;const d={toc:s},u="wrapper";function h(e){let{components:t,...n}=e;return(0,o.kt)(u,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"2167---minimum-time-to-remove-all-cars-containing-illegal-goods-hard"},"2167 - Minimum Time to Remove All Cars Containing Illegal Goods (Hard)"),(0,o.kt)("h2",{id:"problem-link"},"Problem Link"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/"},"https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/")),(0,o.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,o.kt)("p",null,"You are given a ",(0,o.kt)("strong",{parentName:"p"},"0-indexed")," binary string ",(0,o.kt)("inlineCode",{parentName:"p"},"s")," which represents a sequence of train cars. ",(0,o.kt)("inlineCode",{parentName:"p"},"s[i] = '0'")," denotes that the ",(0,o.kt)("inlineCode",{parentName:"p"},"ith")," car does ",(0,o.kt)("strong",{parentName:"p"},"not")," contain illegal goods and ",(0,o.kt)("inlineCode",{parentName:"p"},"s[i] = '1'")," denotes that the ",(0,o.kt)("inlineCode",{parentName:"p"},"ith")," car does contain illegal goods."),(0,o.kt)("p",null,"As the train conductor, you would like to get rid of all the cars containing illegal goods. You can do any of the following three operations ",(0,o.kt)("strong",{parentName:"p"},"any")," number of times:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Remove a train car from the ",(0,o.kt)("strong",{parentName:"li"},"left")," end (i.e., remove ",(0,o.kt)("inlineCode",{parentName:"li"},"s[0]"),") which takes 1 unit of time."),(0,o.kt)("li",{parentName:"ol"},"Remove a train car from the ",(0,o.kt)("strong",{parentName:"li"},"right")," end (i.e., remove ",(0,o.kt)("inlineCode",{parentName:"li"},"s[s.length - 1]"),") which takes 1 unit of time."),(0,o.kt)("li",{parentName:"ol"},"Remove a train car from ",(0,o.kt)("strong",{parentName:"li"},"anywhere")," in the sequence which takes 2 units of time.")),(0,o.kt)("p",null,"Return ",(0,o.kt)("em",{parentName:"p"},"the ",(0,o.kt)("strong",{parentName:"em"},"minimum")," time to remove all the cars containing illegal goods"),"."),(0,o.kt)("p",null,"Note that an empty sequence of cars is considered to have no cars containing illegal goods."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 1:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'Input: s = "1100101"\nOutput: 5\nExplanation: \nOne way to remove all the cars containing illegal goods from the sequence is to\n- remove a car from the left end 2 times. Time taken is 2 * 1 = 2.\n- remove a car from the right end. Time taken is 1.\n- remove the car containing illegal goods found in the middle. Time taken is 2.\nThis obtains a total time of 2 + 1 + 2 = 5. \n\nAn alternative way is to\n- remove a car from the left end 2 times. Time taken is 2 * 1 = 2.\n- remove a car from the right end 3 times. Time taken is 3 * 1 = 3.\nThis also obtains a total time of 2 + 3 = 5.\n\n5 is the minimum time taken to remove all the cars containing illegal goods. \nThere are no other ways to remove them with less time.\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 2:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'Input: s = "0010"\nOutput: 2\nExplanation:\nOne way to remove all the cars containing illegal goods from the sequence is to\n- remove a car from the left end 3 times. Time taken is 3 * 1 = 3.\nThis obtains a total time of 3.\n\nAnother way to remove all the cars containing illegal goods from the sequence is to\n- remove the car containing illegal goods found in the middle. Time taken is 2.\nThis obtains a total time of 2.\n\nAnother way to remove all the cars containing illegal goods from the sequence is to \n- remove a car from the right end 2 times. Time taken is 2 * 1 = 2. \nThis obtains a total time of 2.\n\n2 is the minimum time taken to remove all the cars containing illegal goods. \nThere are no other ways to remove them with less time.\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Constraints:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"1 <= s.length <= 2 * 10^5")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"s[i]")," is either ",(0,o.kt)("inlineCode",{parentName:"li"},"'0'")," or ",(0,o.kt)("inlineCode",{parentName:"li"},"'1'"),".")),(0,o.kt)("h2",{id:"approach-1-minimum-sum-of-subarray"},"Approach 1: Minimum Sum of Subarray"),(0,o.kt)("p",null,"We note that our goal is to ",(0,o.kt)("strong",{parentName:"p"},"minimize")," the following:"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"totalCost = left + right + mid(1) ","*"," 2")),(0,o.kt)("p",null,"Where ",(0,o.kt)("em",{parentName:"p"},"mid(1)")," denotes the number of 1s in the middle part, and ",(0,o.kt)("em",{parentName:"p"},"mid(0)")," denotes the number of 0s in the middle part."),(0,o.kt)("p",null,"We can calculate ",(0,o.kt)("em",{parentName:"p"},"mid(1)")," in the following way:"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"mid - mid(0)")),(0,o.kt)("p",null,"So our new equation becomes:"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"totalCost = left + right + 2 ","*"," (mid - mid(0)) = left + right + mid + (mid - mid(0)) - mid(0)")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"totalCost = all + mid(1) - mid(0)")),(0,o.kt)("p",null,"As all is a constant, we need to ",(0,o.kt)("strong",{parentName:"p"},"minimize")," ",(0,o.kt)("em",{parentName:"p"},"mid(1) - mid(0)")),(0,o.kt)("p",null,"This becomes a minimum sum of subarray problem when we substitute -1 to 0 in the original input."),(0,o.kt)("p",null,"The rest of the problem becomes a classic subarray sum problem."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},'def minimumTime(self, s: str) -> int:\n        \n        #initialize currentValue and smallest\n        currentValue = 0\n        smallest = 0\n        \n        #iterate all characters\n        for c in s:\n            \n            #separate the cases of 0 and 1\n            if(c == "0"):\n                \n                #-1 if it is 0\n                currentValue -= 1\n                \n                #update smallest subarray sum including current value\n                currentValue = min(-1, currentValue)\n                \n                #update smallest\n                smallest = min(smallest, currentValue)\n            else:\n                \n                #add 1 if it is 1\n                currentValue += 1\n        \n        #return result based on formula\n        return len(s) + smallest\n')),(0,o.kt)("h2",{id:"approach-2-dynamic-programming"},"Approach 2: Dynamic Programming"),(0,o.kt)("p",null,"Let $$dp1","[i]","$$ be the time you need to take from the left to to index $$i$$ and $$dp2","[j]","$$ be the time you need to take from the right to to index $$j$$."),(0,o.kt)("p",null,"For each index, we have three options."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"remove from the left and contribute $$i$$ time"),(0,o.kt)("li",{parentName:"ol"},"remove from the middle and contribute $$dp1","[i - 1]"," + 2$$ or $$dp2","[i + 1]"," + 2$$ time if applicable."),(0,o.kt)("li",{parentName:"ol"},"remove from the right and contribute $$n - i$$ time")),(0,o.kt)("p",null,"Let's think about the case from the left to right, the transition is "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"if the character is 0, it doesn't contribute anything, so we take the previous state. $$dp1","[i]"," := dp1","[i - 1]","$$"),(0,o.kt)("li",{parentName:"ul"},"if the character is 1, we can either take $$i$$ or $$dp1","[i - 1]"," + 2$$.")),(0,o.kt)("p",null,"For $$dp2$$, we need to do it in reverse order. We can reverse the string and perform the same logic. At the end, the answer is to find the minimum value from $$dp1","[i]"," + dp2","[n - i]","$$."),(0,o.kt)(p,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int minimumTime(string s) {\n        int n = s.size(), ans = 1e9;\n        // dp1: min time to take from left to right\n        // dp2: min time to take from right to left\n        vector<int> dp1(n + 1), dp2(n + 1);\n        for (int i = 1; i <= n; i++) {\n            // if it is 0, then take the previous state\n            // if not, remove from the left or remove from the middle directly\n            if (s[i - 1] == '0') dp1[i] = dp1[i - 1];\n            else dp1[i] = min(i, dp1[i - 1] + 2);\n        }\n        // reverse the string and apply the same logic on dp2\n        reverse(s.begin(), s.end());\n        for (int i = 1; i <= n; i++) {\n            if (s[i - 1] == '0') dp2[i] = dp2[i - 1];\n            else dp2[i] = min(i, dp2[i - 1] + 2);\n        }\n        for (int i = 0; i <= n; i++) {\n            // dp1 + dp2: cover those three options\n            ans = min(ans, dp1[i] + dp2[n - i]);\n        }\n        return ans;\n    }\n};\n")))}h.isMDXComponent=!0}}]);