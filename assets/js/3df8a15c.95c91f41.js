"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[32889],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var a=t(67294);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function r(e,n){if(null==e)return{};var t,a,l=function(e,n){if(null==e)return{};var t,a,l={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(l[t]=e[t]);return l}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(l[t]=e[t])}return l}var s=a.createContext({}),d=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=d(e.components);return a.createElement(s.Provider,{value:n},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,l=e.mdxType,o=e.originalType,s=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),u=d(t),c=l,m=u["".concat(s,".").concat(c)]||u[c]||h[c]||o;return t?a.createElement(m,i(i({ref:n},p),{},{components:t})):a.createElement(m,i({ref:n},p))}));function m(e,n){var t=arguments,l=n&&n.mdxType;if("string"==typeof e||l){var o=t.length,i=new Array(o);i[0]=c;var r={};for(var s in n)hasOwnProperty.call(n,s)&&(r[s]=n[s]);r.originalType=e,r[u]="string"==typeof e?e:l,i[1]=r;for(var d=2;d<o;d++)i[d]=t[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},44579:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>v,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var a=t(87462),l=(t(67294),t(3905));const o={description:"Author: @wingkwong, @vigneshshiv, @radojicic23 | https://leetcode.com/problems/palindrome-linked-list/",tags:["Linked List","Two Pointers","Stack","Recursion"]},i="0234 - Palindrome Linked List (Easy)",r={unversionedId:"0200-0299/palindrome-linked-list-easy",id:"0200-0299/palindrome-linked-list-easy",title:"0234 - Palindrome Linked List (Easy)",description:"Author: @wingkwong, @vigneshshiv, @radojicic23 | https://leetcode.com/problems/palindrome-linked-list/",source:"@site/solutions/0200-0299/0234-palindrome-linked-list-easy.md",sourceDirName:"0200-0299",slug:"/0200-0299/palindrome-linked-list-easy",permalink:"/solutions/0200-0299/palindrome-linked-list-easy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0200-0299/0234-palindrome-linked-list-easy.md",tags:[{label:"Linked List",permalink:"/solutions/tags/linked-list"},{label:"Two Pointers",permalink:"/solutions/tags/two-pointers"},{label:"Stack",permalink:"/solutions/tags/stack"},{label:"Recursion",permalink:"/solutions/tags/recursion"}],version:"current",sidebarPosition:234,frontMatter:{description:"Author: @wingkwong, @vigneshshiv, @radojicic23 | https://leetcode.com/problems/palindrome-linked-list/",tags:["Linked List","Two Pointers","Stack","Recursion"]},sidebar:"tutorialSidebar",previous:{title:"0231 - Power of Two (Easy)",permalink:"/solutions/0200-0299/power-of-two-easy"},next:{title:"0235 - Lowest Common Ancestor of a Binary Search Tree (Medium)",permalink:"/solutions/0200-0299/lowest-common-ancestor-of-a-binary-search-tree-medium"}},s={},d=[{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Fast &amp; Slow Pointers",id:"approach-1-fast--slow-pointers",level:2},{value:"Approach 2: Convert it to String",id:"approach-2-convert-it-to-string",level:2},{value:"Approach 3: Stack",id:"approach-3-stack",level:2},{value:"Approach 4: Follow up: O(n) time, O(1) space",id:"approach-4-follow-up-on-time-o1-space",level:2}],p=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,l.kt)("div",n)},u=p("Tabs"),h=p("TabItem"),c=p("SolutionAuthor"),m={toc:d},f="wrapper";function v(e){let{components:n,...t}=e;return(0,l.kt)(f,(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"0234---palindrome-linked-list-easy"},"0234 - Palindrome Linked List (Easy)"),(0,l.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,l.kt)("p",null,"Given the ",(0,l.kt)("inlineCode",{parentName:"p"},"head")," of a singly linked list, return ",(0,l.kt)("inlineCode",{parentName:"p"},"true")," if it is a palindrome."),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example 1:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"Input: head = [1,2,2,1]\nOutput: true\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Example 2:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},"Input: head = [1,2]\nOutput: false\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Constraints:")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"The number of nodes in the list is in the range ",(0,l.kt)("inlineCode",{parentName:"li"},"[1, 105]"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"0 <= Node.val <= 9"))),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Follow up:")," Could you do it in ",(0,l.kt)("inlineCode",{parentName:"p"},"O(n)")," time and ",(0,l.kt)("inlineCode",{parentName:"p"},"O(1)")," space?"),(0,l.kt)("h2",{id:"approach-1-fast--slow-pointers"},"Approach 1: Fast & Slow Pointers"),(0,l.kt)(u,{mdxType:"Tabs"},(0,l.kt)(h,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,l.kt)(c,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        // find the middle node\n        ListNode *fast = head;\n        ListNode *slow = head;\n        while(fast && fast->next) {\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        // handle odd case\n        if(fast) slow = slow->next;\n        // reverse the last half of the list\n        ListNode *node = slow;\n        ListNode *last = nullptr;\n        ListNode *next = nullptr;\n        while(node){\n            next = node->next;\n            node->next = last;\n            last = node;\n            node = next;\n        }\n        // compare each half of the list\n        node = last;\n        while(node){\n            if (node->val == head->val) node = node->next, head = head->next;\n            else return false;\n        }\n        return true;\n    }\n};\n"))),(0,l.kt)(h,{value:"python",label:"Python",mdxType:"TabItem"},(0,l.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def isPalindrome(self, head: Optional[ListNode]) -> bool:\n        slow, fast = head, head \n\n        # find middle value(slow)\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        # reverse second portion \n        prev = None # dummy\n        while slow:\n            tmp = slow.next\n            slow.next = prev \n            prev = slow \n            slow = tmp\n\n        # check if it's palindrome \n        left, right = head, prev\n        while right:\n            if left.val != right.val:\n                return False \n            left = left.next\n            right = right.next\n        \n        return True \n"))),(0,l.kt)(h,{value:"javascript",label:"JavaScript",mdxType:"TabItem"},(0,l.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {boolean}\n */\nvar isPalindrome = function(head) {\n    let slow = head;\n    let fast = head;\n    // find middle value(slow)\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    // reverse second portion \n    let prev = null;\n    while (slow) {\n        let temp = slow.next;\n        slow.next = prev;\n        prev = slow;\n        slow = temp;\n    }\n    // check if it's palindrome\n    let left = head;\n    let right = prev;\n    while (right) {\n        if (left.val != right.val) {\n            return false;\n        }\n        left = left.next;\n        right = right.next;\n    }\n    return true;\n};\n")))),(0,l.kt)("h2",{id:"approach-2-convert-it-to-string"},"Approach 2: Convert it to String"),(0,l.kt)(u,{mdxType:"Tabs"},(0,l.kt)(h,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,l.kt)(c,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        // convert it to a string\n        string s;\n        while (head != NULL) {\n            s += head->val;\n            head = head->next;\n        }\n        // test if a string is palindrome\n        string t = s;\n        reverse(t.begin(), t.end());\n        return s == t;\n    }\n};\n"))),(0,l.kt)(h,{value:"javascript",label:"JavaScript",mdxType:"TabItem"},(0,l.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {boolean}\n */\nvar isPalindrome = function(head) {\n    let head_str = new String();\n    // convert to string\n    while (head) {\n        head_str += head.val;\n        head = head.next;\n    }\n    // return true if it's palindrome \n    return head_str == head_str.split('').reverse().join('');\n};\n"))),(0,l.kt)(h,{value:"python",label:"Python",mdxType:"TabItem"},(0,l.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def isPalindrome(self, head: Optional[ListNode]) -> bool:\n        head_str = ''\n        # convert to string\n        while head:\n            head_str += str(head.val)\n            head = head.next\n        # return true if it's palindrome\n        return head_str == head_str[::-1]\n")))),(0,l.kt)("h2",{id:"approach-3-stack"},"Approach 3: Stack"),(0,l.kt)("p",null,"Iterative approach using Stack"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Push first half of the elements onto a stack."),(0,l.kt)("li",{parentName:"ul"},"Iterate through the linked list, using fast runner / slow runner technique."),(0,l.kt)("li",{parentName:"ul"},"At each step, push the data from the slow runner onto a stack"),(0,l.kt)("li",{parentName:"ul"},"When the fast runner hits the end of the list, the slow runner will have reached the middle of the list."),(0,l.kt)("li",{parentName:"ul"},"By this point, the stack will have all the elements from the front of the linked list, but in reverse order Last, iterate through the rest of the slow runner node, and compare the node to the top of the stack.")),(0,l.kt)("p",null,"Time Complexity: $O(n)$, where $n$ - # of nodes in the list"),(0,l.kt)("p",null,"Space complexity: $O(n)$"),(0,l.kt)(u,{mdxType:"Tabs"},(0,l.kt)(h,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)(c,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        // Stack\n        Stack<Integer> stack = new Stack<>();\n        // Fast & Slow runner iteration\n        while (fast != null && fast.next != null) {\n            stack.push(slow.val);\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        // If list has odd number of elements, Skip the middle element\n        if (fast != null) {\n            slow = slow.next;\n        }\n        while (slow != null) {\n            int value = stack.pop().intValue();\n            if (slow.val != value) {\n                return false;\n            }\n            slow = slow.next;\n        }\n        return true;\n    }\n}\n")))),(0,l.kt)("h2",{id:"approach-4-follow-up-on-time-o1-space"},"Approach 4: Follow up: O(n) time, O(1) space"),(0,l.kt)("p",null,"Easy steps to solve the problem,"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Find the middle node"),(0,l.kt)("li",{parentName:"ul"},"Reverse a list from middle"),(0,l.kt)("li",{parentName:"ul"},"Compare both halves"),(0,l.kt)("li",{parentName:"ul"},"Re-reverse the list (optional here), and return true if either of halves are empty")),(0,l.kt)("p",null,"Time Complexity: $O(n)$, where $n$ - # of nodes in the list"),(0,l.kt)("p",null,"Space complexity: $O(1)$"),(0,l.kt)(u,{mdxType:"Tabs"},(0,l.kt)(h,{value:"java",label:"Java",mdxType:"TabItem"},(0,l.kt)(c,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        ListNode mid = middleNode(head);\n        ListNode secondHead = reverseList(mid);\n        // Compare head with reversed middle head\n        while (head != null && secondHead != null) {\n            // if both values are not matching then it's not a palindrome\n            if (head.val != secondHead.val) break;\n            // Keep moving forward\n            head = head.next;\n            secondHead = secondHead.next;\n        }\n        return head == null || secondHead == null;\n    }\n\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n\n    public ListNode reverseList(ListNode head) {\n        if (head == null) return null;\n        ListNode prev = null;\n        ListNode current = head;\n        while (current != null) {\n            ListNode next = current.next;\n            current.next = prev;\n            prev = current;\n            current = next;\n        }\n        return prev;\n    }\n}\n")))))}v.isMDXComponent=!0}}]);