"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[32744],{3905:(e,a,t)=>{t.d(a,{Zo:()=>p,kt:()=>u});var n=t(67294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function s(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function m(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?s(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function i(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=n.createContext({}),o=function(e){var a=n.useContext(l),t=a;return e&&(t="function"==typeof e?e(a):m(m({},a),e)),t},p=function(e){var a=o(e.components);return n.createElement(l.Provider,{value:a},e.children)},c="mdxType",k={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},d=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,s=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),c=o(t),d=r,u=c["".concat(l,".").concat(d)]||c[d]||k[d]||s;return t?n.createElement(u,m(m({ref:a},p),{},{components:t})):n.createElement(u,m({ref:a},p))}));function u(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var s=t.length,m=new Array(s);m[0]=d;var i={};for(var l in a)hasOwnProperty.call(a,l)&&(i[l]=a[l]);i.originalType=e,i[c]="string"==typeof e?e:r,m[1]=i;for(var o=2;o<s;o++)m[o]=t[o];return n.createElement.apply(null,m)}return n.createElement.apply(null,t)}d.displayName="MDXCreateElement"},12703:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>l,contentTitle:()=>m,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>o});var n=t(87462),r=(t(67294),t(3905));const s={description:"Author: @wingkwong | https://leetcode.com/problems/non-overlapping-intervals/",tags:["Array","Dynamic Programming","Greedy","Sorting"]},m="0435 - Non-overlapping Intervals (Medium)",i={unversionedId:"0400-0499/non-overlapping-intervals-medium",id:"0400-0499/non-overlapping-intervals-medium",title:"0435 - Non-overlapping Intervals (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/non-overlapping-intervals/",source:"@site/solutions/0400-0499/0435-non-overlapping-intervals-medium.md",sourceDirName:"0400-0499",slug:"/0400-0499/non-overlapping-intervals-medium",permalink:"/solutions/0400-0499/non-overlapping-intervals-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0400-0499/0435-non-overlapping-intervals-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Dynamic Programming",permalink:"/solutions/tags/dynamic-programming"},{label:"Greedy",permalink:"/solutions/tags/greedy"},{label:"Sorting",permalink:"/solutions/tags/sorting"}],version:"current",sidebarPosition:435,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/non-overlapping-intervals/",tags:["Array","Dynamic Programming","Greedy","Sorting"]},sidebar:"tutorialSidebar",previous:{title:"0433 - Minimum Genetic Mutation (Medium)",permalink:"/solutions/0400-0499/minimum-genetic-mutation-medium"},next:{title:"0438 - Find All Anagrams in a String (Medium)",permalink:"/solutions/0400-0499/find-all-anagrams-in-a-string-medium"}},l={},o=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Greedy",id:"approach-1-greedy",level:2}],p=e=>function(a){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",a)},c=p("Tabs"),k=p("TabItem"),d=p("SolutionAuthor"),u={toc:o},N="wrapper";function h(e){let{components:a,...t}=e;return(0,r.kt)(N,(0,n.Z)({},u,t,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"0435---non-overlapping-intervals-medium"},"0435 - Non-overlapping Intervals (Medium)"),(0,r.kt)("h2",{id:"problem-link"},"Problem Link"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/non-overlapping-intervals/"},"https://leetcode.com/problems/non-overlapping-intervals/")),(0,r.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.kt)("p",null,"Given an array of intervals ",(0,r.kt)("inlineCode",{parentName:"p"},"intervals")," where ",(0,r.kt)("inlineCode",{parentName:"p"},"intervals[i] = [starti, endi]"),", return ",(0,r.kt)("em",{parentName:"p"},"the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: intervals = [[1,2],[2,3],[3,4],[1,3]]\nOutput: 1\nExplanation: [1,3] can be removed and the rest of the intervals are non-overlapping.\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: intervals = [[1,2],[1,2],[1,2]]\nOutput: 2\nExplanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 3:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: intervals = [[1,2],[2,3]]\nOutput: 0\nExplanation: You don't need to remove any of the intervals since they're already non-overlapping.\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Constraints:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"1 <= intervals.length <= 10^5")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"intervals[i].length == 2")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"-5 * 10^4 <= starti < endi <= 5 * 10^4"))),(0,r.kt)("h2",{id:"approach-1-greedy"},"Approach 1: Greedy"),(0,r.kt)("p",null,"First we can sort ",(0,r.kt)("inlineCode",{parentName:"p"},"interval"),". Given two intervals, where ",(0,r.kt)("inlineCode",{parentName:"p"},"intervals[j]")," is the previous interval and ",(0,r.kt)("inlineCode",{parentName:"p"},"interval[i]")," is the current interval. We can think of three cases."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The two intervals are not overlapping, i.e. ",(0,r.kt)("inlineCode",{parentName:"li"},"intervals[i][0]")," >= ",(0,r.kt)("inlineCode",{parentName:"li"},"intervals[j][1]"),". We can simply mark ",(0,r.kt)("inlineCode",{parentName:"li"},"j = i"),"."),(0,r.kt)("li",{parentName:"ol"},"The two intervals are overlapping and the end of the previous interval is greater than that of the current interval. Since it's overlapping, we increase answer by 1. We also mark ",(0,r.kt)("inlineCode",{parentName:"li"},"j = i"),". ",(0,r.kt)("inlineCode",{parentName:"li"},"intervals[j]")," should be removed."),(0,r.kt)("li",{parentName:"ol"},"The two intervals are overlapping and the end of the previous interval is less than that of the current interval. ",(0,r.kt)("inlineCode",{parentName:"li"},"intervals[i]")," should be removed.")),(0,r.kt)("p",null,"Time Complexity: ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mi",{parentName:"mrow"},"l"),(0,r.kt)("mi",{parentName:"mrow"},"o"),(0,r.kt)("mi",{parentName:"mrow"},"g"),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(nlogn)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.01968em"}},"l"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"o"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"g"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),", where ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"n")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n")))))," is the length of ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"i"),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mi",{parentName:"mrow"},"t"),(0,r.kt)("mi",{parentName:"mrow"},"e"),(0,r.kt)("mi",{parentName:"mrow"},"r"),(0,r.kt)("mi",{parentName:"mrow"},"v"),(0,r.kt)("mi",{parentName:"mrow"},"a"),(0,r.kt)("mi",{parentName:"mrow"},"l"),(0,r.kt)("mi",{parentName:"mrow"},"s")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"intervals")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"in"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"er"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"v"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"a"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.01968em"}},"l"),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"s"))))),". We must first sort our intervals array before solving."),(0,r.kt)("p",null,"Space Complexity: ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mn",{parentName:"mrow"},"1"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(1)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord"},"1"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))),", We use no space to sort in place and only need extra space to track our answer, and our pointers."),(0,r.kt)(c,{mdxType:"Tabs"},(0,r.kt)(k,{value:"c++",label:"C++",mdxType:"TabItem"},(0,r.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        int ans = 0;\n        if (intervals.size() == 0) return ans;\n        sort(intervals.begin(), intervals.end());\n        for (int i = 1, j = 0; i < intervals.size(); i++) {\n          if (intervals[i][0] < intervals[j][1]) {\n            ans++;\n            if (intervals[j][1] > intervals[i][1]) j = i;\n          } else {\n            j = i;\n          }\n        }\n        return ans;\n    }\n};\n"))),(0,r.kt)(k,{value:"python",label:"Python",mdxType:"TabItem"},(0,r.kt)(d,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        # Sort our intervals array, O(nlogn) time\n        intervals.sort()\n        # track the end of the previous interval.\n        end = intervals[0][1]\n        # track the number of overlapping intervals to delete.\n        overlap = 0\n        # loop through the remaining intervals\n        for i in range(1, len(intervals)):\n            # get start and end of current intervals\n            _start, _end = intervals[i]\n            # if start of current interval lies within last interval.\n            if  _start < end:\n                # delete one\n                overlap += 1\n                # choose the one that ends sooner to keep.\n                end = min(end, _end)\n            # no overlap, don't delete, and update the previous interval's\n            # value to be what the current interval's end value is.\n            else:\n                end = _end\n        return overlap\n")))))}h.isMDXComponent=!0}}]);