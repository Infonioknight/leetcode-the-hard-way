"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[18063],{3905:(e,t,r)=>{r.d(t,{Zo:()=>m,kt:()=>h});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),p=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},m=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=p(r),d=a,h=u["".concat(s,".").concat(d)]||u[d]||c[d]||o;return r?n.createElement(h,i(i({ref:t},m),{},{components:r})):n.createElement(h,i({ref:t},m))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,i[1]=l;for(var p=2;p<o;p++)i[p]=r[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},53337:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>g,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var n=r(87462),a=(r(67294),r(3905));const o={description:"Author: @wingkwong | https://leetcode.com/problems/parallel-courses-iii/",tags:["Array","Dynamic Programming","Graph","Topological Sort"]},i="2050 - Parallel Courses III (Hard)",l={unversionedId:"2000-2099/parallel-courses-iii-hard",id:"2000-2099/parallel-courses-iii-hard",title:"2050 - Parallel Courses III (Hard)",description:"Author: @wingkwong | https://leetcode.com/problems/parallel-courses-iii/",source:"@site/solutions/2000-2099/2050-parallel-courses-iii-hard.md",sourceDirName:"2000-2099",slug:"/2000-2099/parallel-courses-iii-hard",permalink:"/solutions/2000-2099/parallel-courses-iii-hard",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2000-2099/2050-parallel-courses-iii-hard.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Dynamic Programming",permalink:"/solutions/tags/dynamic-programming"},{label:"Graph",permalink:"/solutions/tags/graph"},{label:"Topological Sort",permalink:"/solutions/tags/topological-sort"}],version:"current",sidebarPosition:2050,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/parallel-courses-iii/",tags:["Array","Dynamic Programming","Graph","Topological Sort"]},sidebar:"tutorialSidebar",previous:{title:"2032 - Two Out of Three (Easy)",permalink:"/solutions/2000-2099/two-out-of-three-easy"},next:{title:"2075 - Decode the Slanted Ciphertext (Medium)",permalink:"/solutions/2000-2099/decode-the-slanted-ciphertext-medium"}},s={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: DFS",id:"approach-1-dfs",level:2}],m=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",t)},u=m("Tabs"),c=m("TabItem"),d=m("SolutionAuthor"),h={toc:p},k="wrapper";function g(e){let{components:t,...r}=e;return(0,a.kt)(k,(0,n.Z)({},h,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"2050---parallel-courses-iii-hard"},"2050 - Parallel Courses III (Hard)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/parallel-courses-iii/"},"https://leetcode.com/problems/parallel-courses-iii/")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"You are given an integer ",(0,a.kt)("inlineCode",{parentName:"p"},"n"),", which indicates that there are ",(0,a.kt)("inlineCode",{parentName:"p"},"n")," courses labeled from ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"n"),". You are also given a 2D integer array ",(0,a.kt)("inlineCode",{parentName:"p"},"relations")," where ",(0,a.kt)("inlineCode",{parentName:"p"},"relations[j] = [prevCoursej, nextCoursej]")," denotes that course ",(0,a.kt)("inlineCode",{parentName:"p"},"prevCoursej")," has to be completed ",(0,a.kt)("strong",{parentName:"p"},"before")," course ",(0,a.kt)("inlineCode",{parentName:"p"},"nextCoursej")," (prerequisite relationship). Furthermore, you are given a ",(0,a.kt)("strong",{parentName:"p"},"0-indexed")," integer array ",(0,a.kt)("inlineCode",{parentName:"p"},"time")," where ",(0,a.kt)("inlineCode",{parentName:"p"},"time[i]")," denotes how many ",(0,a.kt)("strong",{parentName:"p"},"months")," it takes to complete the ",(0,a.kt)("inlineCode",{parentName:"p"},"(i+1)th")," course."),(0,a.kt)("p",null,"You must find the ",(0,a.kt)("strong",{parentName:"p"},"minimum")," number of months needed to complete all the courses following these rules:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"You may start taking a course at ",(0,a.kt)("strong",{parentName:"li"},"any time")," if the prerequisites are met."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Any number of courses")," can be taken at the ",(0,a.kt)("strong",{parentName:"li"},"same time"),".")),(0,a.kt)("p",null,"Return ",(0,a.kt)("em",{parentName:"p"},"the ",(0,a.kt)("strong",{parentName:"em"},"minimum")," number of months needed to complete all the courses"),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Note:")," The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph)."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: n = 3, relations = [[1,3],[2,3]], time = [3,2,5]\nOutput: 8\nExplanation: The figure above represents the given graph and the time required to complete each course. \nWe start course 1 and course 2 simultaneously at month 0.\nCourse 1 takes 3 months and course 2 takes 2 months to complete respectively.\nThus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]\nOutput: 12\nExplanation: The figure above represents the given graph and the time required to complete each course.\nYou can start courses 1, 2, and 3 at month 0.\nYou can complete them after 1, 2, and 3 months respectively.\nCourse 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months.\nCourse 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months.\nThus, the minimum time needed to complete all the courses is 7 + 5 = 12 months.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= n <= 5 * 10 ^ 4")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"0 <= relations.length <= min(n * (n - 1) / 2, 5 * 10 ^ 4)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"relations[j].length == 2")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= prevCoursej, nextCoursej <= n")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"prevCoursej != nextCoursej")),(0,a.kt)("li",{parentName:"ul"},"All the pairs ",(0,a.kt)("inlineCode",{parentName:"li"},"[prevCoursej, nextCoursej]")," are ",(0,a.kt)("strong",{parentName:"li"},"unique"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"time.length == n")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= time[i] <= 10 ^ 4")),(0,a.kt)("li",{parentName:"ul"},"The given graph is a directed acyclic graph.")),(0,a.kt)("h2",{id:"approach-1-dfs"},"Approach 1: DFS"),(0,a.kt)("p",null,"We can use dfs to find the maximum time of all the paths starting from ",(0,a.kt)("inlineCode",{parentName:"p"},"u"),". If there is no prerequisite relationship for ",(0,a.kt)("inlineCode",{parentName:"p"},"u"),", we can simply return ",(0,a.kt)("inlineCode",{parentName:"p"},"time[u]"),". Otherwise, we check the same for all of the neighbors. We can the maximum of all the results. "),(0,a.kt)(u,{mdxType:"Tabs"},(0,a.kt)(c,{value:"py",label:"Python",mdxType:"TabItem"},(0,a.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\n        g = defaultdict(list)\n        # build the prerequisite graph \n        # minus one to make it zero indexing\n        for x in relations: g[x[0] - 1].append(x[1] - 1)\n        # memoize it to improve performance\n        @cache\n        def dfs(u):\n            # no prerequisite relationship -> return its time\n            if not g[u]: return time[u]\n            # the current time + the max of the dfs result from the neighbors\n            return max([dfs(v) for v in g[u]]) + time[u]\n        # try all the nodes \n        return max([dfs(i) for i in range(n)])\n")))))}g.isMDXComponent=!0}}]);