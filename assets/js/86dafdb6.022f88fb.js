"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[80187],{3905:function(t,n,e){e.d(n,{Zo:function(){return c},kt:function(){return d}});var i=e(67294);function o(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function a(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,i)}return e}function r(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?a(Object(e),!0).forEach((function(n){o(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):a(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function l(t,n){if(null==t)return{};var e,i,o=function(t,n){if(null==t)return{};var e,i,o={},a=Object.keys(t);for(i=0;i<a.length;i++)e=a[i],n.indexOf(e)>=0||(o[e]=t[e]);return o}(t,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);for(i=0;i<a.length;i++)e=a[i],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(o[e]=t[e])}return o}var s=i.createContext({}),p=function(t){var n=i.useContext(s),e=n;return t&&(e="function"==typeof t?t(n):r(r({},n),t)),e},c=function(t){var n=p(t.components);return i.createElement(s.Provider,{value:n},t.children)},m={inlineCode:"code",wrapper:function(t){var n=t.children;return i.createElement(i.Fragment,{},n)}},u=i.forwardRef((function(t,n){var e=t.components,o=t.mdxType,a=t.originalType,s=t.parentName,c=l(t,["components","mdxType","originalType","parentName"]),u=p(e),d=o,h=u["".concat(s,".").concat(d)]||u[d]||m[d]||a;return e?i.createElement(h,r(r({ref:n},c),{},{components:e})):i.createElement(h,r({ref:n},c))}));function d(t,n){var e=arguments,o=n&&n.mdxType;if("string"==typeof t||o){var a=e.length,r=new Array(a);r[0]=u;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=t,l.mdxType="string"==typeof t?t:o,r[1]=l;for(var p=2;p<a;p++)r[p]=e[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,e)}u.displayName="MDXCreateElement"},5761:function(t,n,e){e.r(n),e.d(n,{assets:function(){return c},contentTitle:function(){return s},default:function(){return f},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return m}});var i=e(87462),o=e(63366),a=(e(67294),e(3905)),r=["components"],l={description:"Author: @wingkwong, @ColeB2 | https://leetcode.com/problems/min-cost-to-connect-all-points/''",tags:["Array","Union Find","Graph","Minimum Spanning Tree"]},s="1584 - Min Cost to Connect All Points (Medium)",p={unversionedId:"1500-1599/min-cost-to-connect-all-points-medium",id:"1500-1599/min-cost-to-connect-all-points-medium",title:"1584 - Min Cost to Connect All Points (Medium)",description:"Author: @wingkwong, @ColeB2 | https://leetcode.com/problems/min-cost-to-connect-all-points/''",source:"@site/solutions/1500-1599/1584-min-cost-to-connect-all-points-medium.md",sourceDirName:"1500-1599",slug:"/1500-1599/min-cost-to-connect-all-points-medium",permalink:"/solutions/1500-1599/min-cost-to-connect-all-points-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1500-1599/1584-min-cost-to-connect-all-points-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Union Find",permalink:"/solutions/tags/union-find"},{label:"Graph",permalink:"/solutions/tags/graph"},{label:"Minimum Spanning Tree",permalink:"/solutions/tags/minimum-spanning-tree"}],version:"current",sidebarPosition:1584,frontMatter:{description:"Author: @wingkwong, @ColeB2 | https://leetcode.com/problems/min-cost-to-connect-all-points/''",tags:["Array","Union Find","Graph","Minimum Spanning Tree"]},sidebar:"tutorialSidebar",previous:{title:"1578 - Minimum Time to Make Rope Colorful (Medium)",permalink:"/solutions/1500-1599/minimum-time-to-make-rope-colorful-medium"},next:{title:"1588 - Sum Of All Odd Length Subarrays (Easy)",permalink:"/solutions/1500-1599/sum-of-all-odd-length-subarrays-easy"}},c={},m=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Kruskal&#39;s Algorithm",id:"approach-1-kruskals-algorithm",level:2},{value:"Approach 2: Prim&#39;s Algorithm",id:"approach-2-prims-algorithm",level:2}],u=function(t){return function(n){return console.warn("Component "+t+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",n)}},d=u("Tabs"),h=u("TabItem"),g=u("SolutionAuthor"),k={toc:m};function f(t){var n=t.components,e=(0,o.Z)(t,r);return(0,a.kt)("wrapper",(0,i.Z)({},k,e,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"1584---min-cost-to-connect-all-points-medium"},"1584 - Min Cost to Connect All Points (Medium)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/min-cost-to-connect-all-points/"},"https://leetcode.com/problems/min-cost-to-connect-all-points/")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"You are given an array ",(0,a.kt)("inlineCode",{parentName:"p"},"points")," representing integer coordinates of some points on a 2D-plane, where ",(0,a.kt)("inlineCode",{parentName:"p"},"points[i] = [xi, yi]"),"."),(0,a.kt)("p",null,"The cost of connecting two points ",(0,a.kt)("inlineCode",{parentName:"p"},"[xi, yi]")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"[xj, yj]")," is the ",(0,a.kt)("strong",{parentName:"p"},"manhattan distance")," between them: ",(0,a.kt)("inlineCode",{parentName:"p"},"|xi - xj| + |yi - yj|"),", where ",(0,a.kt)("inlineCode",{parentName:"p"},"|val|")," denotes the absolute value of ",(0,a.kt)("inlineCode",{parentName:"p"},"val"),"."),(0,a.kt)("p",null,"Return ",(0,a.kt)("em",{parentName:"p"},"the minimum cost to make all points connected.")," All points are connected if there is ",(0,a.kt)("strong",{parentName:"p"},"exactly one")," simple path between any two points."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2020/08/26/d.png",alt:null})),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]\nOutput: 20\nExplanation: \n\nWe can connect the points as shown above to get the minimum cost of 20.\nNotice that there is a unique path between every pair of points.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: points = [[3,12],[-2,5],[-4,1]]\nOutput: 18\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= points.length <= 1000")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"-10^6 <= xi, yi <= 10^6")),(0,a.kt)("li",{parentName:"ul"},"All pairs ",(0,a.kt)("inlineCode",{parentName:"li"},"(xi, yi)")," are distinct.")),(0,a.kt)("h2",{id:"approach-1-kruskals-algorithm"},"Approach 1: Kruskal's Algorithm"),(0,a.kt)("p",null,"If we see this problem as a graph problem, it is same as find a minimum spanning tree (MST).  We can use Kruskal's algorithm with disjoint-set data structure (DSU) to solve it. We calculate the weight and build edges for all points. Then sort the array in an increasing order. For each edge, we check if two points are united or not. If not, we unite them and and the cost."),(0,a.kt)("p",null,"For more, please see ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Kruskal's_algorithm"},"Kruskal's Algorithm"),"."),(0,a.kt)("details",null,(0,a.kt)("summary",null,"DSU Template"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class dsu {\n public:\n  vector<int> root, rank;\n  int n;\n  int cnt;\n\n  dsu(int _n) : n(_n) {\n    root.resize(n);\n    rank.resize(n);\n    for(int i = 0; i < n; i++) {\n        root[i] = i;\n        rank[i] = 1;\n    }\n    cnt = n;\n  }\n\n  inline int getCount() { return cnt; }\n\n  inline int get(int x) { return (x == root[x] ? x : (root[x] = get(root[x]))); }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n        if (rank[x] > rank[y]) {\n            root[y] = x;\n        } else if (rank[x] < rank[y]) {\n            root[x] = y;\n        } else {\n            root[y] = x;\n            rank[x] += 1;\n        }\n        cnt--;\n      return true;\n    }\n    return false;\n  }\n};\n"))),(0,a.kt)(d,{mdxType:"Tabs"},(0,a.kt)(h,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(g,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int minCostConnectPoints(vector<vector<int>>& points) {\n        int n = points.size(); \n        vector<array<int, 3>> edges;\n        // build all the edges\n        for(int i = 0; i < n; i++) {\n            for(int j = i + 1; j < n; j++) {\n                int w = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]);\n                // put w first - as we want to sort by weight\n                edges.push_back({w, i, j});\n            }\n        }\n        // init dsu\n        dsu d(n);\n        // sort by weight - as we choose the shortest edge for each round\n        sort(edges.begin(), edges.end());\n        int ans = 0;\n        for (auto x : edges) {\n            // unite both point and add the weight\n            if (d.unite(x[1], x[2])) ans += x[0];\n        }\n        return ans;\n    }\n};\n")))),(0,a.kt)("h2",{id:"approach-2-prims-algorithm"},"Approach 2: Prim's Algorithm"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Prim%27s_algorithm"},"Prim's Algorithm")," to create a minimum spanning tree. Prim's algorithm works by building a tree vertex by vertex, selecting the minimum weighted edge of the next vertex not in the tree."),(0,a.kt)("p",null,"There are multiple ways to solve which edge it the min edge to select for the next vertex. We can use an adjaceny matrix, which would matrix that holds the weight of all edges between all vertices."),(0,a.kt)(d,{mdxType:"Tabs"},(0,a.kt)(h,{value:"python",label:"Python",mdxType:"TabItem"},(0,a.kt)(g,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    # Prim's Algorithm\n    # For this version of Prim's algorithm, we will use a hash map to map\n    # our vertex to the distance of the closest point. We will then use\n    # this hash map to track which point is closest to our MST.\n    # Time: O(n^2). Where n is the number of points. For each point\n    # we are going to have to check its distance to all other points.\n    # Space: O(n) our adjancency list will only hold n points inside.\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        # function to calculate manhattan distances.\n        manhattan = lambda x1, x2, y1, y2: abs(x1 - x2) + abs(y1 - y2)\n        # Adjaceny list --\x3e dictionary that maps key:value\n        # key: (x,y) coords. Dictionary gives up O(1) acces to points.\n        # value: Distance to the closest point.\n        # initialize distance of 0 for first point, as that is our\n        # starting point, and then infinity for the remaining points.\n        adj_list = {(x,y): float('inf') if i else 0 for i, (x,y) in enumerate(points)}\n        min_cost = 0\n        # While our adjacency list still has points inside it.\n        while adj_list:\n            # Initialize x,y and min_point variables to help us\n            # track which point we need to select to add to our tree.\n            x, y, min_point = None, None, float('inf')\n            # loop through all our points in the adjacency list.\n            # k = (x,y) coords of that point. \n            # v = manhattan distance of nearest point.\n            for k, v in adj_list.items():\n                # If this point is closer than selected point.\n                if v < min_point:\n                    # Select this point instead.\n                    (x, y), min_point = k, v\n            # Looped all points and selected closest, update min_cost and\n            # remove it from our adjacency list.\n            min_cost += min_point\n            adj_list.pop((x,y))\n            # Loop the remaining points, and update manhattan distances.\n            for xi, yi in adj_list.keys():\n                # Get (xi,yi) manhattan distance value\n                current_val = adj_list[(xi,yi)]\n                # calculate how close (xi,yi) is to (x,y) we found above.\n                updated_val = manhattan(xi,x,yi,y)\n                # update manhattan distance to the smaller of too values.\n                adj_list[(xi,yi)] = min(current_val,  updated_val)\n        return min_cost\n")))))}f.isMDXComponent=!0}}]);