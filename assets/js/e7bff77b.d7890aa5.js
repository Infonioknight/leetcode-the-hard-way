"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[67378],{3905:(e,t,r)=>{r.d(t,{Zo:()=>m,kt:()=>d});var a=r(67294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=a.createContext({}),p=function(e){var t=a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},m=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),u=p(r),h=n,d=u["".concat(l,".").concat(h)]||u[h]||c[h]||o;return r?a.createElement(d,s(s({ref:t},m),{},{components:r})):a.createElement(d,s({ref:t},m))}));function d(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,s=new Array(o);s[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[u]="string"==typeof e?e:n,s[1]=i;for(var p=2;p<o;p++)s[p]=r[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,r)}h.displayName="MDXCreateElement"},44231:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>b,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var a=r(87462),n=(r(67294),r(3905));const o={description:"Author: @madhu915 | https://leetcode.com/problems/two-sum-iv-input-is-a-bst/",tags:["Hash Table","Two Pointers","Tree","Depth-First Search","Breadth-First Search","Binary Search Tree","Binary Tree"]},s="0653 - Two Sum IV - Input is a BST (Easy)",i={unversionedId:"0600-0699/two-sum-IV-input-is-a-BST-easy",id:"0600-0699/two-sum-IV-input-is-a-BST-easy",title:"0653 - Two Sum IV - Input is a BST (Easy)",description:"Author: @madhu915 | https://leetcode.com/problems/two-sum-iv-input-is-a-bst/",source:"@site/solutions/0600-0699/0653-two-sum-IV-input-is-a-BST-easy.md",sourceDirName:"0600-0699",slug:"/0600-0699/two-sum-IV-input-is-a-BST-easy",permalink:"/solutions/0600-0699/two-sum-IV-input-is-a-BST-easy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0600-0699/0653-two-sum-IV-input-is-a-BST-easy.md",tags:[{label:"Hash Table",permalink:"/solutions/tags/hash-table"},{label:"Two Pointers",permalink:"/solutions/tags/two-pointers"},{label:"Tree",permalink:"/solutions/tags/tree"},{label:"Depth-First Search",permalink:"/solutions/tags/depth-first-search"},{label:"Breadth-First Search",permalink:"/solutions/tags/breadth-first-search"},{label:"Binary Search Tree",permalink:"/solutions/tags/binary-search-tree"},{label:"Binary Tree",permalink:"/solutions/tags/binary-tree"}],version:"current",sidebarPosition:653,frontMatter:{description:"Author: @madhu915 | https://leetcode.com/problems/two-sum-iv-input-is-a-bst/",tags:["Hash Table","Two Pointers","Tree","Depth-First Search","Breadth-First Search","Binary Search Tree","Binary Tree"]},sidebar:"tutorialSidebar",previous:{title:"0650 - 2 Keys Keyboard",permalink:"/solutions/0600-0699/two-keys-keyboard-medium"},next:{title:"0662 - Maximum Width of Binary Tree (Medium)",permalink:"/solutions/0600-0699/maximum-width-of-binary-tree-medium"}},l={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Depth First Search",id:"approach-1-depth-first-search",level:2}],m=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,n.kt)("div",t)},u=m("Tabs"),c=m("TabItem"),h=m("SolutionAuthor"),d={toc:p},k="wrapper";function b(e){let{components:t,...r}=e;return(0,n.kt)(k,(0,a.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"0653---two-sum-iv---input-is-a-bst-easy"},"0653 - Two Sum IV - Input is a BST (Easy)"),(0,n.kt)("h2",{id:"problem-link"},"Problem Link"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/two-sum-iv-input-is-a-bst/"},"https://leetcode.com/problems/two-sum-iv-input-is-a-bst/")),(0,n.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,n.kt)("p",null,"Given the ",(0,n.kt)("inlineCode",{parentName:"p"},"root")," of a binary search tree and an integer ",(0,n.kt)("inlineCode",{parentName:"p"},"k"),", return ",(0,n.kt)("inlineCode",{parentName:"p"},"true")," ",(0,n.kt)("em",{parentName:"p"},"if there exist two elements in the BST such that their sum is equal to")," ",(0,n.kt)("inlineCode",{parentName:"p"},"k"),", ",(0,n.kt)("em",{parentName:"p"},"or")," ",(0,n.kt)("inlineCode",{parentName:"p"},"false")," ",(0,n.kt)("em",{parentName:"p"},"otherwise"),"."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Example 1:")),(0,n.kt)("p",null,(0,n.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg",alt:null})),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"Input: root = [5,3,6,2,4,null,7], k = 9\nOutput: true\n")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Example 2:")),(0,n.kt)("p",null,(0,n.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2020/09/21/sum_tree_2.jpg",alt:null})),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"Input: root = [5,3,6,2,4,null,7], k = 28\nOutput: false\n")),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Constraints:")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The number of nodes in the tree is in the range ",(0,n.kt)("inlineCode",{parentName:"li"},"[1, 10 ^ 4]"),"."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"-10 ^ 4 <= Node.val <= 10 ^ 4")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"root")," is guaranteed to be a ",(0,n.kt)("strong",{parentName:"li"},"valid")," binary search tree."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"-10 ^ 5 <= k <= 10 ^ 5"))),(0,n.kt)("h2",{id:"approach-1-depth-first-search"},"Approach 1: Depth First Search"),(0,n.kt)("p",null,"Perform a depth first search in the binary search tree to search for the node with the target value. The values of the nodes are added to the hashset recursively as the tree is travelled in a DFS fashion and the node with the target value is searched within the hashset for each recursive call. The left subtree is traversed followed by the right subtree in order to determine the pair of nodes with sum ",(0,n.kt)("span",{parentName:"p",className:"math math-inline"},(0,n.kt)("span",{parentName:"span",className:"katex"},(0,n.kt)("span",{parentName:"span",className:"katex-mathml"},(0,n.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,n.kt)("semantics",{parentName:"math"},(0,n.kt)("mrow",{parentName:"semantics"},(0,n.kt)("mi",{parentName:"mrow"},"k")),(0,n.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"k")))),(0,n.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,n.kt)("span",{parentName:"span",className:"base"},(0,n.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,n.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03148em"}},"k")))))," and return true for any match."),(0,n.kt)(u,{mdxType:"Tabs"},(0,n.kt)(c,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,n.kt)(h,{name:"@madhu915",mdxType:"SolutionAuthor"}),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n  // set keeps track of the corresponding values of nodes traversed in a DFS fashion\n  unordered_set<int> node;\n\n  bool findTarget(TreeNode* root, int k) {\n    // DFS approach\n    if (!root) return false;\n    // if the target pair is found, then return true\n    if (node.find(k - root->val) != node.end()) return true;\n    // add node value to hashset\n    node.insert(root->val);\n    // search left and right subtrees\n    return findTarget(root->left, k) || findTarget(root->right, k);\n  }\n};\n")))))}b.isMDXComponent=!0}}]);