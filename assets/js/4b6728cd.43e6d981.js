"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[89082],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>k});var r=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var u=r.createContext({}),s=function(e){var n=r.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},m=function(e){var n=s(e.components);return r.createElement(u.Provider,{value:n},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,u=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),p=s(t),d=o,k=p["".concat(u,".").concat(d)]||p[d]||c[d]||a;return t?r.createElement(k,i(i({ref:n},m),{},{components:t})):r.createElement(k,i({ref:n},m))}));function k(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,i=new Array(a);i[0]=d;var l={};for(var u in n)hasOwnProperty.call(n,u)&&(l[u]=n[u]);l.originalType=e,l[p]="string"==typeof e?e:o,i[1]=l;for(var s=2;s<a;s++)i[s]=t[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},36075:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>i,default:()=>k,frontMatter:()=>a,metadata:()=>l,toc:()=>s});var r=t(87462),o=(t(67294),t(3905));const a={description:"Author: @wingkwong | https://leetcode.com/problems/most-frequent-number-following-key-in-an-array/"},i="2190 - Most Frequent Number Following Key In an Array (Easy)",l={unversionedId:"2100-2199/most-frequent-number-following-key-in-an-array-easy",id:"2100-2199/most-frequent-number-following-key-in-an-array-easy",title:"2190 - Most Frequent Number Following Key In an Array (Easy)",description:"Author: @wingkwong | https://leetcode.com/problems/most-frequent-number-following-key-in-an-array/",source:"@site/solutions/2100-2199/2190-most-frequent-number-following-key-in-an-array-easy.md",sourceDirName:"2100-2199",slug:"/2100-2199/most-frequent-number-following-key-in-an-array-easy",permalink:"/solutions/2100-2199/most-frequent-number-following-key-in-an-array-easy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2100-2199/2190-most-frequent-number-following-key-in-an-array-easy.md",tags:[],version:"current",sidebarPosition:2190,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/most-frequent-number-following-key-in-an-array/"},sidebar:"tutorialSidebar",previous:{title:"2188 - Minimum Time to Finish the Race (Hard)",permalink:"/solutions/2100-2199/minimum-time-to-finish-the-race-hard"},next:{title:"2191 - Sort the Jumbled Numbers (Medium)",permalink:"/solutions/2100-2199/sort-the-jumbled-numbers-medium"}},u={},s=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Counting",id:"approach-1-counting",level:2}],m=(p="SolutionAuthor",function(e){return console.warn("Component "+p+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",e)});var p;const c={toc:s},d="wrapper";function k(e){let{components:n,...t}=e;return(0,o.kt)(d,(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"2190---most-frequent-number-following-key-in-an-array-easy"},"2190 - Most Frequent Number Following Key In an Array (Easy)"),(0,o.kt)("h2",{id:"problem-link"},"Problem Link"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/most-frequent-number-following-key-in-an-array/"},"https://leetcode.com/problems/most-frequent-number-following-key-in-an-array/")),(0,o.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,o.kt)("p",null,"You are given a ",(0,o.kt)("strong",{parentName:"p"},"0-indexed")," integer array ",(0,o.kt)("inlineCode",{parentName:"p"},"nums"),". **** You are also given an integer ",(0,o.kt)("inlineCode",{parentName:"p"},"key"),", which is present in ",(0,o.kt)("inlineCode",{parentName:"p"},"nums"),"."),(0,o.kt)("p",null,"For every unique integer ",(0,o.kt)("inlineCode",{parentName:"p"},"target")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"nums"),", ",(0,o.kt)("strong",{parentName:"p"},"count")," the number of times ",(0,o.kt)("inlineCode",{parentName:"p"},"target")," immediately follows an occurrence of ",(0,o.kt)("inlineCode",{parentName:"p"},"key")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"nums"),". In other words, count the number of indices ",(0,o.kt)("inlineCode",{parentName:"p"},"i")," such that:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"0 <= i <= n - 2"),","),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"nums[i] == key")," and,"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"nums[i + 1] == target"),".")),(0,o.kt)("p",null,"Return ",(0,o.kt)("em",{parentName:"p"},"the")," ",(0,o.kt)("inlineCode",{parentName:"p"},"target")," ",(0,o.kt)("em",{parentName:"p"},"with the ",(0,o.kt)("strong",{parentName:"em"},"maximum")," count"),". The test cases will be generated such that the ",(0,o.kt)("inlineCode",{parentName:"p"},"target")," with maximum count is unique."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 1:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: nums = [1,100,200,1,100], key = 1\nOutput: 100\nExplanation: For target = 100, there are 2 occurrences at indices 1 and 4 which follow an occurrence of key.\nNo other integers follow an occurrence of key, so we return 100.\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 2:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: nums = [2,2,2,2,3], key = 2\nOutput: 2\nExplanation: For target = 2, there are 3 occurrences at indices 1, 2, and 3 which follow an occurrence of key.\nFor target = 3, there is only one occurrence at index 4 which follows an occurrence of key.\ntarget = 2 has the maximum number of occurrences following an occurrence of key, so we return 2.\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Constraints:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"2 <= nums.length <= 1000")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"1 <= nums[i] <= 1000")),(0,o.kt)("li",{parentName:"ul"},"The test cases will be generated such that the answer is unique.")),(0,o.kt)("h2",{id:"approach-1-counting"},"Approach 1: Counting"),(0,o.kt)("p",null,"We iterate the input to find the possible $$target$$ and store its occurrence. Return the maximum one."),(0,o.kt)(m,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int mostFrequent(vector<int>& nums, int key) {\n        int n = nums.size(), ans = 0;\n        // use hash map to store the occurrence of a possible target\n        unordered_map<int, int> m;\n        for (int i = 1; i < n; i++) {\n            // the previous one is key\n            // nums[i] is target\n            if (nums[i - 1] == key) {\n                // count occurrence\n                m[nums[i]]++;\n            }\n        }\n        int mx = 0;\n        for (auto x : m) {\n            // check if it is greater than the current max count\n            if (x.second > mx) {\n                // store the number\n                ans = x.first;\n                // update the max count\n                mx = x.second;\n            }\n        }\n        return ans;\n    }\n};\n")),(0,o.kt)("p",null,"Once we get the idea, we can further optimise the above solution a bit. We only set answer if the current number is $$target$$ and its occurrence is greater than the current max count."),(0,o.kt)(m,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int mostFrequent(vector<int>& nums, int key) {\n        int n = nums.size(), ans = 0;\n        unordered_map<int, int> m;\n        for (int i = 1; i < n; i++) {\n            if (nums[i - 1] == key && ++m[nums[i]] > m[ans]) {\n                ans = nums[i];\n            }\n        }\n        return ans;\n    }\n};\n")))}k.isMDXComponent=!0}}]);