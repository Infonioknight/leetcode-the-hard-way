"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[73993],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>k});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var i=n.createContext({}),m=function(e){var t=n.useContext(i),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=m(e.components);return n.createElement(i.Provider,{value:t},e.children)},h="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),h=m(a),d=r,k=h["".concat(i,".").concat(d)]||h[d]||c[d]||o;return a?n.createElement(k,s(s({ref:t},p),{},{components:a})):n.createElement(k,s({ref:t},p))}));function k(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,s=new Array(o);s[0]=d;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l[h]="string"==typeof e?e:r,s[1]=l;for(var m=2;m<o;m++)s[m]=a[m];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},36660:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>l,suggestedProblems:()=>p,toc:()=>m});var n=a(87462),r=(a(67294),a(3905));const o={title:"Binary Search Tree",description:"A binary tree where left child is less than or equal to the parent, while the right child is greater",keywords:["leetcode","tutorial","binary search tree","data structure"]},s=void 0,l={unversionedId:"graph-theory/binary-search-tree",id:"graph-theory/binary-search-tree",title:"Binary Search Tree",description:"A binary tree where left child is less than or equal to the parent, while the right child is greater",source:"@site/tutorials/graph-theory/binary-search-tree.md",sourceDirName:"graph-theory",slug:"/graph-theory/binary-search-tree",permalink:"/tutorials/graph-theory/binary-search-tree",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/graph-theory/binary-search-tree.md",tags:[],version:"current",frontMatter:{title:"Binary Search Tree",description:"A binary tree where left child is less than or equal to the parent, while the right child is greater",keywords:["leetcode","tutorial","binary search tree","data structure"]},sidebar:"tutorialSidebar",previous:{title:"Bellman Ford Algorithm",permalink:"/tutorials/graph-theory/bellman-ford-algorithm"},next:{title:"Binary Tree",permalink:"/tutorials/graph-theory/binary-tree"}},i={},m=[{value:"Binary Search Trees",id:"binary-search-trees",level:2},{value:"Implementation",id:"implementation",level:3},{value:"Operations",id:"operations",level:3},{value:"Insertion",id:"insertion",level:4},{value:"Deletion",id:"deletion",level:4},{value:"Searching",id:"searching",level:4},{value:"Example #1: 0701 - Insert into a Binary Search Tree",id:"example-1-0701---insert-into-a-binary-search-tree",level:3},{value:"Example #2: 0450 - Delete Node in a BST",id:"example-2-0450---delete-node-in-a-bst",level:3},{value:"Example #3: 0700 - Search in a Binary Search Tree",id:"example-3-0700---search-in-a-binary-search-tree",level:3},{value:"Balanced Binary Search Trees",id:"balanced-binary-search-trees",level:2},{value:"Example #1: 1382 - Balance a Binary Search Tree",id:"example-1-1382---balance-a-binary-search-tree",level:3},{value:"Complexity Analysis",id:"complexity-analysis",level:2}],p=[{problemName:"0098 - Validate Binary Search Tree",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/validate-binary-search-tree/",solutionLink:"../../solutions/0000-0099/validate-binary-search-tree-medium"},{problemName:"0230 - Kth Smallest Element in a BST",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/kth-smallest-element-in-a-bst/",solutionLink:"../../solutions/0200-0299/kth-smallest-element-in-a-bst-medium"},{problemName:"0703 - Kth Largest Element in a Stream",difficulty:"Easy",leetCodeLink:"https://leetcode.com/problems/kth-largest-element-in-a-stream/",solutionLink:"../../solutions/0700-0799/kth-largest-element-in-a-stream-easy"}],h=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",t)},c=h("TutorialAuthors"),d=h("Table"),k={toc:m,suggestedProblems:p},N="wrapper";function u(e){let{components:t,...a}=e;return(0,r.kt)(N,(0,n.Z)({},k,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(c,{names:"@ChiragAgg5k",mdxType:"TutorialAuthors"}),(0,r.kt)("h2",{id:"binary-search-trees"},"Binary Search Trees"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Binary search trees (BST)")," are basically ",(0,r.kt)("a",{parentName:"p",href:"/tutorials/graph-theory/binary-tree"},"binary trees")," where each node's value is larger than all the nodes in that node's left subtree, and smaller than all the nodes in that node's right subtree. This property allows the ",(0,r.kt)("a",{parentName:"p",href:"/tutorials/basic-topics/binary-search"},"binary search algorithm")," to be applied to the tree, which is useful for fast lookup, insertion, and deletion of the nodes."),(0,r.kt)("h3",{id:"implementation"},"Implementation"),(0,r.kt)("p",null,"A BST can be implemented using a ",(0,r.kt)("a",{parentName:"p",href:"/tutorials/graph-theory/binary-tree"},"binary tree")," with the following structure:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"struct TreeNode {\n  int val;\n  TreeNode * left;\n  TreeNode * right;\n  TreeNode(): val(0), left(nullptr), right(nullptr) {}\n  TreeNode(int x): val(x), left(nullptr), right(nullptr) {}\n  TreeNode(int x, TreeNode * left, TreeNode * right): val(x), left(left), right(right) {}\n};\n")),(0,r.kt)("h3",{id:"operations"},"Operations"),(0,r.kt)("h4",{id:"insertion"},"Insertion"),(0,r.kt)("p",null,"Inserting a node into a BST is similar to inserting a node into a ",(0,r.kt)("a",{parentName:"p",href:"/tutorials/graph-theory/binary-tree"},"binary tree"),", except that the node must be inserted in the correct position to maintain the BST property. The following is an example of inserting a node into a BST:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"TreeNode* insert(TreeNode* root, int key) {\n  if (root == NULL) return new TreeNode(key);\n  if (key < root->val) root->left = insert(root->left, key);\n  else root->right = insert(root->right, key);\n  return root;\n}\n")),(0,r.kt)("h4",{id:"deletion"},"Deletion"),(0,r.kt)("p",null,"There are 4 cases to consider when deleting a node from a BST:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The node has no children - the node can be deleted without any further processing."),(0,r.kt)("li",{parentName:"ol"},"The node has only a left child - the node can be deleted and replaced with its left child."),(0,r.kt)("li",{parentName:"ol"},"The node has only a right child - the node can be deleted and replaced with its right child."),(0,r.kt)("li",{parentName:"ol"},"The node has both a left and right child - the node can be deleted and replaced with the ",(0,r.kt)("em",{parentName:"li"},"minimum node in its right subtree"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"TreeNode* deleteNode(TreeNode* root, int key) {\n  if (root) {\n    if (key < root->val) root->left = deleteNode(root->left, key);\n    else if (key > root->val) root->right = deleteNode(root->right, key);\n  } else {\n    if (!root->left && !root->right) return NULL;\n    if (!root->left || !root->right) return root->left ? root->left : root->right;\n    TreeNode* temp = root->left;\n    while (temp->right != NULL) temp = temp->right;\n    root->val = temp->val;\n    root->left = deleteNode(root->left, temp->val);\n  }\n  return root;\n}\n")),(0,r.kt)("h4",{id:"searching"},"Searching"),(0,r.kt)("p",null,"Searching in a BST follows the same logic as in binary search, using the divide and conquer approach. The following is an implementation of searching in a BST:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"TreeNode* search(TreeNode* root, int key) {\n  if (root == NULL || root->val == key) return root;\n  if (key < root->val) return search(root->left, key);\n  return search(root->right, key);\n}\n")),(0,r.kt)("h3",{id:"example-1-0701---insert-into-a-binary-search-tree"},"Example #1: ",(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/insert-into-a-binary-search-tree/"},"0701 - Insert into a Binary Search Tree")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.")),(0,r.kt)("p",null,"In this problem, we are asked to insert a node with a given key into a BST. To do so, first we need to find the correct position to insert the node and then insert it. The solution to this problem is as follows:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\n public:\n  TreeNode* insertIntoBST(TreeNode* root, int key) {\n    // if root is NULL, insert the node at the root\n    if (root == NULL) return new TreeNode(key);\n    // if key is less than root's value, recurse into the left subtree, \n    // else recurse into the right subtree\n    if (key < root->val) root->left = insertIntoBST(root->left, key);\n    else root->right = insertIntoBST(root->right, key);\n    return root;\n  }\n};\n")),(0,r.kt)("h3",{id:"example-2-0450---delete-node-in-a-bst"},"Example #2: ",(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/delete-node-in-a-bst/"},"0450 - Delete Node in a BST")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.")),(0,r.kt)("p",null,"In this problem, we are asked to delete a node with a given key from a BST. Now its fairly easy to navigate to the node with the given key, but the problem is that we need to ",(0,r.kt)("em",{parentName:"p"},"maintain the BST property")," after deleting the node. For this we can apply the logic of deletion in a BST, which is described above. The following is the complete solution to this problem:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\n public:\n  TreeNode *deleteNode(TreeNode *root, int key) {\n    if (root) {\n      if (key < root->val) root->left = deleteNode(root->left, key);\n      else if (key > root->val) root->right = deleteNode(root->right, key);\n      else {\n        // if the node has no children, delete it directly\n        if (!root->left && !root->right) return NULL;\n        // if the node has only one child, delete it and replace it with its child\n        if (!root->left || !root->right) return root->left ? root->left : root->right;\n        // if the node has both a left and right child, replace it with the minimum\n        TreeNode *temp = root->left;\n        while (temp->right != NULL) temp = temp->right;\n        root->val = temp->val;\n        root->left = deleteNode(root->left, temp->val);\n      }\n    }\n    return root;\n  }\n};\n")),(0,r.kt)("h3",{id:"example-3-0700---search-in-a-binary-search-tree"},"Example #3: ",(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/search-in-a-binary-search-tree/"},"0700 - Search in a Binary Search Tree")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Find the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.")),(0,r.kt)("p",null,"In this problem, we are asked to find a node with a given key in a BST. This can be done in an optimal way using the divide and conquer approach due to the BST property. The following is the complete solution to this problem:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\n public:\n  TreeNode* searchBST(TreeNode* root, int key) {\n    // either root is found or the key is not present in the BST\n    if (root == NULL || root->val == key) return root;\n    // if key is less than root's value, recurse into the left subtree\n    if (key < root->val) return searchBST(root->left, key);\n    // else ecurse into the right subtree\n    return searchBST(root->right, key);\n  }\n};\n")),(0,r.kt)("h2",{id:"balanced-binary-search-trees"},"Balanced Binary Search Trees"),(0,r.kt)("p",null,"A binary search tree is said to be ",(0,r.kt)("strong",{parentName:"p"},"balanced")," if the height of the left and right subtrees of every node differ by at most 1. A balanced BST has applications in many algorithms, such as ",(0,r.kt)("strong",{parentName:"p"},"AVL trees")," and ",(0,r.kt)("strong",{parentName:"p"},"red-black trees"),"."),(0,r.kt)("p",null,"We can convert a binary tree into a balanced BST by first traversing the tree in inorder and storing the values in an array, and then constructing a balanced BST from the array. The following leetcode problem demonstrates this approach:"),(0,r.kt)("h3",{id:"example-1-1382---balance-a-binary-search-tree"},"Example #1: ",(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/balance-a-binary-search-tree/"},"1382 - Balance a Binary Search Tree")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Given the root of a binary search tree, return a balanced binary search tree with the same node values. If there is more than one answer, return any of them.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\n public:\n  void inorder(TreeNode* root, vector<int>& ans) {\n    if (root == NULL) return;\n    inorder(root->left, ans);\n    ans.push_back(root->val);\n    inorder(root->right, ans);\n  }\n\n  TreeNode* createBST(vector<int> ans, int start, int end) {\n    if (start > end) return NULL;\n    int mid = start + (end - start) / 2;\n    TreeNode* root = new TreeNode(ans[mid]);\n    root->left = createBST(ans, start, mid - 1);\n    root->right = createBST(ans, mid + 1, end);\n    return root;\n  }\n\n  TreeNode* balanceBST(TreeNode* root) {\n    vector<int> ans;\n    // Store the inorder traversal of the tree in an array\n    inorder(root, ans);\n    int start = 0, end = ans.size() - 1;\n    return createBST(ans, start, end);\n  }\n};\n")),(0,r.kt)("h2",{id:"complexity-analysis"},"Complexity Analysis"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Operation"),(0,r.kt)("th",{parentName:"tr",align:null},"Time Complexity"),(0,r.kt)("th",{parentName:"tr",align:null},"Space Complexity"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Insertion"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("span",{parentName:"td",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")")))))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("span",{parentName:"td",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Deletion"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("span",{parentName:"td",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")")))))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("span",{parentName:"td",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Searching"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("span",{parentName:"td",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")")))))),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("span",{parentName:"td",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"O"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,r.kt)("mi",{parentName:"mrow"},"n"),(0,r.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n)")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,r.kt)("span",{parentName:"span",className:"mopen"},"("),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,r.kt)("span",{parentName:"span",className:"mclose"},")"))))))))),(0,r.kt)("p",null,"where ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"n")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"n")))))," is the number of nodes in the BST."),(0,r.kt)(d,{title:"Suggested Problems",data:p,mdxType:"Table"}))}u.isMDXComponent=!0}}]);