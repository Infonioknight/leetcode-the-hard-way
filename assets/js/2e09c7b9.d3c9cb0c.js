"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[77958],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>c});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var h=r.createContext({}),p=function(e){var t=r.useContext(h),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=p(e.components);return r.createElement(h.Provider,{value:t},e.children)},s="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,h=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),s=p(n),m=a,c=s["".concat(h,".").concat(m)]||s[m]||u[m]||o;return n?r.createElement(c,i(i({ref:t},d),{},{components:n})):r.createElement(c,i({ref:t},d))}));function c(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var h in t)hasOwnProperty.call(t,h)&&(l[h]=t[h]);l.originalType=e,l[s]="string"==typeof e?e:a,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},78171:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>i,default:()=>g,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var r=n(87462),a=(n(67294),n(3905));const o={description:"Author: @vigneshshiv, @radojicic23, @ColeB2 | https://leetcode.com/problems/maximum-depth-of-binary-tree"},i="0104 - Maximum Depth of Binary Tree (Easy)",l={unversionedId:"0100-0199/maximum-depth-of-binary-tree-easy",id:"0100-0199/maximum-depth-of-binary-tree-easy",title:"0104 - Maximum Depth of Binary Tree (Easy)",description:"Author: @vigneshshiv, @radojicic23, @ColeB2 | https://leetcode.com/problems/maximum-depth-of-binary-tree",source:"@site/solutions/0100-0199/0104-maximum-depth-of-binary-tree-easy.md",sourceDirName:"0100-0199",slug:"/0100-0199/maximum-depth-of-binary-tree-easy",permalink:"/solutions/0100-0199/maximum-depth-of-binary-tree-easy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0100-0199/0104-maximum-depth-of-binary-tree-easy.md",tags:[],version:"current",sidebarPosition:104,frontMatter:{description:"Author: @vigneshshiv, @radojicic23, @ColeB2 | https://leetcode.com/problems/maximum-depth-of-binary-tree"},sidebar:"tutorialSidebar",previous:{title:"0103 -  Binary Tree Zigzag Level Order Traversal (Medium)",permalink:"/solutions/0100-0199/binary-tree-zigzag-level-order-traversal-medium"},next:{title:"0105 - Construct Binary Tree from Preorder and Inorder Traversal (Medium)",permalink:"/solutions/0100-0199/construct-binary-tree-from-preorder-and-inorder-traversal-medium"}},h={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Recursive",id:"approach-1-recursive",level:2},{value:"Approach 2: Iterative Depth-First Search",id:"approach-2-iterative-depth-first-search",level:2},{value:"Approach 3: Iterative Breadth-First Search",id:"approach-3-iterative-breadth-first-search",level:2}],d=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",t)},s=d("Tabs"),u=d("TabItem"),m=d("SolutionAuthor"),c={toc:p},f="wrapper";function g(e){let{components:t,...n}=e;return(0,a.kt)(f,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"0104---maximum-depth-of-binary-tree-easy"},"0104 - Maximum Depth of Binary Tree (Easy)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/maximum-depth-of-binary-tree"},"https://leetcode.com/problems/maximum-depth-of-binary-tree")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"Given the ",(0,a.kt)("inlineCode",{parentName:"p"},"root")," of a binary tree, return ",(0,a.kt)("em",{parentName:"p"},"its maximum depth"),"."),(0,a.kt)("p",null,"A binary tree's ",(0,a.kt)("strong",{parentName:"p"},"maximum depth")," is the number of nodes along the longest path from the root node down to the farthest leaf node."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg",alt:null})),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: root = [3,9,20,null,null,15,7]\nOutput: 3\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: root = [1,null,2]\nOutput: 2\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The number of nodes in the tree is in the range ",(0,a.kt)("inlineCode",{parentName:"li"},"[0, 104]"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"-100 <= Node.val <= 100"))),(0,a.kt)("h2",{id:"approach-1-recursive"},"Approach 1: Recursive"),(0,a.kt)("p",null,"Traverse left and right nodes till last, and at every level keep find the maximum between left and right nodes and add 1."),(0,a.kt)(s,{mdxType:"Tabs"},(0,a.kt)(u,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.kt)(m,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n// Time complexity: O(n), where n - # of nodes in the tree\n// Space complexity: O(h), where h - height of the tree from root\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n    }\n}\n"))),(0,a.kt)(u,{value:"python",label:"Python",mdxType:"TabItem"},(0,a.kt)(m,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0 \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n"))),(0,a.kt)(u,{value:"javascript",label:"JavaScript",mdxType:"TabItem"},(0,a.kt)(m,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    if (!root) {\n        return 0;\n    }\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right))\n};\n"))),(0,a.kt)(u,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(m,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (!root) return 0;\n        return 1 + max(maxDepth(root->left), maxDepth(root->right));\n    }\n};\n")))),(0,a.kt)("h2",{id:"approach-2-iterative-depth-first-search"},"Approach 2: Iterative Depth-First Search"),(0,a.kt)("p",null,"We can solve this iteratively by tracking a global max and using a stack to store our data for each node. What we will store is the node we are processing itself and the depth of that node. Then while traversing, we can update the global max depth on each iteration, and return it at the end."),(0,a.kt)("p",null,"While traversing the tree we can process each node by: "),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Updating the global max depth by checking whether the depth of the current node is larger or not, we can do this using the max function. "),(0,a.kt)("li",{parentName:"ol"},"Checking whether it has children nodes, then adding them to the list, making sure the depth of the child node is 1 greater than the current node.")),(0,a.kt)("p",null,"Time Complexity: $$O(n)$$ where n is the number of nodes. We have to process each node once."),(0,a.kt)("p",null,"Space Complexity: $$O(h)$$ where h is the height of the tree. Since we are only storing the nodes of the current path we are traversing."),(0,a.kt)(s,{mdxType:"Tabs"},(0,a.kt)(u,{value:"python",label:"Python",mdxType:"TabItem"},(0,a.kt)(m,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        # Early termination, if given none as a root, return early.\n        if not root:\n            return 0\n        # initialize stack with root and starting depth of 1.\n        stack = [(root,1)]\n        # track our global max_depth\n        max_depth = 1\n        # traverse our tree while our stack has values.\n        while stack:\n            # pop off the node and the count of the current depth.\n            node, count = stack.pop()\n            # update the max depth.\n            max_depth = max(count, max_depth)\n            # if the node has a left child\n            if node.left:\n                # add it to the stack, update the depth of the child node.\n                stack.append((node.left, count+1))\n            # if node has right child\n            if node.right:\n                # add it to the stack, update depth of the child node.\n                stack.append((node.right, count+1))\n        # return the max depth we found.\n        return max_depth\n\n")))),(0,a.kt)("h2",{id:"approach-3-iterative-breadth-first-search"},"Approach 3: Iterative Breadth-First Search"),(0,a.kt)("p",null,"We can also use a queue as our main data structure. A queue allows us to traverse the tree 1 level at a time. Meaning instead of updateing the global max depth at each node, we can update it once at each level."),(0,a.kt)("p",null,"While traversing the tree we can process each level by:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Updating the max depth we have reached."),(0,a.kt)("li",{parentName:"ol"},"Running a for loop over the length of the queue. This allows us to process each node currently in the queue, while also adding the children node to the queue."),(0,a.kt)("li",{parentName:"ol"},"During the processing of each node, make sure it has children before adding them to the queue.")),(0,a.kt)("p",null,"Time Complexity: $$O(n)$$ where n is the number of nodes. We have to process each node once."),(0,a.kt)("p",null,"Space Complexity: $$O(n)$$ where n is the number of nodes, as in a full tree, the last layer will hold $$\\frac {n}{2}$$ nodes."),(0,a.kt)(s,{mdxType:"Tabs"},(0,a.kt)(u,{value:"python",label:"Python",mdxType:"TabItem"},(0,a.kt)(m,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        # Early termination, given a null root.\n        if not root:\n            return 0\n        # initialize our queue with the root node.\n        q = deque([root])\n        # track a global max depth.\n        max_depth = 0\n        # traverse the tree while nodes exist in the queue.\n        while q:\n            # update the max depth\n            max_depth += 1\n            # traverse each node in the queue. Ex. If the current level has\n            # 4 nodes inside the queue, then we will only loop 4 times, despite\n            # also adding extra nodes to the queue during each loop.\n            for _ in range(len(q)):\n                # pop the node we want to process\n                node = q.popleft()\n                # left child check before adding it to the queue.\n                if node.left:\n                    q.append((node.left))\n                # right child check.\n                if node.right:\n                    q.append((node.right))\n        # return our maximum depth\n        return max_depth\n\n")))))}g.isMDXComponent=!0}}]);