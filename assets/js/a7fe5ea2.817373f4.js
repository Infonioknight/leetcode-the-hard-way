"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[69383],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>p});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function m(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),s=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=s(e.components);return n.createElement(l.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=m(e,["components","mdxType","originalType","parentName"]),c=s(a),d=r,p=c["".concat(l,".").concat(d)]||c[d]||h[d]||i;return a?n.createElement(p,o(o({ref:t},u),{},{components:a})):n.createElement(p,o({ref:t},u))}));function p(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=d;var m={};for(var l in t)hasOwnProperty.call(t,l)&&(m[l]=t[l]);m.originalType=e,m[c]="string"==typeof e?e:r,o[1]=m;for(var s=2;s<i;s++)o[s]=a[s];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},28531:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>v,frontMatter:()=>i,kadane2DSuggestedProblems:()=>c,kadaneSuggestedProblems:()=>u,metadata:()=>m,toc:()=>s});var n=a(87462),r=(a(67294),a(3905));const i={title:"Kadane Algorithm",description:"Kadane 1D algorithm finds the maximum sum subarray in an array of integers. Kadane 2D algorithm finds the maximum sum subarray in a 2D array of integers.",hide_table_of_contents:!1,keywords:["leetcode","tutorial","Kadane","algorithm"]},o=void 0,m={unversionedId:"basic-topics/kadane",id:"basic-topics/kadane",title:"Kadane Algorithm",description:"Kadane 1D algorithm finds the maximum sum subarray in an array of integers. Kadane 2D algorithm finds the maximum sum subarray in a 2D array of integers.",source:"@site/tutorials/basic-topics/kadane.md",sourceDirName:"basic-topics",slug:"/basic-topics/kadane",permalink:"/tutorials/basic-topics/kadane",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/basic-topics/kadane.md",tags:[],version:"current",frontMatter:{title:"Kadane Algorithm",description:"Kadane 1D algorithm finds the maximum sum subarray in an array of integers. Kadane 2D algorithm finds the maximum sum subarray in a 2D array of integers.",hide_table_of_contents:!1,keywords:["leetcode","tutorial","Kadane","algorithm"]},sidebar:"tutorialSidebar",previous:{title:"Heap (Priority Queue)",permalink:"/tutorials/basic-topics/heap"},next:{title:"Linear Search",permalink:"/tutorials/basic-topics/linear-search"}},l={},s=[{value:"Overview",id:"overview",level:2},{value:"Algorithm",id:"algorithm",level:2},{value:"Example 1: 0053 - Maximum Subarray",id:"example-1-0053---maximum-subarray",level:2},{value:"Kadane&#39;s 2D Algorithm (Variation)",id:"kadanes-2d-algorithm-variation",level:2},{value:"Overview",id:"overview-1",level:3},{value:"Algorithm",id:"algorithm-1",level:3},{value:"Example 1: 0085 - Maximal Rectangle",id:"example-1-0085---maximal-rectangle",level:3}],u=[{problemName:"152 - Maximum Product Subarray",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/maximum-product-subarray/",solutionLink:""},{problemName:"121 - Best Time to Buy and Sell Stock",difficulty:"Easy",leetCodeLink:"https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",solutionLink:""},{problemName:"918 - Maximum-sum-circular-subarray",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/maximum-sum-circular-subarray/",solutionLink:""}],c=[{problemName:"363 - Max Sum of Rectangle No Larger Than K",difficulty:"Hard",leetCodeLink:"https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/",solutionLink:""}],h=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",t)},d=h("TutorialAuthors"),p=h("Tabs"),b=h("TabItem"),f=h("SolutionAuthor"),g=h("Table"),y={toc:s,kadaneSuggestedProblems:u,kadane2DSuggestedProblems:c},x="wrapper";function v(e){let{components:t,...a}=e;return(0,r.kt)(x,(0,n.Z)({},y,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(d,{names:"@ShivaRapolu01, @wingkwong",mdxType:"TutorialAuthors"}),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"The Kadane's algorithm is a well-known method for solving the problem of finding the maximum sum of a contiguous subarray of a given array of numbers. The basic idea behind the algorithm is to iterate through the array, keeping track of the maximum sum seen so far and the current sum, and updating the maximum sum whenever a new maximum is found. The algorithm has a time complexity of $O(n)$."),(0,r.kt)("h2",{id:"algorithm"},"Algorithm"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Initialize variables to keep track of the current sum and maximum sum, setting them both to the first element of the array."),(0,r.kt)("li",{parentName:"ol"},"Starting from the second element, iterate through the rest of the array."),(0,r.kt)("li",{parentName:"ol"},"At each element, calculate the current sum by adding the current element to the previous current sum. If the current sum is less than zero, set the current sum to zero."),(0,r.kt)("li",{parentName:"ol"},"Compare the current sum to the maximum sum and update the maximum sum if the current sum is greater."),(0,r.kt)("li",{parentName:"ol"},"Return the maximum sum as the result of the algorithm.")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},'Note: Algorithm will work for an array of integers where all numbers in the array are non-negative. If the array contains negative numbers, a variant of this algorithm called "Maximum subarray problem" should be used.')),(0,r.kt)("h2",{id:"example-1-0053---maximum-subarray"},"Example 1: ",(0,r.kt)("a",{parentName:"h2",href:"https://leetcode.com/problems/maximum-subarray/"},"0053 - Maximum Subarray")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\nA subarray is a contiguous part of an array.\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: [4,-1,2,1] has the largest sum = 6.\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"A subarray is a contiguous part of an array maintaining the order of elements. $","[1,2,3]","$ is a subarray of $","[1,2,3,4,5]","$ but $","[1,3,2]","$ & $","[1,3,5]","$ are not.")),(0,r.kt)("p",null,"Consider an array of positive integers only, the maximum sum subarray will be the entire array itself. If the array contains negative integers only, then the maximum sum subarray will be the maximum element of the array.\nIt gets tricker when we have both positive and negative numbers. "),(0,r.kt)("p",null,"If the array consists of positive integers(need not be all positive integers). Then there definitely exists a subarray which has positive sum, because I can choose one positive element in worst case and it would be the subarray with positive sum. "),(0,r.kt)("p",null,"The main idea of Kadane's algorithm is to neglect the negative sum subarrays and take maximum among the positive sum subarrays."),(0,r.kt)(p,{mdxType:"Tabs"},(0,r.kt)(b,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)(f,{name:"@ShivaRapolu01",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n      int n = nums.size(); \n      // globalSum is where the maximum sum of subarray is stored\n      // localSum is where the sum of current subarray is stored\n      int globalSum = INT_MIN, localSum = 0;\n      for (int i = 0; i < n; i++) {\n        // add current element to current sum \n        localSum = localSum + nums[i];\n        // if current sum is greater than globalSum, update globalSum\n        if (globalSum < localSum) {\n          globalSum = localSum;\n        }\n        // if upon adding ith element current sum is becoming less than 0\n        // it cannot contribute to the maximum sum subarray so we neglect it \n        // and reset our current sum to 0 to start another subarray freshly\n        if (localSum < 0) {\n          localSum = 0;\n        }\n      }\n      return globalSum;\n    }\n};\n")))),(0,r.kt)(g,{title:"Suggested Problems",data:u,mdxType:"Table"}),(0,r.kt)("h2",{id:"kadanes-2d-algorithm-variation"},"Kadane's 2D Algorithm (Variation)"),(0,r.kt)("h3",{id:"overview-1"},"Overview"),(0,r.kt)("p",null,"Kadane's 2D Algorithm is a variation of the original Kadane's algorithm that is used to find the maximum sum of a submatrix in a given 2D array. It is a powerful tool for solving problems related to image processing, such as finding the maximum sum of a sub-image in a larger image. The basic idea behind the algorithm is to first find the maximum sum of each row of the submatrix by using the original Kadane's algorithm, then find the maximum sum of all the rows by using the same algorithm again. The algorithm has a time complexity of $O(n^4)$ and is often used in conjunction with other techniques such as dynamic programming to improve the performance."),(0,r.kt)("h3",{id:"algorithm-1"},"Algorithm"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Any submatrix has $4$ sides so we need $4$ variables to uniquely identify and store the boundaries of the maximum sum submatrix."),(0,r.kt)("li",{parentName:"ol"},"Using the 1D kadane's algorithm we can find the maximum sum subarray in a 1D array and with some modifications we can retrieve the boundaries(starting index and ending index) of this maximum sum subarray."),(0,r.kt)("li",{parentName:"ol"},"We need to convert the submatrix into 1D array in such a way that we can identify the boundaries of maximum sum submatrix. For this we can try fixing the left and right boundaries (finalLeft and finalRight) of the submatrix and then we calculate the cummulative sum in each row and store it as 1D array."),(0,r.kt)("li",{parentName:"ol"},"Now we can apply 1D Kadane's algorithm on this 1D array to find the maximum sum subarray and we retrieve the boundaries of this maximum sum subarray."),(0,r.kt)("li",{parentName:"ol"},"The boundaries retrieved from this 1D Kadane's algorithm are the final Top and FinalBottom boundaries of the maximum sum submatrix in the original 2D matrix.")),(0,r.kt)("p",null,"Consider the below problem statement:"),(0,r.kt)("h3",{id:"example-1-0085---maximal-rectangle"},"Example 1: ",(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/maximal-rectangle/"},"0085 - Maximal Rectangle")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Given a rows x cols binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.              ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},' Input: matrix = [\n  ["1","0","1","0","0"],\n  ["1","0","1","1","1"],\n  ["1","1","1","1","1"],\n  ["1","0","0","1","0"]\n]\nOutput: 6\n')),(0,r.kt)("p",null,"If noticed properly we can see that maximum sum submatrix is the 6. Which is the submatrix enclosed by zero-indexed vertices $(1,2),(1,4),(2,2),(2,4)$. "),(0,r.kt)("p",null,"Hint: The problem statement resonates with Kadane's algorithm. The main thing is how to extend the 1D Kadane's algorithm to 2D. General Kadane's algorithm works on a 1D array, so first we need to convert the submatrix into 1D array in such a way that we can uniquely identify the boundaries of maximum sum submatrix. Then we can apply Kadane's algorithm on this 1D array to find the maximum sum subarray."),(0,r.kt)(p,{mdxType:"Tabs"},(0,r.kt)(b,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)(f,{name:"@ShivaRapolu01",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int Kadane(vector<int> arr, int &cursumLeft, int &cursumRight, int n) {\n      // function returns maxiumum sum of subarray and also updates \n      // the left and right indices of the subarray in cursumLeft and  cursumRight respectively\n      int localSum = 0, globalSum = 0;\n      // variable to store the right index of current subarray\n      int localSumRight = 0;\n      // variable to store starting index of intermediate subarrays\n      int localCurStart = 0;\n      for (int i = 0; i < n; ++i) {\n        localSum += arr[i];\n        if (localSum < 0) {\n          localSum = 0;\n          localCurStart = i + 1;\n        } else if (localSum > globalSum) {\n          globalSum = localSum;\n          cursumLeft = localCurStart;\n          cursumRight = i;\n        }\n      }\n      return globalSum;\n    }\n\n\n    int maximalRectangle(vector<vector<char>>& matrix) {\n      int globalMaxSum = 0;\n      // variables to indicate maximum submatrix boundaries\n      int finalLeft, finalRight, finalTop, finalBottom;\n      int rows = matrix.size(); \n      int cols = matrix[0].size(); \n      const int INF = -(rows * cols); \n      // since there can be maximum of rows * cols number of 1's in the matrix \n      // if we encounter 0 in a row in the current submatrix,\n      // our maximum sum submatrix can't contain this row as it should contain only 1's. \n      // as we need to neglect the whole row,\n      // we need erase contributions of 1's in the same row which are before 0 \n      // hence we add INF to temp array before passing it to Kadane's algorithm\n\n      // set the left column\n      for (int left = 0; left < cols; ++left) {\n        vector<int> temp(rows, 0); \n        // temp is used to store sum between current left and right boundaries for every row.\n        \n        // set the right column corresponding to  left\n        for (int right = left; right < cols; ++right) {\n          // calculate sum between current left and right for each row\n          for (int i = 0; i < rows; ++i) {\n            if (matrix[i][right]=='1') {\n              temp[i]+=1;\n            } else {\n              temp[i]+=INF; \n            }\n          }\n          // Find the maximum sum subarray in this created temp array using Kadane's 1D algorithm.\n          int localSum, localSumLeft, localSumRight;\n          localSum = Kadane(temp, localSumLeft, localSumRight, rows);\n          // compare sum with maximum sum so far.\n          // if sum is more, then update globalMaxSum\n          // and also update boundaries of maximum sum submatrix\n          if (localSum > globalMaxSum) {\n            globalMaxSum = localSum;\n            finalLeft = left;\n            finalRight = right;\n            finalTop = localSumLeft;\n            finalBottom = localSumRight;\n          }\n        }\n      }\n      return globalMaxSum; \n    }\n};\n")))),(0,r.kt)(g,{title:"Suggested Problems",data:c,mdxType:"Table"}))}v.isMDXComponent=!0}}]);