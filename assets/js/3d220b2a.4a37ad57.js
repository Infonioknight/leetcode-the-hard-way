"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[67534],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>c});var r=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function m(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=r.createContext({}),l=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},p=function(e){var n=l(e.components);return r.createElement(s.Provider,{value:n},e.children)},u="mdxType",f={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=m(e,["components","mdxType","originalType","parentName"]),u=l(t),d=i,c=u["".concat(s,".").concat(d)]||u[d]||f[d]||o;return t?r.createElement(c,a(a({ref:n},p),{},{components:t})):r.createElement(c,a({ref:n},p))}));function c(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,a=new Array(o);a[0]=d;var m={};for(var s in n)hasOwnProperty.call(n,s)&&(m[s]=n[s]);m.originalType=e,m[u]="string"==typeof e?e:i,a[1]=m;for(var l=2;l<o;l++)a[l]=t[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},78651:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>a,default:()=>c,frontMatter:()=>o,metadata:()=>m,toc:()=>l});var r=t(87462),i=(t(67294),t(3905));const o={description:"Author: @wingkwong | https://leetcode.com/problems/minimum-difference-in-sums-after-removal-of-elements/"},a="2163 - Minimum Difference in Sums After Removal of Elements (Hard)",m={unversionedId:"2100-2199/minimum-difference-in-sums-after-removal-of-elements-hard",id:"2100-2199/minimum-difference-in-sums-after-removal-of-elements-hard",title:"2163 - Minimum Difference in Sums After Removal of Elements (Hard)",description:"Author: @wingkwong | https://leetcode.com/problems/minimum-difference-in-sums-after-removal-of-elements/",source:"@site/solutions/2100-2199/2163-minimum-difference-in-sums-after-removal-of-elements-hard.md",sourceDirName:"2100-2199",slug:"/2100-2199/minimum-difference-in-sums-after-removal-of-elements-hard",permalink:"/solutions/2100-2199/minimum-difference-in-sums-after-removal-of-elements-hard",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2100-2199/2163-minimum-difference-in-sums-after-removal-of-elements-hard.md",tags:[],version:"current",sidebarPosition:2163,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/minimum-difference-in-sums-after-removal-of-elements/"},sidebar:"tutorialSidebar",previous:{title:"2162 - Minimum Cost to Set Cooking Time (Medium)",permalink:"/solutions/2100-2199/minimum-cost-to-set-cooking-time-medium"},next:{title:"2164 - Sort Even and Odd Indices Independently (Easy)",permalink:"/solutions/2100-2199/sort-even-and-odd-indices-independently-easy"}},s={},l=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Two Heaps",id:"approach-1-two-heaps",level:2}],p=(u="SolutionAuthor",function(e){return console.warn("Component "+u+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",e)});var u;const f={toc:l},d="wrapper";function c(e){let{components:n,...t}=e;return(0,i.kt)(d,(0,r.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"2163---minimum-difference-in-sums-after-removal-of-elements-hard"},"2163 - Minimum Difference in Sums After Removal of Elements (Hard)"),(0,i.kt)("h2",{id:"problem-link"},"Problem Link"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/minimum-difference-in-sums-after-removal-of-elements/"},"https://leetcode.com/problems/minimum-difference-in-sums-after-removal-of-elements/")),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"You are given a ",(0,i.kt)("strong",{parentName:"p"},"0-indexed")," integer array ",(0,i.kt)("inlineCode",{parentName:"p"},"nums")," consisting of ",(0,i.kt)("inlineCode",{parentName:"p"},"3 * n")," elements."),(0,i.kt)("p",null,"You are allowed to remove any ",(0,i.kt)("strong",{parentName:"p"},"subsequence")," of elements of size ",(0,i.kt)("strong",{parentName:"p"},"exactly")," ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"nums"),". The remaining ",(0,i.kt)("inlineCode",{parentName:"p"},"2 * n")," elements will be divided into two ",(0,i.kt)("strong",{parentName:"p"},"equal")," parts:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The first ",(0,i.kt)("inlineCode",{parentName:"li"},"n")," elements belonging to the first part and their sum is ",(0,i.kt)("inlineCode",{parentName:"li"},"sumfirst"),"."),(0,i.kt)("li",{parentName:"ul"},"The next ",(0,i.kt)("inlineCode",{parentName:"li"},"n")," elements belonging to the second part and their sum is ",(0,i.kt)("inlineCode",{parentName:"li"},"sumsecond"),".")),(0,i.kt)("p",null,"The ",(0,i.kt)("strong",{parentName:"p"},"difference in sums")," of the two parts is denoted as ",(0,i.kt)("inlineCode",{parentName:"p"},"sumfirst - sumsecond"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"For example, if ",(0,i.kt)("inlineCode",{parentName:"li"},"sumfirst = 3")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"sumsecond = 2"),", their difference is ",(0,i.kt)("inlineCode",{parentName:"li"},"1"),"."),(0,i.kt)("li",{parentName:"ul"},"Similarly, if ",(0,i.kt)("inlineCode",{parentName:"li"},"sumfirst = 2")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"sumsecond = 3"),", their difference is ",(0,i.kt)("inlineCode",{parentName:"li"},"-1"),".")),(0,i.kt)("p",null,"Return ",(0,i.kt)("em",{parentName:"p"},"the ",(0,i.kt)("strong",{parentName:"em"},"minimum difference")," possible between the sums of the two parts after the removal of")," ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," ",(0,i.kt)("em",{parentName:"p"},"elements"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: nums = [3,1,2]\nOutput: -1\nExplanation: Here, nums has 3 elements, so n = 1. \nThus we have to remove 1 element from nums and divide the array into two equal parts.\n- If we remove nums[0] = 3, the array will be [1,2]. The difference in sums of the two parts will be 1 - 2 = -1.\n- If we remove nums[1] = 1, the array will be [3,2]. The difference in sums of the two parts will be 3 - 2 = 1.\n- If we remove nums[2] = 2, the array will be [3,1]. The difference in sums of the two parts will be 3 - 1 = 2.\nThe minimum difference between sums of the two parts is min(-1,1,2) = -1. \n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: nums = [7,9,5,8,1,3]\nOutput: 1\nExplanation: Here n = 2. So we must remove 2 elements and divide the remaining array into two parts containing two elements each.\nIf we remove nums[2] = 5 and nums[3] = 8, the resultant array will be [7,9,1,3]. The difference in sums will be (7+9) - (1+3) = 12.\nTo obtain the minimum difference, we should remove nums[1] = 9 and nums[4] = 1. The resultant array becomes [7,5,8,3]. The difference in sums of the two parts is (7+5) - (8+3) = 1.\nIt can be shown that it is not possible to obtain a difference smaller than 1.\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nums.length == 3 * n")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= n <= 10^5")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= nums[i] <= 10^5"))),(0,i.kt)("h2",{id:"approach-1-two-heaps"},"Approach 1: Two Heaps"),(0,i.kt)("p",null,"Given an array of $$3 ",(0,i.kt)("em",{parentName:"p"}," n$$ elements, we need to remove a subsequence of $$n$$ elements. At the end, we will have $$2 ")," n$$ elements. The answer is the $$sum",(0,i.kt)("em",{parentName:"p"},"{first} - sum"),"{second}$$. Therefore, we need to make $$sum",(0,i.kt)("em",{parentName:"p"},"{first}$$as small as possible and $$sum"),"{second}$$ as large as possible."),(0,i.kt)("p",null,"We use two heaps $$p$$ and $$s$$ to record the smallest $$n$$ elements and the largest $$n$$ elements and $$pre$$to record the sum of $$p$$ and $$suf$$ to record that of $$s$$."),(0,i.kt)("p",null,"Now we handle the middle $$n$$ elements. From left to right, we check if the element $$nums","[i]","$$ is smaller than the top element $$q$$ from $$p$$. If so, we should take this element instead and ditch the top one. We update $$pre' = pre + nums","[i]"," - q$$. At the same time we keep the prefix sum $$pv","[i]","$$ in$$[n, 2 * n)$$. Similarly, we do the same thing from right to left to build the suffix sum $$sv","[i]","$$ in the same range."),(0,i.kt)("p",null,"At the end, we can find out the minimum difference by checking $$pv","[i - 1]"," - sv","[i]","$$ between the middle $$n$$ range."),(0,i.kt)(p,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    long long minimumDifference(vector<int>& nums) {\n        int n = (int) nums.size() / 3;\n        long long ans = 1e18;\n        priority_queue<long long> p;\n        priority_queue<long long, vector<long long>, greater<long long>> s;\n        vector<long long> pv(3 * n, 1e18), sv(3 * n, -1e18);\n        long long pre = 0, suf = 0;\n        for (int i = 0; i < n; i++) {\n            p.push(nums[i]); s.push(nums[3 * n - 1 - i]);\n            pre += nums[i], suf += nums[3 * n - 1 - i];\n        }\n        pv[n - 1] = pre, sv[2 * n] = suf;\n        for (int i = n; i < 2 * n; i++) {\n            long long q = p.top();\n            if (nums[i] < q) {\n                p.pop();\n                pre += nums[i] - q;\n                p.push(nums[i]);\n            }\n            pv[i] = pre;\n        }\n        for (int i = 2 * n - 1; i >= n; i--) {\n            long long q = s.top();\n            if (nums[i] > q) {\n                s.pop();\n                suf += nums[i] - q;\n                s.push(nums[i]);\n            }\n            sv[i] = suf;\n        }\n        for (int i = n; i <= 2 * n; i++) ans = min(ans, pv[i - 1] - sv[i]);\n        return ans;\n    }\n};\n")))}c.isMDXComponent=!0}}]);