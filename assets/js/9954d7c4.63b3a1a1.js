"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[62382],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var l=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);t&&(l=l.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,l)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,l,i=function(e,t){if(null==e)return{};var n,l,i={},s=Object.keys(e);for(l=0;l<s.length;l++)n=s[l],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(l=0;l<s.length;l++)n=s[l],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=l.createContext({}),p=function(e){var t=l.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},u=function(e){var t=p(e.components);return l.createElement(o.Provider,{value:t},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return l.createElement(l.Fragment,{},t)}},c=l.forwardRef((function(e,t){var n=e.components,i=e.mdxType,s=e.originalType,o=e.parentName,u=a(e,["components","mdxType","originalType","parentName"]),d=p(n),c=i,h=d["".concat(o,".").concat(c)]||d[c]||m[c]||s;return n?l.createElement(h,r(r({ref:t},u),{},{components:n})):l.createElement(h,r({ref:t},u))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=n.length,r=new Array(s);r[0]=c;var a={};for(var o in t)hasOwnProperty.call(t,o)&&(a[o]=t[o]);a.originalType=e,a[d]="string"==typeof e?e:i,r[1]=a;for(var p=2;p<s;p++)r[p]=n[p];return l.createElement.apply(null,r)}return l.createElement.apply(null,n)}c.displayName="MDXCreateElement"},61964:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>g,frontMatter:()=>s,metadata:()=>a,toc:()=>p});var l=n(87462),i=(n(67294),n(3905));const s={description:"Author: @wingkwong, @ganajayant, @sourav, @radojicic23 | https://leetcode.com/problems/merge-two-sorted-lists/"},r="0021 - Merge Two Sorted Lists (Easy)",a={unversionedId:"0000-0099/merge-two-sorted-lists-easy",id:"0000-0099/merge-two-sorted-lists-easy",title:"0021 - Merge Two Sorted Lists (Easy)",description:"Author: @wingkwong, @ganajayant, @sourav, @radojicic23 | https://leetcode.com/problems/merge-two-sorted-lists/",source:"@site/solutions/0000-0099/0021-merge-two-sorted-lists-easy.md",sourceDirName:"0000-0099",slug:"/0000-0099/merge-two-sorted-lists-easy",permalink:"/solutions/0000-0099/merge-two-sorted-lists-easy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0000-0099/0021-merge-two-sorted-lists-easy.md",tags:[],version:"current",sidebarPosition:21,frontMatter:{description:"Author: @wingkwong, @ganajayant, @sourav, @radojicic23 | https://leetcode.com/problems/merge-two-sorted-lists/"},sidebar:"tutorialSidebar",previous:{title:"0020 - Valid Parentheses (Easy)",permalink:"/solutions/0000-0099/valid-parentheses-easy"},next:{title:"0022 - Generate Parentheses (Medium)",permalink:"/solutions/0000-0099/generate-parentheses-medium"}},o={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Recursion",id:"approach-1-recursion",level:2},{value:"Approach 2: Iterative",id:"approach-2-iterative",level:2}],u=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",t)},d=u("Tabs"),m=u("TabItem"),c=u("SolutionAuthor"),h={toc:p},f="wrapper";function g(e){let{components:t,...n}=e;return(0,i.kt)(f,(0,l.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"0021---merge-two-sorted-lists-easy"},"0021 - Merge Two Sorted Lists (Easy)"),(0,i.kt)("h2",{id:"problem-link"},"Problem Link"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/merge-two-sorted-lists/"},"https://leetcode.com/problems/merge-two-sorted-lists/")),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"You are given the heads of two sorted linked lists ",(0,i.kt)("inlineCode",{parentName:"p"},"list1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"list2"),"."),(0,i.kt)("p",null,"Merge the two lists in a one ",(0,i.kt)("strong",{parentName:"p"},"sorted")," list. The list should be made by splicing together the nodes of the first two lists."),(0,i.kt)("p",null,"Return ",(0,i.kt)("em",{parentName:"p"},"the head of the merged linked list"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg",alt:null})),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: list1 = [], list2 = []\nOutput: []\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 3:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: list1 = [], list2 = [0]\nOutput: [0]\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The number of nodes in both lists is in the range ",(0,i.kt)("inlineCode",{parentName:"li"},"[0, 50]"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-100 <= Node.val <= 100")),(0,i.kt)("li",{parentName:"ul"},"Both ",(0,i.kt)("inlineCode",{parentName:"li"},"list1")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"list2")," are sorted in ",(0,i.kt)("strong",{parentName:"li"},"non-decreasing")," order.")),(0,i.kt)("h2",{id:"approach-1-recursion"},"Approach 1: Recursion"),(0,i.kt)("p",null,"Let's think of the edge cases first. If either list is null, there is no way to merge. Therefore we simply return the non-null list. In other words, if list1 is null, we return list2, and vice versa."),(0,i.kt)("p",null,"We compare a node in list1 and that in list2. If the value of node in list1 is smaller than that in list2, then we can set the next node to the result of next merge result. Otherwise, we set it in list2."),(0,i.kt)("p",null,"In general, we will have $$list1","[0]"," + mergeTwoLists(list1","[1:]",", list2)$$ for $$list1","[0]"," < list2","[0]","$$ else we have $$list2","[0]"," + mergeTwoLists(list1, list2","[1:]",")$$."),(0,i.kt)(d,{mdxType:"Tabs"},(0,i.kt)(m,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)(c,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        if (list1 == nullptr) return list2;\n        else if (list2 == nullptr) return list1;\n        else if (list1->val < list2->val) {\n            list1->next = mergeTwoLists(list1->next, list2);\n            return list1;\n        } else {\n            list2->next = mergeTwoLists(list2->next, list1);\n            return list2;\n        }\n    }\n};\n"))),(0,i.kt)(m,{value:"python",label:"Python",mdxType:"TabItem"},(0,i.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        if list1 == None:\n            return list2\n        elif list2 == None:\n            return list1\n        elif list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list2.next, list1)\n            return list2\n"))),(0,i.kt)(m,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} list1\n * @param {ListNode} list2\n * @return {ListNode}\n */\nvar mergeTwoLists = function (list1, list2) {\n  if (!list1) {\n    return list2;\n  } else if (!list2) {\n    return list1;\n  } else if (list1.val < list2.val) {\n    list1.next = mergeTwoLists(list1.next, list2);\n    return list1;\n  } else {\n    list2.next = mergeTwoLists(list1, list2.next);\n    return list2;\n  }\n};\n")))),(0,i.kt)("h2",{id:"approach-2-iterative"},"Approach 2: Iterative"),(0,i.kt)("p",null,"We create a head and tail pointer."),(0,i.kt)("p",null,"The head pointer is created so that we can keep track of the beginning element of our list and return it in $O(1)$\nFirstly we check if either of the linked list $list1$ or $list2$ is empty if it is then we simply return the non-empty list\nNow we compare the first element of both the list in order to find out our beginning element of the merged linked list\nWe set head and tail pointer to the above-obtained element and increase the $list1$ or $list2$ pointer to the next element accordingly."),(0,i.kt)("p",null,"Now, we run a while loop until any of the list terminates."),(0,i.kt)("p",null,"Case 1: if the $list1$ value is less than l2: then we shift our tail pointer to $list1$ and set tail as the current $list1$ now we shift our l1 pointer to the next element of that list."),(0,i.kt)("p",null,"Case 2: if the $list2$ value is less than $list1$: then we shift our tail pointer to $list2$ and set tail as the current $list2$ now we shift our $list2$ pointer to the next element of that list."),(0,i.kt)("p",null,"Now when these list $list1$ and $list2$ are of equal length then the while loop will terminate before traversing whole list\nTo handle such cases we will check which list got terminated."),(0,i.kt)("p",null,"For example, if $list1$ is null right now then we just shift our tail pointer to the current element of $list2$ and copy the remaining element of $list2$."),(0,i.kt)("p",null,"As we are already having a sorted merged list, hence all the remaining elements will be greater than the largest of our current merged list. So we can just copy the remaining list."),(0,i.kt)(d,{mdxType:"Tabs"},(0,i.kt)(m,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)(c,{name:"@ganajayant",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode ll = new ListNode();\n        ListNode tail = ll;\n\n        while (list1 != null && list2 != null) {\n            if (list1.val < list2.val) {\n                tail.next = list1;\n                list1 = list1.next;\n            } else {\n                tail.next = list2;\n                list2 = list2.next;\n            }\n            tail = tail.next;\n        }\n\n        if (list1 != null) {\n            tail.next = list1;\n            tail = tail.next;\n        }\n\n        else if (list2 != null) {\n            tail.next = list2;\n            tail = tail.next;\n        }\n\n        return ll.next;\n    }\n}\n"))),(0,i.kt)(m,{value:"py",label:"Python",mdxType:"TabItem"},(0,i.kt)(c,{name:"@sourav",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode()\n        tail = dummy\n        while list1 and list2:\n            if list1.val< list2.val:\n                tail.next = list1\n                list1 = list1.next\n                tail = tail.next\n            else:\n                tail.next = list2\n                list2 = list2.next\n                tail = tail.next\n        if list1:\n            tail.next = list1\n        if list2:\n            tail.next = list2\n        return dummy.next\n"))),(0,i.kt)(m,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} list1\n * @param {ListNode} list2\n * @return {ListNode}\n */\nvar mergeTwoLists = function (list1, list2) {\n  const dummy = new ListNode();\n  let tail = dummy;\n  while (list1 && list2) {\n    if (list1.val < list2.val) {\n      tail.next = list1;\n      list1 = list1.next;\n    } else {\n      tail.next = list2;\n      list2 = list2.next;\n    }\n    tail = tail.next;\n  }\n  if (list1) tail.next = list1;\n  if (list2) tail.next = list2;\n  return dummy.next;\n};\n"))),(0,i.kt)(m,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode* dummy = new ListNode();\n        auto tail = dummy;\n        while (list1 && list2) {\n            if (list1->val < list2->val) {\n                tail->next = list1;\n                list1 = list1->next;\n            } else {\n                tail->next = list2;\n                list2 = list2->next;\n            }\n            tail = tail->next;\n        }\n        if (list1) tail->next = list1;\n        if (list2) tail->next = list2;\n        return dummy->next;\n    }\n};\n")))))}g.isMDXComponent=!0}}]);