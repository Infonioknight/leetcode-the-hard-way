"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[15427],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>h});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function m(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=r.createContext({}),l=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},s=function(e){var t=l(e.components);return r.createElement(u.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,u=e.parentName,s=m(e,["components","mdxType","originalType","parentName"]),p=l(n),d=a,h=p["".concat(u,".").concat(d)]||p[d]||c[d]||i;return n?r.createElement(h,o(o({ref:t},s),{},{components:n})):r.createElement(h,o({ref:t},s))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var m={};for(var u in t)hasOwnProperty.call(t,u)&&(m[u]=t[u]);m.originalType=e,m[p]="string"==typeof e?e:a,o[1]=m;for(var l=2;l<i;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4612:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>o,default:()=>y,frontMatter:()=>i,metadata:()=>m,toc:()=>l});var r=n(87462),a=(n(67294),n(3905));const i={description:"Author: @Dhanu084 | https://leetcode.com/problems/partition-array-for-maximum-sum/description/",tags:["Recursion","Dynamic Programming"]},o="1043 - Partition Array for Maximum Sum (Medium)",m={unversionedId:"1000-1099/partition-array-for-maximum-sum-medium",id:"1000-1099/partition-array-for-maximum-sum-medium",title:"1043 - Partition Array for Maximum Sum (Medium)",description:"Author: @Dhanu084 | https://leetcode.com/problems/partition-array-for-maximum-sum/description/",source:"@site/solutions/1000-1099/1043-partition-array-for-maximum-sum-medium.md",sourceDirName:"1000-1099",slug:"/1000-1099/partition-array-for-maximum-sum-medium",permalink:"/solutions/1000-1099/partition-array-for-maximum-sum-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1000-1099/1043-partition-array-for-maximum-sum-medium.md",tags:[{label:"Recursion",permalink:"/solutions/tags/recursion"},{label:"Dynamic Programming",permalink:"/solutions/tags/dynamic-programming"}],version:"current",sidebarPosition:1043,frontMatter:{description:"Author: @Dhanu084 | https://leetcode.com/problems/partition-array-for-maximum-sum/description/",tags:["Recursion","Dynamic Programming"]},sidebar:"tutorialSidebar",previous:{title:"1029 - Two City Scheduling (Medium)",permalink:"/solutions/1000-1099/two-city-scheduling-medium"},next:{title:"1046 - Last Stone Weight (Easy)",permalink:"/solutions/1000-1099/last-stone-weight-easy"}},u={},l=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Recursion",id:"approach-1-recursion",level:2},{value:"Approach 2: Memoization",id:"approach-2-memoization",level:2},{value:"Approach 3: Iterative DP",id:"approach-3-iterative-dp",level:2},{value:"References",id:"references",level:2}],s=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",t)},p=s("Tabs"),c=s("TabItem"),d=s("SolutionAuthor"),h={toc:l},f="wrapper";function y(e){let{components:t,...n}=e;return(0,a.kt)(f,(0,r.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"1043---partition-array-for-maximum-sum-medium"},"1043 - Partition Array for Maximum Sum (Medium)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/partition-array-for-maximum-sum/"},"https://leetcode.com/problems/partition-array-for-maximum-sum/")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"Given an integer array arr, partition the array into (contiguous) subarrays of length at most k. After partitioning, each subarray has their values changed to become the maximum value of that subarray."),(0,a.kt)("p",null,"Return the largest sum of the given array after partitioning. Test cases are generated so that the answer fits in a 32-bit integer."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: arr = [1,15,7,9,2,5,10], k = 3\nOutput: 84\nExplanation: arr becomes [15,15,15,9,10,10,10]\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4\nOutput: 83\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 3:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: arr = [1], k = 1\nOutput: 1\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"1 <= arr.length <= 500"),(0,a.kt)("li",{parentName:"ul"},"0 <= arr","[i]"," <= 109"),(0,a.kt)("li",{parentName:"ul"},"1 <= k <= arr.length")),(0,a.kt)("h2",{id:"approach-1-recursion"},"Approach 1: Recursion"),(0,a.kt)("p",null,"Time complexity: $$O(n * k ^ n)$$"),(0,a.kt)("p",null,"Space complexity: $$O(n)$$ + auxilary recursive stack space"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Note:"),"\nThis soution will give Time Limit Exceeded at leetcode as it is exponential in nature"),(0,a.kt)(p,{mdxType:"Tabs"},(0,a.kt)(c,{value:"py",label:"Python",mdxType:"TabItem"},(0,a.kt)(d,{name:"@dhanu084",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        def dfs(ind, k):\n            if ind == len(arr):\n                return 0\n\n            maxi = max_sum = length = 0\n\n            '''\n                for eg Input : [1,15,7,9,2,5,10]\n                From every index loop till index + k\n                Find the maximum in the subarray [index : index+k]\n                multiply it with the current subarray length to get the current sum\n                If current sum is greater than maximum sum , update it\n\n                there are lot of decisions in recursion, below is the working of the optimal one:\n                for subarray [1,15,7] of size k , the maximum in the subarray is 15 and length is 3\n                so the sum will be 15 * 3 = 45\n                for the next Partition keep just [9] as a subarray with sum 9 * 1 = 9\n                for the next partition keep subarray [2,5,10], the maximum is 10 and length is 3\n                so the sum is 10 * 3 = 30\n\n                So the total sum is 45 + 9 + 30 = 84\n\n                Please try out other partitions like\n                [1] [15] [7,9,2,5,10] = (1 * 1) + (15 * 1) + (10 * 5) = 67\n                [1,15] [7] [9,2,5,10] = (15 * 1) + (7 * 1) + (10 * 4) = 62\n                [1,15,7] [9,2,5] [10] = (15 * 1) + (9 * 3) + (10 * 1) = 52\n                [1,15,7] [9,2] [5,10] = (15 * 3) + (9 * 2) + (10 * 2) = 73\n                etc for better understanding\n            '''\n\n            for i in range(ind, min(ind + k, len(arr))):\n                length += 1\n                maxi = max(maxi, arr[i])\n                curr_sum = length * maxi + dfs(i + 1, k)\n                max_sum = max(curr_sum, max_sum)\n            return max_sum\n        return dfs(0, k)\n")))),(0,a.kt)("h2",{id:"approach-2-memoization"},"Approach 2: Memoization"),(0,a.kt)("p",null,"Time complexity: $$O(n * k)$$"),(0,a.kt)("p",null,"Space complexity: $$O(n)$$ + auxilary recursive stack space"),(0,a.kt)(p,{mdxType:"Tabs"},(0,a.kt)(c,{value:"py",label:"Python",mdxType:"TabItem"},(0,a.kt)(d,{name:"@dhanu084",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [-1] * n\n\n        def dfs(ind, k):\n            if ind == len(arr):\n                return 0\n\n            '''\n                 if decision tree is drawn for the above recursive solution,\n                 a lot of overlapping subproblems can be found\n                 To avoid subsequent recursive calls to find the result\n                 which is already calculated cache the results once calculated and return it later\n                 when the same result is required.\n\n                 For caching consider the changing parameters in the function,\n                 for this problem only index changes during recursion so\n                 create an array of size n and cache the results one found\n\n                 if k also changes then create 2D array for caching both index and k\n            '''\n            if dp[ind] != -1:\n                return dp[ind]\n\n            maxi = max_sum = length = 0\n\n            for i in range(ind, min(ind + k, len(arr))):\n                length += 1\n                maxi = max(maxi, arr[i])\n                curr_sum = length * maxi + dfs(i + 1, k)\n                max_sum = max(curr_sum, max_sum)\n            dp[ind] = max_sum\n            # cache the results\n            return dp[ind]\n\n        return dfs(0, k)\n")))),(0,a.kt)("h2",{id:"approach-3-iterative-dp"},"Approach 3: Iterative DP"),(0,a.kt)("p",null,"Time complexity: $$O(n * k)$$"),(0,a.kt)("p",null,"Space complexity: $$O(n)$$"),(0,a.kt)(p,{mdxType:"Tabs"},(0,a.kt)(c,{value:"py",label:"Python",mdxType:"TabItem"},(0,a.kt)(d,{name:"@dhanu084",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [0] * (n + 1)\n        ans = 0\n\n        for i in range(n-1, -1, -1):\n            maxi = max_sum = length = 0\n            for j in range(i, min(i + k, n)):\n                length += 1\n                maxi = max(maxi, arr[j])\n                curr_sum = length * maxi + dp[j+1]\n                max_sum = max(max_sum, curr_sum)\n            dp[i] = max_sum\n\n        return dp[0]\n")))),(0,a.kt)("h2",{id:"references"},"References"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=PhWWJmaKfMc"},"Striver DP playlist - takeyouforward youtube channel")))}y.isMDXComponent=!0}}]);