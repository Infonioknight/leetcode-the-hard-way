"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[85551],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>m});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var o=r.createContext({}),v=function(e){var n=r.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=v(e.components);return r.createElement(o.Provider,{value:n},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,l=e.originalType,o=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=v(t),d=a,m=u["".concat(o,".").concat(d)]||u[d]||c[d]||l;return t?r.createElement(m,i(i({ref:n},p),{},{components:t})):r.createElement(m,i({ref:n},p))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,i=new Array(l);i[0]=d;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s[u]="string"==typeof e?e:a,i[1]=s;for(var v=2;v<l;v++)i[v]=t[v];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},42358:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>I,frontMatter:()=>l,metadata:()=>s,toc:()=>v});var r=t(87462),a=(t(67294),t(3905));const l={description:"Author: @wingkwong, @radojicic23 | https://leetcode.com/problems/insert-interval/",tags:["Array"]},i="0057 - Insert Interval (Medium)",s={unversionedId:"0000-0099/insert-interval-medium",id:"0000-0099/insert-interval-medium",title:"0057 - Insert Interval (Medium)",description:"Author: @wingkwong, @radojicic23 | https://leetcode.com/problems/insert-interval/",source:"@site/solutions/0000-0099/0057-insert-interval-medium.md",sourceDirName:"0000-0099",slug:"/0000-0099/insert-interval-medium",permalink:"/solutions/0000-0099/insert-interval-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0000-0099/0057-insert-interval-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"}],version:"current",sidebarPosition:57,frontMatter:{description:"Author: @wingkwong, @radojicic23 | https://leetcode.com/problems/insert-interval/",tags:["Array"]},sidebar:"tutorialSidebar",previous:{title:"0051 - N-Queens (Hard)",permalink:"/solutions/0000-0099/n-queens-hard"},next:{title:"0061 - Rotate List (Medium)",permalink:"/solutions/0000-0099/rotate-list-medium"}},o={},v=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: One Pass",id:"approach-1-one-pass",level:2}],p=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",n)},u=p("Tabs"),c=p("TabItem"),d=p("SolutionAuthor"),m={toc:v},w="wrapper";function I(e){let{components:n,...t}=e;return(0,a.kt)(w,(0,r.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"0057---insert-interval-medium"},"0057 - Insert Interval (Medium)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/insert-interval/"},"https://leetcode.com/problems/insert-interval/")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"You are given an array of non-overlapping intervals ",(0,a.kt)("inlineCode",{parentName:"p"},"intervals")," where ",(0,a.kt)("inlineCode",{parentName:"p"},"intervals[i] = [starti, endi]")," represent the start and the end of the ",(0,a.kt)("inlineCode",{parentName:"p"},"ith")," interval and ",(0,a.kt)("inlineCode",{parentName:"p"},"intervals")," is sorted in ascending order by ",(0,a.kt)("inlineCode",{parentName:"p"},"starti"),". You are also given an interval ",(0,a.kt)("inlineCode",{parentName:"p"},"newInterval = [start, end]")," that represents the start and end of another interval."),(0,a.kt)("p",null,"Insert ",(0,a.kt)("inlineCode",{parentName:"p"},"newInterval")," into ",(0,a.kt)("inlineCode",{parentName:"p"},"intervals")," such that ",(0,a.kt)("inlineCode",{parentName:"p"},"intervals")," is still sorted in ascending order by ",(0,a.kt)("inlineCode",{parentName:"p"},"starti")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"intervals")," still does not have any overlapping intervals (merge overlapping intervals if necessary)."),(0,a.kt)("p",null,"Return ",(0,a.kt)("inlineCode",{parentName:"p"},"intervals"),(0,a.kt)("em",{parentName:"p"},"after the insertion"),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"0 <= intervals.length <= 10^4")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"intervals[i].length == 2")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"0 <= start_i <= endi <= 10^5")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"intervals")," is sorted by ",(0,a.kt)("inlineCode",{parentName:"li"},"start_i")," in ",(0,a.kt)("strong",{parentName:"li"},"ascending")," order."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"newInterval.length == 2")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"0 <= start <= end <= 10^5"))),(0,a.kt)("h2",{id:"approach-1-one-pass"},"Approach 1: One Pass"),(0,a.kt)(u,{mdxType:"Tabs"},(0,a.kt)(c,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>> ans;\n        int n = intervals.size();\n        for (int i = 0; i < n; i++) {\n            if (intervals[i][1] < newInterval[0]) {\n                // current interval starts first & not covered by newInterval, add intervals[i] to ans\n                // [curInterval]\n                //                      [newInterval]\n                ans.push_back(intervals[i]);\n            } else if (intervals[i][0] > newInterval[1]) {\n                // newInterval starts first and not covered by current interval\n                // add newInterval to ans and set newInterval = curInterval\n                //                       [curInterval]\n                // [newInterval]\n                ans.push_back(newInterval);\n                newInterval = intervals[i];\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\n                // they are overlapped, merge them\n                // [curInterval]\n                //        [newInterval]\n                // or\n                // [newInterval]\n                //        [curInterval]\n                newInterval[0] = min(newInterval[0], intervals[i][0]);\n                newInterval[1] = max(newInterval[1], intervals[i][1]);\n            }\n        }\n        // add the last interval\n        ans.push_back(newInterval);\n        return ans;\n    }\n};\n"))),(0,a.kt)(c,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        List<int[]> ans = new ArrayList<>();\n        int n = intervals.length;\n        for (int i = 0; i < n; i++) {\n            int[] curInterval = intervals[i];\n            if (intervals[i][1] < newInterval[0]) {\n                // current interval starts first & not covered by newInterval, add intervals[i] to ans\n                // [curInterval]\n                //                      [newInterval]\n                ans.add(intervals[i]);\n            } else if (intervals[i][0] > newInterval[1]) {\n                // newInterval starts first and not covered by current interval\n                // add newInterval to ans and set newInterval = curInterval\n                //                       [curInterval]\n                // [newInterval]\n                ans.add(newInterval);\n                newInterval = intervals[i];\n            } else if (intervals[i][1] >= newInterval[0] || intervals[i][0] <= newInterval[1]) {\n                // they are overlapped, merge them\n                // [curInterval]\n                //        [newInterval]\n                // or\n                // [newInterval]\n                //        [curInterval]\n                newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n                newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n            }\n        }\n        // add the last interval\n        ans.add(newInterval);\n        return ans.toArray(new int[ans.size()][]);\n    }\n}\n\n"))),(0,a.kt)(c,{value:"py",label:"Python",mdxType:"TabItem"},(0,a.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        ans = []\n        n = len(intervals)\n        for i in range(n):\n            if intervals[i][1] < newInterval[0]:\n                # current interval starts first & not covered by newInterval, add intervals[i] to ans\n                # [curInterval]\n                #                      [newInterval]\n                ans.append(intervals[i])\n            elif intervals[i][0] > newInterval[1]:\n                # newInterval starts first and not covered by current interval\n                # Add newInterval to ans and set newInterval = curInterval\n                #                       [curInterval]\n                # [newInterval]\n                ans.append(newInterval)\n                newInterval = intervals[i]\n            elif intervals[i][1] >= newInterval[0] or intervals[i][0] <= newInterval[1]:\n                # They are overlapped, merge them\n                # [curInterval]\n                #        [newInterval]\n                # or\n                # [newInterval]\n                #        [curInterval]\n                newInterval[0] = min(newInterval[0], intervals[i][0])\n                newInterval[1] = max(newInterval[1], intervals[i][1])\n        # add the last interval\n        ans.append(newInterval)\n        return ans\n\n"))),(0,a.kt)(c,{value:"rs",label:"Rust",mdxType:"TabItem"},(0,a.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rs"},"use std::cmp::min;\nuse std::cmp::max;\n\nimpl Solution {\n    pub fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut ans = vec![];\n        let n = intervals.len();\n        let mut new_interval = new_interval;\n        for i in 0 .. n {\n            if intervals[i][1] < new_interval[0] {\n                // current interval starts first & not covered by newInterval, add intervals[i] to ans\n                // [curInterval]\n                //                      [newInterval]\n                ans.push(intervals[i].clone());\n            } else if intervals[i][0] > new_interval[1] {\n                // NewInterval starts first and not covered by current interval\n                // Add newInterval to ans and set newInterval = curInterval\n                //                       [curInterval]\n                // [newInterval]\n                ans.push(new_interval.clone());\n                new_interval = intervals[i].clone();\n            } else if intervals[i][1] >= new_interval[0] || intervals[i][0] <= new_interval[1] {\n                // they are overlapped, merge them\n                // [curInterval]\n                //        [newInterval]\n                // or\n                // [newInterval]\n                //        [curInterval]\n                new_interval[0] = min(new_interval[0], intervals[i][0]);\n                new_interval[1] = max(new_interval[1], intervals[i][1]);\n            }\n        }\n        // add the last interval\n        ans.push(new_interval.clone());\n        ans\n    }\n}\n"))),(0,a.kt)(c,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,a.kt)(d,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"/**\n * @param {number[][]} intervals\n * @param {number[]} newInterval\n * @return {number[][]}\n */\nvar insert = function (intervals, newInterval) {\n  let res = [];\n  for (i = 0; i < intervals.length; i++) {\n    if (newInterval[1] < intervals[i][0]) {\n      res.push(newInterval);\n      return res.concat(intervals.slice(i, intervals.length));\n    } else if (newInterval[0] > intervals[i][1]) {\n      res.push(intervals[i]);\n    } else {\n      newInterval[0] = [Math.min(newInterval[0], intervals[i][0])];\n      newInterval[1] = [Math.max(newInterval[1], intervals[i][1])];\n    }\n  }\n  res.push(newInterval);\n  return res;\n};\n")))))}I.isMDXComponent=!0}}]);