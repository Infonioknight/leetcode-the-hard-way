"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[94631],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var o=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=o.createContext({}),l=function(e){var t=o.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=l(e.components);return o.createElement(p.Provider,{value:t},e.children)},h="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=l(n),m=i,d=h["".concat(p,".").concat(m)]||h[m]||c[m]||r;return n?o.createElement(d,a(a({ref:t},u),{},{components:n})):o.createElement(d,a({ref:t},u))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,a=new Array(r);a[0]=m;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[h]="string"==typeof e?e:i,a[1]=s;for(var l=2;l<r;l++)a[l]=n[l];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},65098:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>a,default:()=>g,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var o=n(87462),i=(n(67294),n(3905));const r={description:"Author: @wingkwong, @heiheihang, @ColeB2 | https://leetcode.com/problems/k-closest-points-to-origin/",tags:["Array","Math","Divide and Conquer","Geometry","Sorting","Heap (Priority Queue)","Quickselect"]},a="0973 - K Closest Points to Origin (Medium)",s={unversionedId:"0900-0999/k-closest-points-to-origin-medium",id:"0900-0999/k-closest-points-to-origin-medium",title:"0973 - K Closest Points to Origin (Medium)",description:"Author: @wingkwong, @heiheihang, @ColeB2 | https://leetcode.com/problems/k-closest-points-to-origin/",source:"@site/solutions/0900-0999/0973-k-closest-points-to-origin-medium.md",sourceDirName:"0900-0999",slug:"/0900-0999/k-closest-points-to-origin-medium",permalink:"/solutions/0900-0999/k-closest-points-to-origin-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0900-0999/0973-k-closest-points-to-origin-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Math",permalink:"/solutions/tags/math"},{label:"Divide and Conquer",permalink:"/solutions/tags/divide-and-conquer"},{label:"Geometry",permalink:"/solutions/tags/geometry"},{label:"Sorting",permalink:"/solutions/tags/sorting"},{label:"Heap (Priority Queue)",permalink:"/solutions/tags/heap-priority-queue"},{label:"Quickselect",permalink:"/solutions/tags/quickselect"}],version:"current",sidebarPosition:973,frontMatter:{description:"Author: @wingkwong, @heiheihang, @ColeB2 | https://leetcode.com/problems/k-closest-points-to-origin/",tags:["Array","Math","Divide and Conquer","Geometry","Sorting","Heap (Priority Queue)","Quickselect"]},sidebar:"tutorialSidebar",previous:{title:"0967 - Numbers With Same Consecutive Differences (Medium)",permalink:"/solutions/0900-0999/numbers-with-same-consecutive-differences-medium"},next:{title:"0974 - Subarray Sums Divisible by K (Medium)",permalink:"/solutions/0900-0999/subarray-sums-divisible-by-k-medium"}},p={},l=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: nth_element",id:"approach-1-nth_element",level:2},{value:"Approach 2: Heap (Python)",id:"approach-2-heap-python",level:2},{value:"Approach 3: Quick Select",id:"approach-3-quick-select",level:2}],u=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",t)},h=u("Tabs"),c=u("TabItem"),m=u("SolutionAuthor"),d={toc:l},k="wrapper";function g(e){let{components:t,...n}=e;return(0,i.kt)(k,(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"0973---k-closest-points-to-origin-medium"},"0973 - K Closest Points to Origin (Medium)"),(0,i.kt)("h2",{id:"problem-link"},"Problem Link"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/k-closest-points-to-origin/"},"https://leetcode.com/problems/k-closest-points-to-origin/")),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"Given an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"points")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"points[i] = [xi, yi]")," represents a point on the ",(0,i.kt)("strong",{parentName:"p"},"X-Y")," plane and an integer ",(0,i.kt)("inlineCode",{parentName:"p"},"k"),", return the ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," closest points to the origin ",(0,i.kt)("inlineCode",{parentName:"p"},"(0, 0)"),"."),(0,i.kt)("p",null,"The distance between two points on the ",(0,i.kt)("strong",{parentName:"p"},"X-Y")," plane is the Euclidean distance (i.e., ",(0,i.kt)("inlineCode",{parentName:"p"},"\u221a(x1 - x2)2 + (y1 - y2)2"),")."),(0,i.kt)("p",null,"You may return the answer in ",(0,i.kt)("strong",{parentName:"p"},"any order"),". The answer is ",(0,i.kt)("strong",{parentName:"p"},"guaranteed")," to be ",(0,i.kt)("strong",{parentName:"p"},"unique")," (except for the order that it is in)."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2021/03/03/closestplane1.jpg",alt:null})),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: points = [[1,3],[-2,2]], k = 1\nOutput: [[-2,2]]\nExplanation:\nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: points = [[3,3],[5,-1],[-2,4]], k = 2\nOutput: [[3,3],[-2,4]]\nExplanation: The answer [[-2,4],[3,3]] would also be accepted.\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= k <= points.length <= 10^4")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-10^4 < xi, yi < 10^4"))),(0,i.kt)("h2",{id:"approach-1-nth_element"},"Approach 1: nth_element"),(0,i.kt)(h,{mdxType:"Tabs"},(0,i.kt)(c,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)(m,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\n        // we don't need to care about the exact order \n        // nth_element approach is enough\n        nth_element(points.begin(), points.begin() + K, points.end(),[](vector<int>& q, vector<int>& p) {\n            // sort by Euclidean distance\n            // dist(q, p) = sqrt( (q1 - p1) * (q1 - p1) + (q2 - p2) * (q2 - p2) )\n            // since we are comparing the points with the origin (0,0)\n            // dist(q, p) = sqrt( (q1) * (q1) + (q2) * (q2) )\n            // and we don't need to perform sqrt as sqrt(a) must be smaller than sqrt(b) if a < b\n            return q[0] * q[0] + q[1] * q[1] < p[0] * p[0] + p[1] * p[1];\n        });\n        // resize points to show K clostest points\n        points.resize(K);\n        return points;\n    }\n};\n")))),(0,i.kt)("h2",{id:"approach-2-heap-python"},"Approach 2: Heap (Python)"),(0,i.kt)("p",null,"We can use a max heap of size ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," to store the ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," points closest to the origin."),(0,i.kt)("p",null,"Time Complexity: $$O(nlogk)$$. Where n is the length of points, and k is the given k. We must loop through all points inside points, and it takes $$logk$$ time to maintain our heap."),(0,i.kt)("p",null,"Space Complexity: $$O(k)$$. We only need to maintain k items inside of our heap."),(0,i.kt)(h,{mdxType:"Tabs"},(0,i.kt)(c,{value:"python",label:"Python",mdxType:"TabItem"},(0,i.kt)(m,{name:"@heiheihang",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        h = []\n        \n        for a, b in points:\n            \n            dist = a ** 2 + b ** 2\n            heappush(h, [-dist, a, b])\n            if len(h) > k:\n                heappop(h)\n        \n        res = []\n        \n        while h:\n            res.append([h[0][1], h[0][2]])\n            heappop(h)\n            \n        return res\n")))),(0,i.kt)("h2",{id:"approach-3-quick-select"},"Approach 3: Quick Select"),(0,i.kt)("p",null,"We can sort in O(nlogn) time, and select k, but instead of sorting the whole array, we really just need the first k elements. That is where quick select comes in."),(0,i.kt)("p",null,"To perform quick select, we need $$left$$ and $$right$$ pointers and a partition, $$p$$. We can partition by selecting a random $$pivot$$ and swapping it with the value at our $$right$$ pointer, then looping through all the elements from our $$left$$ to $$right$$ pointer, inclusive. We would then swap the values that are $$<=$$ to our $$pivot$$ with a third pointer that starts at the $$left$$ pointer and moves up after each swap."),(0,i.kt)("p",null,"If we initialize our partition to be the length of the array, $$points$$, then we only need to run our partition algorithm until we reach a point that $$p$$ == $$k$$. If our $$p$$ is less than $$k$$ it means we don't have enough points inside our partition so we would have to move our left pointer up to sort more values inside of k. Otherwise, we would have to move our right pointer back towards the left, to shrink how many elements we have inside our partition."),(0,i.kt)("p",null,"When our partition, $$p$$ finally reaches a point that equals $$k$$, it means that all the values to the left of the partition are less than or equal to the pivot, and all to the right are greater than. Meaning we have the k closest elements to the origin."),(0,i.kt)("p",null,"Time Complexity: $$O(n)$$. O(n) is the average case based on the pivot we select at random. If we select the worst pivot during each call to partition, our time will approach $$O(n^2)$$, but by selecting a random pivot, this is rare to happen."),(0,i.kt)("p",null,"Space Complexity: $$O(1)$$ we can do this in place, and just swap around the points inside our points array."),(0,i.kt)(h,{mdxType:"Tabs"},(0,i.kt)(c,{value:"python",label:"Python",mdxType:"TabItem"},(0,i.kt)(m,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        # create a function to calculate the euclidean distance of points\n        euclid_dist = lambda xy: xy[0]**2 + xy[1]**2\n        # partition function, takes left and right pointer as parameters\n        # to work as endpoints of our array we are trying to partition.\n        def partition(l, r):\n            # pivot, select one at random between l and r. We use a\n            # pivot instead of always selecting the first/last etc to \n            # hopefully prevent O(n^2) time complexity against malicious\n            # inputs.\n            pivot = random.randint(l, r)\n            # swap our pivot point with our right point.\n            points[r], points[pivot] = points[pivot], points[r]\n            # pointer starting at left pointer to track where we\n            # swap our values to that are less than or equal to our\n            # pivot distance\n            i = l\n            pivot_dist = euclid_dist(points[r])\n            # loop from l to r+1 for inclusivity to make sure we swap\n            # our pivot back into proper place.\n            for j in range(l, r+1):\n                # point we are looking at, j is closer to the origin\n                # than the point at our pivot.\n                if euclid_dist(points[j]) <= pivot_dist:\n                    # swap it with i. Depending where our pivot ends up\n                    # all points swapped will be less than the pivot.\n                    points[i], points[j] = points[j], points[i]\n                    i += 1\n            # return our partition index.\n            return i - 1\n\n        # start our algorithm, initialize left, right and partition.\n        left, right, p = 0, len(points) - 1, len(points)\n        # loop until p == k. At p == k it means we have exactly k\n        # elements less than our partition p.\n        while p != k:\n            # get our partition\n            p = partition(left,right)\n            # partition we received < k it means we don't have enough\n            # elements to the left of our partition that are < p.\n            # Move left pointer up to get more.\n            if p < k:\n                left = p + 1\n            # p >= k it means we have too many elements left of our\n            # partition, we have more than k elements closer. Move\n            # right pointer left to get fewer points.\n            else:\n                right = p - 1\n        # Reached point p == k, meaning we know all points to the left\n        # of p/k closer to the origin than p. Return that slice of points.\n        return points[:k]\n")))))}g.isMDXComponent=!0}}]);