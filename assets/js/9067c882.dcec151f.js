"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[55673],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),p=u(n),d=a,h=p["".concat(s,".").concat(d)]||p[d]||c[d]||i;return n?r.createElement(h,l(l({ref:t},m),{},{components:n})):r.createElement(h,l({ref:t},m))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[p]="string"==typeof e?e:a,l[1]=o;for(var u=2;u<i;u++)l[u]=n[u];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},63448:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>f,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var r=n(87462),a=(n(67294),n(3905));const i={description:"Author: @wingkwong, @ColeB2, @radojicic23 | https://leetcode.com/problems/binary-search/"},l="0704 - Binary Search (Easy)",o={unversionedId:"0700-0799/binary-search-easy",id:"0700-0799/binary-search-easy",title:"0704 - Binary Search (Easy)",description:"Author: @wingkwong, @ColeB2, @radojicic23 | https://leetcode.com/problems/binary-search/",source:"@site/solutions/0700-0799/0704-binary-search-easy.md",sourceDirName:"0700-0799",slug:"/0700-0799/binary-search-easy",permalink:"/solutions/0700-0799/binary-search-easy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0700-0799/0704-binary-search-easy.md",tags:[],version:"current",sidebarPosition:704,frontMatter:{description:"Author: @wingkwong, @ColeB2, @radojicic23 | https://leetcode.com/problems/binary-search/"},sidebar:"tutorialSidebar",previous:{title:"0703 - Kth Largest Element in a Stream (Easy)",permalink:"/solutions/0700-0799/kth-largest-element-in-a-stream-easy"},next:{title:"0706 - Design HashMap (Medium)",permalink:"/solutions/0700-0799/design-hashmap-medium"}},s={},u=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Brute Force/Linear Search",id:"approach-1-brute-forcelinear-search",level:2},{value:"Approach 2: Binary Search",id:"approach-2-binary-search",level:2}],m=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",t)},p=m("Tabs"),c=m("TabItem"),d=m("SolutionAuthor"),h={toc:u},g="wrapper";function f(e){let{components:t,...n}=e;return(0,a.kt)(g,(0,r.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"0704---binary-search-easy"},"0704 - Binary Search (Easy)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/binary-search/"},"https://leetcode.com/problems/binary-search/")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"Given an array of integers ",(0,a.kt)("inlineCode",{parentName:"p"},"nums")," which is sorted in ascending order, and an integer ",(0,a.kt)("inlineCode",{parentName:"p"},"target"),", write a function to search ",(0,a.kt)("inlineCode",{parentName:"p"},"target")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"nums"),". If ",(0,a.kt)("inlineCode",{parentName:"p"},"target")," exists, then return its index. Otherwise, return ",(0,a.kt)("inlineCode",{parentName:"p"},"-1"),"."),(0,a.kt)("p",null,"You must write an algorithm with ",(0,a.kt)("inlineCode",{parentName:"p"},"O(log n)")," runtime complexity."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: 9 exists in nums and its index is 4\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1\nExplanation: 2 does not exist in nums so return -1\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= nums.length <= 10^4")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"-10^4 < nums[i], target < 10^4")),(0,a.kt)("li",{parentName:"ul"},"All the integers in ",(0,a.kt)("inlineCode",{parentName:"li"},"nums")," are ",(0,a.kt)("strong",{parentName:"li"},"unique"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"nums")," is sorted in ascending order.")),(0,a.kt)("h2",{id:"approach-1-brute-forcelinear-search"},"Approach 1: Brute Force/Linear Search"),(0,a.kt)("p",null,"The questions asks for an $$O(log n)$$ time answer. But what if we can't find that. We can always start with the brute force solution first to gain insight. Obviously we can imagine, that if we scan through the numbers, we can return it if we find it, and if we reach the end of the array without finding it, we can return -1. "),(0,a.kt)("p",null,"We also know the array is sorted, so if we ever pass the target before the end, we can return early. That is our insight right there. "),(0,a.kt)("p",null,"Time Complexity $$O(n)$$ to scan each number in the array."),(0,a.kt)("p",null,"Space Complexity $$O(1)$$ "),(0,a.kt)(p,{mdxType:"Tabs"},(0,a.kt)(c,{value:"python",label:"Python",mdxType:"TabItem"},(0,a.kt)(d,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        # scan all numbers, tracking index, i and number, num.\n        for i, num in enumerate(nums):\n            # if num == target, we found num, return index, i\n            if num == target:\n                return i\n            # num > target, we passed it, we can return -1 early\n            elif num > target:\n                return -1\n        # if we couldn't find it and couldn't return early, return -1.\n        return -1\n")))),(0,a.kt)("p",null,"Note we found our insight above that the array is sorted. Since the array is sorted, and we know if the number we are looking at is larger or smaller than our target, then can we eliminate the need to look at all the numbers? Can we look directly in the middle, and eliminate half of all numbers in one go? We can. That is our intuition for binary search below."),(0,a.kt)("h2",{id:"approach-2-binary-search"},"Approach 2: Binary Search"),(0,a.kt)("admonition",{title:"Prerequisite",type:"info"},(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"../../tutorials/basic-topics/binary-search"},"Binary Search")))),(0,a.kt)("p",null,"We set the boundary from the first index to the last index of the array. In each round, we try the middle one $$m = l + (r - l + 1) / 2$$. The reason we add $$1$$ here is that we need to take the upper one if there are even number of elements. If the target is less than $$nums","[m]","$$, then move the right pointer to $$m - 1$$, else move the left pointer to $$m$$. At the end, if the target is found, the index would be $$l$$."),(0,a.kt)(p,{mdxType:"Tabs"},(0,a.kt)(c,{value:"c++",label:"C++",mdxType:"TabItem"},(0,a.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        // init possible boundary\n        int n = nums.size(), l = 0, r = n - 1;\n        while (l < r) {\n            // get the middle one\n            // for even number of elements, take the upper one\n            int m = l + (r - l + 1) / 2;\n            // exclude m\n            if (target < nums[m]) r = m - 1;\n            // include m\n            else l = m;\n        }\n        return nums[l] == target ? l : -1;\n    }\n};\n"))),(0,a.kt)(c,{value:"python",label:"Python",mdxType:"TabItem"},(0,a.kt)(d,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        # initialize left, l and right, r boundaries\n        l, r = 0, len(nums)-1\n        # l passes r, we are done.\n        while l < r:\n            # get our middle number, right one if even number elements.\n            # note: do it this way to prevent int overflow, don't have\n            # issue in Pythonn, but it is good practice for languages that do.\n            m = l + (r-l+1) // 2\n            # target smaller than we are looking at.\n            if nums[m] > target:\n                # set boundary m-1 to keep scanning left half\n                r = m - 1\n            else:\n                # set boundary to m to keep scanning right half\n                l = m\n        # if we found the item, it will be @ index l, else -1.\n        return l if nums[l] == target else -1\n"))),(0,a.kt)(c,{value:"javascript",label:"JavaScript",mdxType:"TabItem"},(0,a.kt)(d,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    // initialize left and right boundary\n    let l = 0;\n    let r = nums.length - 1;\n    while (l <= r) {\n        // find mid value \n        let mid = Math.floor((l + r) / 2) \n        if (nums[mid] == target) return mid;\n        // if mid value is greater than target\n        // search left\n        else if (nums[mid] > target) r = mid - 1;\n        // if mid value is less than target\n        // search right\n        else l = mid + 1;\n    }\n    return -1;\n};\n")))),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"How about taking the lower element if the number of elements is even?")),(0,a.kt)("p",null,"Similarly, we set the boundary from the first index to the last index of the array. In each round, we try the middle one $$m = l + (r - l) / 2$$. If there are even number of elements, we take the lower one. If the target is greater than $$nums","[m]","$$, then move the left pointer to $$m + 1$$, else move the right pointer to $$m$$. At the end, if the target is found, the index would be $$l$$."),(0,a.kt)(p,{mdxType:"Tabs"},(0,a.kt)(c,{value:"c++",label:"C++",mdxType:"TabItem"},(0,a.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        // init possible boundary\n        int n = nums.size(), l = 0, r = n - 1;\n        while (l < r) {\n            // get the middle one\n            // for even number of elements, take the lower one\n            int m = l + (r - l) / 2;\n            // exclude m\n            if (target > nums[m]) l = m + 1;\n            // include m\n            else r = m;\n        }\n        return nums[l] == target ? l : -1;\n    }\n};\n"))),(0,a.kt)(c,{value:"python",label:"Python",mdxType:"TabItem"},(0,a.kt)(d,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        # initialize left, l and right, r boundaries\n        l, r = 0, len(nums)-1\n        # l passes r, we are done.\n        while l < r:\n            # get our middle number, left one if even number elements.\n            # note: do it this way to prevent int overflow, we don't have the\n            # issue in Python, but it is good practice for languages that do.\n            m = l + (r-l) // 2\n            # target larger than num we are looking at.\n            if nums[m] < target:\n                # set boundary m-1 to keep scanning right half\n                l = m + 1\n            else:\n                # set boundary to m to keep scanning left half\n                r = m\n        # if we found the item, it will be @ index l, else -1.\n        return l if nums[l] == target else -1\n"))),(0,a.kt)(c,{value:"javascript",label:"JavaScript",mdxType:"TabItem"},(0,a.kt)(d,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function(nums, target) {\n    // initialize left and right boundary\n    let l = 0;\n    let r = nums.length - 1;\n    while (l <= r) {\n        // find mid value \n        let mid = Math.floor((l + r) / 2) \n        if (nums[mid] == target) return mid;\n        // if mid value is less than target\n        // search right\n        else if (nums[mid] < target) l = mid + 1;\n        // if mid value is greater than target\n        // search left\n        else r = mid - 1;\n    }\n    return -1;\n};\n")))))}f.isMDXComponent=!0}}]);