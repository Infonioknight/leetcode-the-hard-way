"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[78537],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function u(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),l=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},p=function(e){var n=l(e.components);return r.createElement(s.Provider,{value:n},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=u(e,["components","mdxType","originalType","parentName"]),m=l(t),d=a,h=m["".concat(s,".").concat(d)]||m[d]||c[d]||o;return t?r.createElement(h,i(i({ref:n},p),{},{components:t})):r.createElement(h,i({ref:n},p))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=d;var u={};for(var s in n)hasOwnProperty.call(n,s)&&(u[s]=n[s]);u.originalType=e,u[m]="string"==typeof e?e:a,i[1]=u;for(var l=2;l<o;l++)i[l]=t[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},676:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>u,toc:()=>l});var r=t(87462),a=(t(67294),t(3905));const o={description:"Author: @wingkwong | https://leetcode.com/problems/contiguous-array/"},i="0525 - Contiguous Array (Medium)",u={unversionedId:"0500-0599/contiguous-array-medium",id:"0500-0599/contiguous-array-medium",title:"0525 - Contiguous Array (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/contiguous-array/",source:"@site/solutions/0500-0599/0525-contiguous-array-medium.md",sourceDirName:"0500-0599",slug:"/0500-0599/contiguous-array-medium",permalink:"/solutions/0500-0599/contiguous-array-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0500-0599/0525-contiguous-array-medium.md",tags:[],version:"current",sidebarPosition:525,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/contiguous-array/"},sidebar:"tutorialSidebar",previous:{title:"0523 - Continuous Subarray Sum (Medium)",permalink:"/solutions/0500-0599/continuous-subarray-sum-medium"},next:{title:"0532 - K-diff Pairs in an Array (Medium)",permalink:"/solutions/0500-0599/k-diff-pairs-in-an-array-medium"}},s={},l=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Prefix Sum + Hash Map",id:"approach-1-prefix-sum--hash-map",level:2}],p=(m="SolutionAuthor",function(e){return console.warn("Component "+m+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",e)});var m;const c={toc:l},d="wrapper";function h(e){let{components:n,...t}=e;return(0,a.kt)(d,(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"0525---contiguous-array-medium"},"0525 - Contiguous Array (Medium)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/contiguous-array/"},"https://leetcode.com/problems/contiguous-array/")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"Given a binary array ",(0,a.kt)("inlineCode",{parentName:"p"},"nums"),", return ",(0,a.kt)("em",{parentName:"p"},"the maximum length of a contiguous subarray with an equal number of")," ",(0,a.kt)("inlineCode",{parentName:"p"},"0")," ",(0,a.kt)("em",{parentName:"p"},"and")," ",(0,a.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: nums = [0,1]\nOutput: 2\nExplanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: nums = [0,1,0]\nOutput: 2\nExplanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= nums.length <= 10^5")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"nums[i]")," is either ",(0,a.kt)("inlineCode",{parentName:"li"},"0")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"1"),".")),(0,a.kt)("h2",{id:"approach-1-prefix-sum--hash-map"},"Approach 1: Prefix Sum + Hash Map"),(0,a.kt)("p",null,"Since the number only contain either 0 and 1, we can check the balance and calculate the length. Let $$pre$$ be the sum with initial value 0. If $$nums","[i]","$$ is 1, then $$sum := sum + 1$$. If $$nums","[i]","$$ is 0, then $$sum := sum - 1$$. We iterate $$nums$$ to calculate $$pre$$. If we get the same $$pre$$ at some point, then it means we have one possible answer."),(0,a.kt)("p",null,"For example, given the input $$","[0, 0, 0, 1, 1, 1]","$$, $$pre$$ would be 0 -> -1 -> -2 -> -3 -> -2 -> -1 -> 0. We can see that there are three contiguous subarrays with an equal number of 0 and 1, which are $$nums","[0..5]",", nums","[1..4]","$$ and $$nums","[2..3]","$$. The longest contiguous subarray with an equal number of 0 and 1 is $$nums","[0..5]","$$ which has the length of $$5 - 0 + 1 = 6$$."),(0,a.kt)("p",null,"Therefore, the approach is to calculate the prefix sum and put it into a hash map. If the prefix sum can be found, then the we can compare the length with the current maximum answer to see if we update it or not. This solution gives both $$O(n)$$time complexity and space complexity."),(0,a.kt)(p,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int findMaxLength(vector<int>& nums) {\n        int ans = 0, pre = 0, n = nums.size();\n        unordered_map<int, int> m;\n        for (int i = 0; i < n; i++) {\n            pre += 2 * nums[i] - 1;\n            if (pre == 0) ans = max(ans, i + 1);\n            if (m.count(pre)) ans = max(ans, i - m[pre]);\n            else m[pre] = i;            \n        }\n        return ans;\n    }\n};\n")),(0,a.kt)("p",null,"Or you can initialise $$m","[pre]"," = -1$$ for $$pre = 0$$."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int findMaxLength(vector<int>& nums) {\n        int ans = 0, pre = 0, n = nums.size();\n        unordered_map<int, int> m;\n        m[0] = -1;\n        for (int i = 0; i < n; i++) {\n            pre += 2 * nums[i] - 1;\n            if (m.count(pre)) ans = max(ans, i - m[pre]);\n            else m[pre] = i;            \n        }\n        return ans;\n    }\n};\n")))}h.isMDXComponent=!0}}]);