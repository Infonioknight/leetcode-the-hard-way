"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[99572],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>m});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var d=r.createContext({}),p=function(e){var t=r.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},s=function(e){var t=p(e.components);return r.createElement(d.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,d=e.parentName,s=i(e,["components","mdxType","originalType","parentName"]),u=p(n),c=o,m=u["".concat(d,".").concat(c)]||u[c]||h[c]||a;return n?r.createElement(m,l(l({ref:t},s),{},{components:n})):r.createElement(m,l({ref:t},s))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,l=new Array(a);l[0]=c;var i={};for(var d in t)hasOwnProperty.call(t,d)&&(i[d]=t[d]);i.originalType=e,i[u]="string"==typeof e?e:o,l[1]=i;for(var p=2;p<a;p++)l[p]=n[p];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},16384:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>k,frontMatter:()=>a,metadata:()=>i,toc:()=>p});var r=n(87462),o=(n(67294),n(3905));const a={description:"Author: @divyansh_0602| https://leetcode.com/problems/add-one-row-to-tree/",tags:["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},l="0623 - Add One Row to Tree (Medium)",i={unversionedId:"0600-0699/add-one-row-to-tree-medium",id:"0600-0699/add-one-row-to-tree-medium",title:"0623 - Add One Row to Tree (Medium)",description:"Author: @divyansh_0602| https://leetcode.com/problems/add-one-row-to-tree/",source:"@site/solutions/0600-0699/0623-add-one-row-to-tree-medium.md",sourceDirName:"0600-0699",slug:"/0600-0699/add-one-row-to-tree-medium",permalink:"/solutions/0600-0699/add-one-row-to-tree-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0600-0699/0623-add-one-row-to-tree-medium.md",tags:[{label:"Tree",permalink:"/solutions/tags/tree"},{label:"Depth-First Search",permalink:"/solutions/tags/depth-first-search"},{label:"Breadth-First Search",permalink:"/solutions/tags/breadth-first-search"},{label:"Binary Tree",permalink:"/solutions/tags/binary-tree"}],version:"current",sidebarPosition:623,frontMatter:{description:"Author: @divyansh_0602| https://leetcode.com/problems/add-one-row-to-tree/",tags:["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},sidebar:"tutorialSidebar",previous:{title:"0622 - Design Circular Queue (Medium)",permalink:"/solutions/0600-0699/design-circular-queue-medium"},next:{title:"0633 - Sum of Square Numbers (Medium)",permalink:"/solutions/0600-0699/sum-of-square-numbers-medium"}},d={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Recursion (DFS)",id:"approach-1-recursion-dfs",level:2}],s=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",t)},u=s("Tabs"),h=s("TabItem"),c=s("SolutionAuthor"),m={toc:p},f="wrapper";function k(e){let{components:t,...n}=e;return(0,o.kt)(f,(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"0623---add-one-row-to-tree-medium"},"0623 - Add One Row to Tree (Medium)"),(0,o.kt)("h2",{id:"problem-link"},"Problem Link"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/add-one-row-to-tree/"},"https://leetcode.com/problems/add-one-row-to-tree/")),(0,o.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,o.kt)("p",null,"Given the ",(0,o.kt)("inlineCode",{parentName:"p"},"root")," of a binary tree and two integers ",(0,o.kt)("inlineCode",{parentName:"p"},"val")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"depth"),", add a row of nodes with value ",(0,o.kt)("inlineCode",{parentName:"p"},"val")," at the given depth ",(0,o.kt)("inlineCode",{parentName:"p"},"depth"),"."),(0,o.kt)("p",null,"Note that the root ",(0,o.kt)("inlineCode",{parentName:"p"},"node")," is at depth ",(0,o.kt)("inlineCode",{parentName:"p"},"1"),"."),(0,o.kt)("p",null,"The adding rule is:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Given the integer ",(0,o.kt)("inlineCode",{parentName:"li"},"depth"),", for each not null tree node ",(0,o.kt)("inlineCode",{parentName:"li"},"cur")," at the depth ",(0,o.kt)("inlineCode",{parentName:"li"},"depth - 1"),", create two tree nodes with value ",(0,o.kt)("inlineCode",{parentName:"li"},"val")," as ",(0,o.kt)("inlineCode",{parentName:"li"},"cur"),"'s left subtree root and right subtree root."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"cur"),"'s original left subtree should be the left subtree of the new left subtree root."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"cur"),"'s original right subtree should be the right subtree of the new right subtree root."),(0,o.kt)("li",{parentName:"ul"},"If ",(0,o.kt)("inlineCode",{parentName:"li"},"depth == 1")," that means there is no depth ",(0,o.kt)("inlineCode",{parentName:"li"},"depth - 1")," at all, then create a tree node with value ",(0,o.kt)("inlineCode",{parentName:"li"},"val")," as the new root of the whole original tree, and the original tree is the new root's left subtree.")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 1:")),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2021/03/15/addrow-tree.jpg",alt:"Example 1",title:"Example 1"})),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: root = [4,2,6,3,1,5], val = 1, depth = 2\nOutput: [4,1,1,2,null,null,6,3,1,5]\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 2:")),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2021/03/11/add2-tree.jpg",alt:"Example 2",title:"Example 2"})),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: root = [4,2,null,3,1], val = 1, depth = 3\nOutput: [4,2,null,1,1,3,null,null,1]\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Constraints:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The number of nodes in the tree is in the range ",(0,o.kt)("inlineCode",{parentName:"li"},"[1, 10^4]"),"."),(0,o.kt)("li",{parentName:"ul"},"The depth of the tree is in the range ",(0,o.kt)("inlineCode",{parentName:"li"},"[1, 10^4]"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"-100 <= Node.val <= 100")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"-10^5 <= val <= 10^5")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"1 <= depth <= the depth of tree + 1"))),(0,o.kt)("h2",{id:"approach-1-recursion-dfs"},"Approach 1: Recursion (DFS)"),(0,o.kt)("p",null,"This approach uses a simple DFS approach. The recursive function $insert(node, currDepth, val, depth)$ can be used to recursively reach a node where we need to insert two nodes."),(0,o.kt)("p",null,"The parameters used in the function are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"$node$: the current node on which DFS is called upon"),(0,o.kt)("li",{parentName:"ul"},"$currDepth$: the depth of current node $node$"),(0,o.kt)("li",{parentName:"ul"},"$val$: value of nodes to be inserted"),(0,o.kt)("li",{parentName:"ul"},"$depth$: the depth at which nodes are to be inserted")),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Note: the parameters $val$ and $depth$ never change during program execution and hence can be made global")),(0,o.kt)("p",null,"Now, whenever we reach a node with depth $depth-1$ we create two new nodes $l$ and $r$ and link $l$'s and $r$'s left and right children to be $node$'s left and right children respectively, and then we re-assign $node$'s left and right children as $l$ and $r$ respectively. "),(0,o.kt)("p",null,"If $node$ is at a depth < $depth$ we recursively call $insert$ for $node$->$right$ and $node$->$left$ with increased depths."),(0,o.kt)("p",null,"One special case to be taken care of is when $depth$ is 1 because here the original root of tree is changed so we create a new node, assign this new node's left child as root and return this new node as root of tree."),(0,o.kt)("p",null,"Time Complexity: $O(n)$. A total of n nodes of the given tree will be considered in worst case."),(0,o.kt)("p",null,"Space Complexity: $O(n)$. The depth of the recursion tree can go upto n in the worst case (skewed tree)."),(0,o.kt)(u,{mdxType:"Tabs"},(0,o.kt)(h,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,o.kt)(c,{name:"@divyansh_0602",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void insert(TreeNode *node, int currDepth, int val, int depth) {\n        if (!node) return;\n\n        // if we reach the node where we need to create two nodes\n        if (currDepth == depth - 1) {\n            // create two new nodes\n            TreeNode *l = new TreeNode(val);\n            TreeNode *r = new TreeNode(val);\n\n            // link the new nodes\n            l->left = node->left;\n            r->right = node->right;\n\n            // change original links\n            node->left = l;\n            node->right = r;\n\n            // return since we do not need to further deep in the tree\n            return;\n        }\n\n        // if we do not reach desired depth, go deep in the tree\n        insert(node->left, currDepth + 1, val, depth);\n        insert(node->right, currDepth + 1, val, depth);\n    }\n\n    TreeNode *addOneRow(TreeNode *root, int val, int depth) {\n        // since root is changed in this case, handle this case seperately\n        if (depth == 1) {\n            TreeNode *newNode = new TreeNode(val);\n            newNode->left = root;\n            return newNode;\n        }\n        // recursive function for insertion of new nodes\n        insert(root, 1, val, depth);\n        return root;\n    }\n};\n")))))}k.isMDXComponent=!0}}]);