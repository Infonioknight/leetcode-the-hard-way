"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[91522],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),d=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=d(e.components);return r.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=d(n),m=o,h=p["".concat(l,".").concat(m)]||p[m]||u[m]||a;return n?r.createElement(h,i(i({ref:t},c),{},{components:n})):r.createElement(h,i({ref:t},c))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:o,i[1]=s;for(var d=2;d<a;d++)i[d]=n[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},39343:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>f,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var r=n(87462),o=(n(67294),n(3905));const a={description:"Author: @vigneshshiv | https://leetcode.com/problems/concatenated-words/"},i="0472 - Concatenated Words (Hard)",s={unversionedId:"0400-0499/concatenated-words-hard",id:"0400-0499/concatenated-words-hard",title:"0472 - Concatenated Words (Hard)",description:"Author: @vigneshshiv | https://leetcode.com/problems/concatenated-words/",source:"@site/solutions/0400-0499/0472-concatenated-words-hard.md",sourceDirName:"0400-0499",slug:"/0400-0499/concatenated-words-hard",permalink:"/solutions/0400-0499/concatenated-words-hard",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0400-0499/0472-concatenated-words-hard.md",tags:[],version:"current",sidebarPosition:472,frontMatter:{description:"Author: @vigneshshiv | https://leetcode.com/problems/concatenated-words/"},sidebar:"tutorialSidebar",previous:{title:"0465 - Optimal Account Balancing (Hard)",permalink:"/solutions/0400-0499/optimal-account-balancing-hard"},next:{title:"0473 - Matchsticks to Square (Medium)",permalink:"/solutions/0400-0499/matchsticks-to-square-medium"}},l={},d=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Trie Structure",id:"approach-1-trie-structure",level:2},{value:"Approach 2: HashSet with Iterative Solution",id:"approach-2-hashset-with-iterative-solution",level:2}],c=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",t)},p=c("Tabs"),u=c("TabItem"),m=c("SolutionAuthor"),h={toc:d},g="wrapper";function f(e){let{components:t,...n}=e;return(0,o.kt)(g,(0,r.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"0472---concatenated-words-hard"},"0472 - Concatenated Words (Hard)"),(0,o.kt)("h2",{id:"problem-link"},"Problem Link"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/concatenated-words/"},"https://leetcode.com/problems/concatenated-words/")),(0,o.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,o.kt)("p",null,"Given an array of strings ",(0,o.kt)("inlineCode",{parentName:"p"},"words")," (",(0,o.kt)("strong",{parentName:"p"},"without duplicates"),"), return ",(0,o.kt)("em",{parentName:"p"},"all the")," ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"concatenated words"))," ",(0,o.kt)("em",{parentName:"p"},"in the given list of")," ",(0,o.kt)("inlineCode",{parentName:"p"},"words"),"."),(0,o.kt)("p",null,"A ",(0,o.kt)("strong",{parentName:"p"},"concatenated word")," is defined as a string that is comprised entirely of at least two shorter words in the given array."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 1:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'Input: words = ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]\nOutput: ["catsdogcats","dogcatsdog","ratcatdogcat"]\nExplanation: "catsdogcats" can be concatenated by "cats", "dog" and "cats"; \n"dogcatsdog" can be concatenated by "dog", "cats" and "dog"; \n"ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 2:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'Input: words = ["cat","dog","catdog"]\nOutput: ["catdog"]\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Constraints:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"1 <= words.length <= 10^4")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"1 <= words[i].length <= 30")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"words[i]")," consists of only lowercase English letters."),(0,o.kt)("li",{parentName:"ul"},"All the strings of ",(0,o.kt)("inlineCode",{parentName:"li"},"words")," are ",(0,o.kt)("strong",{parentName:"li"},"unique"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"1 <= sum(words[i].length) <= 10^5"))),(0,o.kt)("h2",{id:"approach-1-trie-structure"},"Approach 1: Trie Structure"),(0,o.kt)("p",null,"Construct a list of string as a tree (similar to trie) and check whether larger string consist of atleast two or more than two strings. "),(0,o.kt)("p",null,"So lets break down problem statement, a concatenated words is combined with $2$ or more than $2$ words from the list to forms a large string. Let's take above example $2$, ",(0,o.kt)("em",{parentName:"p"},"catdog")," is concatenated strings of ",(0,o.kt)("em",{parentName:"p"},"cat")," and ",(0,o.kt)("em",{parentName:"p"},"dog")," from the list. "),(0,o.kt)("p",null,"Simpler appraoch to solve this, by taking larger string, check index by index with other strings in the list to ",(0,o.kt)("em",{parentName:"p"},"match prefix of larger string to forms a complete word"),". If larger string has a remaining substring, iterate through the same process to find the next half of the string in the list. "),(0,o.kt)("p",null,"Here, the second string may be a another string in the list (",(0,o.kt)("em",{parentName:"p"},"dog"),") or it may be on the same string then the larger consist of $3$ strings. "),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"First, builds a trie structure, to forms string tree structure."),(0,o.kt)("li",{parentName:"ul"},"Iterate through the list of words and check the prefix and suffix forms a complete word either two or more than two strings (as mentioned above). ")),(0,o.kt)("p",null,"Time Complexity: $O(n * s^3)$, where $n$ - # of words, $s$ - the highest length of the word"),(0,o.kt)("p",null,"Space Complexity: $O(n)$"),(0,o.kt)(p,{mdxType:"Tabs"},(0,o.kt)(u,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)(m,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    \n    class TrieNode {\n        private char character;\n        private TrieNode[] nodes = new TrieNode[26];\n        private boolean completeWord;\n\n        public TrieNode(char character) {\n            this.character = character;\n        }\n\n        public void setWordCompletion(boolean complete) {\n            this.completeWord = complete;\n        }\n\n        public boolean isCompleteWord() {\n            return completeWord;\n        }\n    }\n    \n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\n        List<String> result = new ArrayList<>();\n        TrieNode root = buildsTrie(words);\n        for (String word : words) {\n            if (canForm(root, word, 0, word.length() - 1)) {\n                result.add(word);\n            }\n        }\n        return result;\n    }\n    \n    public TrieNode buildsTrie(String[] words) {\n        // Forms as Root\n        TrieNode root = new TrieNode('\\0');\n        for (String word : words) {\n            TrieNode current = root;\n            for (char c : word.toCharArray()) {\n                int idx = c - 'a';\n                if (current.nodes[idx] == null) {\n                    current.nodes[idx] = new TrieNode(c);\n                }\n                current = current.nodes[idx];\n            }\n            if (current != null) {\n                current.setWordCompletion(true);\n            }\n        }\n        return root;\n    }\n    \n    public boolean canForm(TrieNode root, String word, int start, int end) {\n        TrieNode current = root;\n        for (int i = start; i <= end; i++) {\n            char c = word.charAt(i);\n            current = current.nodes[c - 'a'];\n            if (current == null) return false;\n            // Prefix word\n            if (current.isCompleteWord()) {\n                if (hasWord(root, word, i + 1, end) || canForm(root, word, i + 1, end)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public boolean hasWord(TrieNode root, String word, int start, int end) {\n        TrieNode current = root;\n        for (int i = start; i <= end; i++) {\n            char c = word.charAt(i);\n            current = current.nodes[c - 'a'];\n            if (current == null) return false;\n        }\n        return current.isCompleteWord();\n    }\n}\n")))),(0,o.kt)("h2",{id:"approach-2-hashset-with-iterative-solution"},"Approach 2: HashSet with Iterative Solution"),(0,o.kt)("p",null,"Construct a list of string as a collection store in Set, and check whether larger string consist of atleast two or more than two strings. "),(0,o.kt)("p",null,"HashSet preferred instead of list, it avoids duplicate string in the collection of objects when we iterate through the list and store suffix string as a memoization for faster lookup. Consider the below example why suffix stored as a memoized value in the list, "),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},'["cat","cats","rat","ratcatsdog","dog","dogcatsdog"]')),(0,o.kt)("p",null,"When iterating on ",(0,o.kt)("inlineCode",{parentName:"p"},"ratcatsdog")," string, as soon as the ",(0,o.kt)("inlineCode",{parentName:"p"},"rat")," get matched, the suffix ",(0,o.kt)("inlineCode",{parentName:"p"},"catsdog")," string is look for matching string. Since it can be formed by ",(0,o.kt)("inlineCode",{parentName:"p"},"cats")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"dog")," and string, this suffix ",(0,o.kt)("inlineCode",{parentName:"p"},"catsdog")," will be added to the HashSet. So when, ",(0,o.kt)("inlineCode",{parentName:"p"},"dogcatsdog")," iteration, the prefix ",(0,o.kt)("inlineCode",{parentName:"p"},"dog")," is found the list, so the suffix ",(0,o.kt)("inlineCode",{parentName:"p"},"catsdog")," is also available in the list, since we added as memoized record for future conditions to run as optimal solution."),(0,o.kt)("p",null,"Solve this by,"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"First, builds a HashSet store with all the words"),(0,o.kt)("li",{parentName:"ul"},"Iterate through the list of words and check the prefix and suffix forms a complete word either two or more than two strings. ")),(0,o.kt)("p",null,"Time Complexity: $O(n * s^3)$, where $n$ - # of words, $s$ - the highest length of the word"),(0,o.kt)("p",null,"Space Complexity: $O(n^2)$"),(0,o.kt)(p,{mdxType:"Tabs"},(0,o.kt)(u,{value:"java",label:"Java",mdxType:"TabItem"},(0,o.kt)(m,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\n        List<String> result = new ArrayList<>();\n        Set<String> store = new HashSet<>(Arrays.asList(words));\n        for (String word : words) {\n            if (hasWord(word, store)) result.add(word);\n        }\n        return result;\n    }\n    \n    public boolean hasWord(String word, Set<String> store) {\n        for (int i = 1; i < word.length(); i++) {\n            if (store.contains(word.substring(0, i))) {\n                String suffix = word.substring(i);\n                if (store.contains(suffix) || hasWord(suffix, store)) {\n                    // memoization - concatenated word for look up at later stage\n                    store.add(suffix);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n")))))}f.isMDXComponent=!0}}]);