"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[33785],{3905:function(e,n,t){t.d(n,{Zo:function(){return m},kt:function(){return c}});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),d=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},m=function(e){var n=d(e.components);return r.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),u=d(t),c=a,g=u["".concat(l,".").concat(c)]||u[c]||p[c]||i;return t?r.createElement(g,o(o({ref:n},m),{},{components:t})):r.createElement(g,o({ref:n},m))}));function c(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var d=2;d<i;d++)o[d]=t[d];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},86883:function(e,n,t){t.r(n),t.d(n,{assets:function(){return m},contentTitle:function(){return l},default:function(){return b},frontMatter:function(){return s},metadata:function(){return d},toc:function(){return p}});var r=t(87462),a=t(63366),i=(t(67294),t(3905)),o=["components"],s={description:"Author: @wingkwong | https://leetcode.com/problems/my-calendar-iii/",tags:["Binary Search","Design","Segment Tree","Ordered Set"]},l="0732 - My Calendar III (Hard)",d={unversionedId:"0700-0799/my-calendar-iii-hard",id:"0700-0799/my-calendar-iii-hard",title:"0732 - My Calendar III (Hard)",description:"Author: @wingkwong | https://leetcode.com/problems/my-calendar-iii/",source:"@site/solutions/0700-0799/0732-my-calendar-iii-hard.md",sourceDirName:"0700-0799",slug:"/0700-0799/my-calendar-iii-hard",permalink:"/solutions/0700-0799/my-calendar-iii-hard",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0700-0799/0732-my-calendar-iii-hard.md",tags:[{label:"Binary Search",permalink:"/solutions/tags/binary-search"},{label:"Design",permalink:"/solutions/tags/design"},{label:"Segment Tree",permalink:"/solutions/tags/segment-tree"},{label:"Ordered Set",permalink:"/solutions/tags/ordered-set"}],version:"current",sidebarPosition:732,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/my-calendar-iii/",tags:["Binary Search","Design","Segment Tree","Ordered Set"]},sidebar:"tutorialSidebar",previous:{title:"0724 - Find Pivot Index (Easy)",permalink:"/solutions/0700-0799/find-pivot-index-easy"},next:{title:"0733 - Flood Fill (Easy)",permalink:"/solutions/0700-0799/flood-fill-easy"}},m={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Line Sweeping",id:"approach-1-line-sweeping",level:2},{value:"Approach 2: Segment Tree",id:"approach-2-segment-tree",level:2}],u=function(e){return function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",n)}},c=u("Tabs"),g=u("TabItem"),h=u("SolutionAuthor"),y={toc:p};function b(e){var n=e.components,t=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},y,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"0732---my-calendar-iii-hard"},"0732 - My Calendar III (Hard)"),(0,i.kt)("h2",{id:"problem-link"},"Problem Link"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/my-calendar-iii/"},"https://leetcode.com/problems/my-calendar-iii/")),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"k"),"-booking happens when ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," events have some non-empty intersection (i.e., there is some time that is common to all ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," events.)"),(0,i.kt)("p",null,"You are given some events ",(0,i.kt)("inlineCode",{parentName:"p"},"[start, end)"),", after each given event, return an integer ",(0,i.kt)("inlineCode",{parentName:"p"},"k")," representing the maximum ",(0,i.kt)("inlineCode",{parentName:"p"},"k"),"-booking between all the previous events."),(0,i.kt)("p",null,"Implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"MyCalendarThree")," class:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"MyCalendarThree()")," Initializes the object."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"int book(int start, int end)")," Returns an integer ",(0,i.kt)("inlineCode",{parentName:"li"},"k")," representing the largest integer such that there exists a ",(0,i.kt)("inlineCode",{parentName:"li"},"k"),"-booking in the calendar.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input\n["MyCalendarThree", "book", "book", "book", "book", "book", "book"]\n[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]\nOutput\n[null, 1, 1, 2, 3, 3, 3]\n\nExplanation\nMyCalendarThree myCalendarThree = new MyCalendarThree();\nmyCalendarThree.book(10, 20); // return 1, The first event can be booked and is disjoint, so the maximum k-booking is a 1-booking.\nmyCalendarThree.book(50, 60); // return 1, The second event can be booked and is disjoint, so the maximum k-booking is a 1-booking.\nmyCalendarThree.book(10, 40); // return 2, The third event [10, 40) intersects the first event, and the maximum k-booking is a 2-booking.\nmyCalendarThree.book(5, 15); // return 3, The remaining events cause the maximum K-booking to be only a 3-booking.\nmyCalendarThree.book(5, 10); // return 3\nmyCalendarThree.book(25, 55); // return 3\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0 <= start < end <= 109")),(0,i.kt)("li",{parentName:"ul"},"At most ",(0,i.kt)("inlineCode",{parentName:"li"},"400")," calls will be made to ",(0,i.kt)("inlineCode",{parentName:"li"},"book"),".")),(0,i.kt)("h2",{id:"approach-1-line-sweeping"},"Approach 1: Line Sweeping"),(0,i.kt)(c,{mdxType:"Tabs"},(0,i.kt)(g,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)(h,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Time Complexity: O(N ^ 2)\n// Space Complexity: O(N)\nclass MyCalendarThree {\npublic:\n    // finding number of overlapping elements at time points -> line sweeping\n    MyCalendarThree() {}\n    \n    int book(int start, int end) {\n        // new event starts here -> increase by 1\n        lines[start]++;\n        // the event ends here -> decrease by 1\n        // p.s. sometimes you may see `lines[end + 1]--;`. e.g. 2406. Divide Intervals Into Minimum Number of Groups\n        //      you may search `leetcode-the-hard-way` on Discussion to see my solution explanation on that problem\n        //      this is because the interval is inclusive, i.e [start, end] \n        //      however, the interval in this problem is [start, end), so we don't need to add 1 here.\n        lines[end]--;\n        int mx = 0, cnt = 0;\n        for (auto x : lines) {\n            // here we calculate the prefix sum\n            cnt += x.second;\n            // and record the maximum overlapping intervals\n            mx = max(mx, cnt);\n        }\n        return mx;\n    }\nprivate:\n    // can I use `vector` instead? \n    // given that the constraints state 0 <= start < end <= 10 ^ 9 \n    // it means we need to sweep from 0 to 10 ^ 9 if we use vector\n    // let's say the books are [10, 20) and [1e9 - 10, 1e9)\n    // then the range [20, 1e9 - 10 - 1] is empty but we still spend time to check them\n    \n    // in c++, we can use map instead since we only have at most 400 calls\n    // in line sweeping, we need to ensure the keys are sorted\n    // map is implemented as red-black trees so the it fulfils\n    // lines[i] = j means we have j overlapping elements at time point i\n    map<int, int> lines;\n};\n\n/**\n * Your MyCalendarThree object will be instantiated and called as such:\n * MyCalendarThree* obj = new MyCalendarThree();\n * int param_1 = obj->book(start,end);\n */\n"))),(0,i.kt)(g,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)(h,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// Time Complexity: O(N ^ 2)\n// Space Complexity: O(N)\nclass MyCalendarThree {\n    // can I use `ArrayList` instead? \n    // given that the constraints state 0 <= start < end <= 10 ^ 9 \n    // it means we need to sweep from 0 to 10 ^ 9 if we use ArrayList\n    // let's say the books are [10, 20) and [1e9 - 10, 1e9)\n    // then the range [20, 1e9 - 10 - 1] is empty but we still spend time to check them\n    \n    // in java, we can use TreeMap instead since we only have at most 400 calls\n    // in line sweeping, we need to ensure the keys are sorted\n    // TreeMap is implemented as red-black trees so the it fulfils\n    // lines[i] = j means we have j overlapping elements at time point i\n    private TreeMap<Integer, Integer> lines;\n\n    // finding number of overlapping elements at time points -> line sweeping\n    \n    public MyCalendarThree() {\n        // init TreeMap\n        lines = new TreeMap<>();\n    }\n    \n    public int book(int start, int end) {\n        // new event starts here -> increase by 1\n        lines.put(start, lines.getOrDefault(start, 0) + 1);\n        // the event ends here -> decrease by 1\n        // p.s. sometimes you may see `lines[end + 1]--;`. e.g. 2406. Divide Intervals Into Minimum Number of Groups\n        //      you may search `leetcode-the-hard-way` on Discussion to see my solution explanation on that problem\n        //      this is because the interval is inclusive, i.e [start, end] \n        //      however, the interval in this problem is [start, end), so we don't need to add 1 here.\n        lines.put(end, lines.getOrDefault(end, 0) - 1);\n        int mx = 0, cnt = 0;\n        for (int x : lines.values()) {\n            // here we calculate the prefix sum\n            cnt += x;\n            // and record the maximum overlapping intervals\n            mx = Math.max(mx, cnt);\n        }\n        return mx;\n    }\n    \n}\n\n/**\n * Your MyCalendarThree object will be instantiated and called as such:\n * MyCalendarThree obj = new MyCalendarThree();\n * int param_1 = obj.book(start,end);\n */\n"))),(0,i.kt)(g,{value:"py",label:"Python",mdxType:"TabItem"},(0,i.kt)(h,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"from sortedcontainers import SortedDict\n\n# Time Complexity: O(N ^ 2)\n# Space Complexity: O(N)\nclass MyCalendarThree:\n\n    def __init__(self):\n        # in line sweeping, we need to ensure the keys are sorted\n        # in python, we can use SortedDict which fulfils the above requirement\n        # lines[i] = j means we have j overlapping elements at time point i\n        self.lines = SortedDict()\n\n\n    # finding number of overlapping elements at time points -> line sweeping\n    def book(self, start: int, end: int) -> int:\n        # new event starts here -> increase by 1\n        self.lines[start] = self.lines.get(start, 0) + 1\n        # the event ends here -> decrease by 1\n        # p.s. sometimes you may see `lines.get(end + 1, 0) - 1;`. e.g. 2406. Divide Intervals Into Minimum Number of Groups\n        #      you may search `leetcode-the-hard-way` on Discussion to see my solution explanation on that problem\n        #      this is because the interval is inclusive, i.e [start, end] \n        #      however, the interval in this problem is [start, end), so we don't need to add 1 here.\n        self.lines[end] = self.lines.get(end, 0) - 1\n        # here we calculate the prefix sum using `accumulate`\n        # and get the maximum overlapping intervals using `max`\n        return max(accumulate(self.lines.values()))\n\n\n# Your MyCalendarThree object will be instantiated and called as such:\n# obj = MyCalendarThree()\n# param_1 = obj.book(start,end)\n")))),(0,i.kt)("h2",{id:"approach-2-segment-tree"},"Approach 2: Segment Tree"),(0,i.kt)(c,{mdxType:"Tabs"},(0,i.kt)(g,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)(h,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class MyCalendarThree {\npublic:\n    // modified from https://usaco.guide/plat/sparse-segtree?lang=cpp\n    struct Node {\n        int sum, lazy, tl, tr, l, r;\n        Node() : sum(0), lazy(0), l(-1), r(-1) {}\n    };\n    \n    const static int magic = 64 * 200 * 10;\n\n    Node segtree[magic];\n    int cnt = 2;\n\n    void push_lazy(int node) {\n        if (segtree[node].lazy) {\n            segtree[node].sum += segtree[node].lazy;\n            int mid = (segtree[node].tl + segtree[node].tr) / 2;\n            if (segtree[node].l == -1) {\n                segtree[node].l = cnt++;\n                segtree[segtree[node].l].tl = segtree[node].tl;\n                segtree[segtree[node].l].tr = mid;\n            }\n            if (segtree[node].r == -1) {\n                segtree[node].r = cnt++;\n                segtree[segtree[node].r].tl = mid + 1;\n                segtree[segtree[node].r].tr = segtree[node].tr;\n            }\n            segtree[segtree[node].l].lazy += segtree[node].lazy;\n            segtree[segtree[node].r].lazy += segtree[node].lazy;\n            segtree[node].lazy = 0;\n        }\n    }\n\n    void update(int node, int l, int r) {\n        push_lazy(node);\n        if (l == segtree[node].tl && r == segtree[node].tr) {\n            segtree[node].lazy += 1;\n            push_lazy(node);\n        } else {\n            int mid = (segtree[node].tl + segtree[node].tr) / 2;\n            if (segtree[node].l == -1) {\n                segtree[node].l = cnt++;\n                segtree[segtree[node].l].tl = segtree[node].tl;\n                segtree[segtree[node].l].tr = mid;\n            }\n            if (segtree[node].r == -1) {\n                segtree[node].r = cnt++;\n                segtree[segtree[node].r].tl = mid + 1;\n                segtree[segtree[node].r].tr = segtree[node].tr;\n            }\n\n            if (l > mid) update(segtree[node].r, l, r);\n            else if (r <= mid) update(segtree[node].l, l, r);\n            else {\n                update(segtree[node].l, l, mid);\n                update(segtree[node].r, mid + 1, r);\n            }\n            push_lazy(segtree[node].l);\n            push_lazy(segtree[node].r);\n            segtree[node].sum = max(segtree[segtree[node].l].sum, segtree[segtree[node].r].sum);\n        }\n    }\n\n    int query(int node, int l, int r) {\n        push_lazy(node);\n        if (l == segtree[node].tl && r == segtree[node].tr) return segtree[node].sum;\n        else {\n            int mid = (segtree[node].tl + segtree[node].tr) / 2;\n            if (segtree[node].l == -1) {\n                segtree[node].l = cnt++;\n                segtree[segtree[node].l].tl = segtree[node].tl;\n                segtree[segtree[node].l].tr = mid;\n            }\n            if (segtree[node].r == -1) {\n                segtree[node].r = cnt++;\n                segtree[segtree[node].r].tl = mid + 1;\n                segtree[segtree[node].r].tr = segtree[node].tr;\n            }\n            if (l > mid) return query(segtree[node].r, l, r);\n            else if (r <= mid) return query(segtree[node].l, l, r);\n            else return max(query(segtree[node].l, l, mid), query(segtree[node].r, mid + 1, r));\n        }\n    }\n\n\n    MyCalendarThree() {\n        segtree[1].sum = 0; segtree[1].lazy = 0;\n        segtree[1].tl = 0; segtree[1].tr = 1e9;\n    }\n    \n    int book(int start, int end) {\n        update(1, start, end - 1);\n        return segtree[1].sum;\n    }\n};\n\n/**\n * Your MyCalendarThree object will be instantiated and called as such:\n * MyCalendarThree* obj = new MyCalendarThree();\n * int param_1 = obj->book(start,end);\n */\n")))))}b.isMDXComponent=!0}}]);