"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[97973],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var i=a.createContext({}),p=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(i.Provider,{value:t},e.children)},m="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=p(n),c=o,u=m["".concat(i,".").concat(c)]||m[c]||h[c]||r;return n?a.createElement(u,l(l({ref:t},d),{},{components:n})):a.createElement(u,l({ref:t},d))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,l=new Array(r);l[0]=c;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s[m]="string"==typeof e?e:o,l[1]=s;for(var p=2;p<r;p++)l[p]=n[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},75863:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>w,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(87462),o=(n(67294),n(3905));const r={description:"Author: @ColeB2 | https://leetcode.com/problems/reorder-list/",tags:["Linked List","Two Pointers","Stack","Recursion"]},l="0143 - Reorder List (Medium)",s={unversionedId:"0100-0199/reorder-list-medium",id:"0100-0199/reorder-list-medium",title:"0143 - Reorder List (Medium)",description:"Author: @ColeB2 | https://leetcode.com/problems/reorder-list/",source:"@site/solutions/0100-0199/0143-reorder-list-medium.md",sourceDirName:"0100-0199",slug:"/0100-0199/reorder-list-medium",permalink:"/solutions/0100-0199/reorder-list-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0100-0199/0143-reorder-list-medium.md",tags:[{label:"Linked List",permalink:"/solutions/tags/linked-list"},{label:"Two Pointers",permalink:"/solutions/tags/two-pointers"},{label:"Stack",permalink:"/solutions/tags/stack"},{label:"Recursion",permalink:"/solutions/tags/recursion"}],version:"current",sidebarPosition:143,frontMatter:{description:"Author: @ColeB2 | https://leetcode.com/problems/reorder-list/",tags:["Linked List","Two Pointers","Stack","Recursion"]},sidebar:"tutorialSidebar",previous:{title:"0141 - Linked List Cycle (Easy)",permalink:"/solutions/0100-0199/linked-list-cycle"},next:{title:"0144 - Binary Tree Preorder Traversal (Easy)",permalink:"/solutions/0100-0199/binary-tree-preorder-traversal-easy"}},i={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Iterative using 2 pointers.",id:"approach-1-iterative-using-2-pointers",level:2}],d=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",t)},m=d("Tabs"),h=d("TabItem"),c=d("SolutionAuthor"),u={toc:p},k="wrapper";function w(e){let{components:t,...n}=e;return(0,o.kt)(k,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"0143---reorder-list-medium"},"0143 - Reorder List (Medium)"),(0,o.kt)("h2",{id:"problem-link"},"Problem Link"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/reorder-list/"},"https://leetcode.com/problems/reorder-list/")),(0,o.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,o.kt)("p",null,"You are given the head of a singly linked-list. The list can be represented as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"L0 \u2192 L1 \u2192 \u2026 \u2192 Ln - 1 \u2192 Ln\n")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Reorder the list to be on the following form:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"L0 \u2192 Ln \u2192 L1 \u2192 Ln - 1 \u2192 L2 \u2192 Ln - 2 \u2192 \u2026\n")),(0,o.kt)("p",null,"You may not modify the values in the list's nodes. Only nodes themselves may be changed."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 1:")),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2021/03/04/reorder1linked-list.jpg",alt:null})),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: head = [1,2,3,4]\nOutput: [1,4,2,3]\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 2:")),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2021/03/09/reorder2-linked-list.jpg",alt:null})),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: head = [1,2,3,4,5]\nOutput: [1,5,2,4,3]\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Constraints:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The number of nodes in the list is in the range ",(0,o.kt)("inlineCode",{parentName:"li"},"[1, 5 * 10^4]"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"1 <= Node.val <= 1000"))),(0,o.kt)("h2",{id:"approach-1-iterative-using-2-pointers"},"Approach 1: Iterative using 2 pointers."),(0,o.kt)("p",null,"We can break this problem down into 3 distinct parts. "),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Find the middle."),(0,o.kt)("li",{parentName:"ol"},"Reverse the second half."),(0,o.kt)("li",{parentName:"ol"},"Merge the Two linked lists.")),(0,o.kt)("p",null,"All of these can be done with very careful pointer manipulation to track the proper nodes at the proper time to manipulate each node correctly."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Finding the middle.")),(0,o.kt)("p",null,"We can find the middle, using a 2 pointer approach, 1 a slow pointer that moves 1 node at a time, and a 2nd fast pointer that moves 2 nodes at a time, stopping only in the case when either our fast pointer reaches null, or fast's next pointer is null. By starting the slow pointer at the first node, and the fast pointer at the second node, we will always end off in the case of the slow node being left at the end of the first half, ready to move on to the second half. In the case of an odd number of nodes, the first half will be larger too, which allows for an easy merge."),(0,o.kt)("p",null,"Example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"0 -> 1 -> 2 -> 3 -> 4-> null\ns    f\n     s         f\n          s             f\n")),(0,o.kt)("p",null,"Here we can see that when it ends, by moving our slow pointer to the second half, we have a split of 0->1->2->null and 3->4->null. We can also imagine in the case of a 4 node linked list, the split would be even: 0->1->null and 2->3->null."),(0,o.kt)("ol",{start:2},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("a",{parentName:"li",href:"https://wingkwong.github.io/leetcode-the-hard-way/solutions/0200-0299/reverse-linked-list-easy"},"Reversing")," the second half.")),(0,o.kt)("p",null,"Before we reverse, we will need to sever the links between both halves to make sure we have two separate linked lists."),(0,o.kt)("p",null,"Then, to reverse a linked list, we will need 2 pointers again, one to point to the previous node in the list, so we know where to point our current node, and another to track the head of the linked list as we go along. We maintain a temporary node inside our loop, to make sure we don't lose track of the next node as we are moving our current node's pointer to the node behind it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"0->1->2->null\n0<-1  2->null\n")),(0,o.kt)("p",null,"Above we can see, if we don't track our next node from the current, we can easily lose our linked list."),(0,o.kt)("ol",{start:3},(0,o.kt)("li",{parentName:"ol"},"Merging")),(0,o.kt)("p",null,"Finally, we can merge our linked lists, again with 2 pointers, 1 at the head of each linked list. We need temporary pointers to track the next values of each linked list again so we don't lost them. Then we point our first list to our second, and our second to the first's next and making sure we update the heads of our first and second to their appropriate next node. Then, considering how we split our lists, we only need to do this while our second linked list has nodes, since our first will always be the same size or larger, and the second will always point to the first's next node. Again we are aiming for:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"L0 \u2192 L1 \u2192 \u2026 \u2192 Ln - 1 \u2192 Ln\nL0 \u2192 Ln \u2192 L1 \u2192 Ln - 1 \u2192 L2 \u2192 Ln - 2 \u2192 \u2026\n")),(0,o.kt)("p",null,"Time Complexity: ",(0,o.kt)("span",{parentName:"p",className:"math math-inline"},(0,o.kt)("span",{parentName:"span",className:"katex"},(0,o.kt)("span",{parentName:"span",className:"katex-mathml"},(0,o.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,o.kt)("semantics",{parentName:"math"},(0,o.kt)("mrow",{parentName:"semantics"},(0,o.kt)("mi",{parentName:"mrow"},"O"),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,o.kt)("mi",{parentName:"mrow"},"n"),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,o.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n)")))),(0,o.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,o.kt)("span",{parentName:"span",className:"mopen"},"("),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,o.kt)("span",{parentName:"span",className:"mclose"},")"))))),". We will be looking at each node twice, Once to traverse, split and reverse, and a second time to merge into a single list."),(0,o.kt)("p",null,"Space Complexity: ",(0,o.kt)("span",{parentName:"p",className:"math math-inline"},(0,o.kt)("span",{parentName:"span",className:"katex"},(0,o.kt)("span",{parentName:"span",className:"katex-mathml"},(0,o.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,o.kt)("semantics",{parentName:"math"},(0,o.kt)("mrow",{parentName:"semantics"},(0,o.kt)("mi",{parentName:"mrow"},"O"),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,o.kt)("mn",{parentName:"mrow"},"1"),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,o.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(1)")))),(0,o.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,o.kt)("span",{parentName:"span",className:"mopen"},"("),(0,o.kt)("span",{parentName:"span",className:"mord"},"1"),(0,o.kt)("span",{parentName:"span",className:"mclose"},")"))))),". We are using constant extra space to track nodes while we manipulate their next pointers."),(0,o.kt)(m,{mdxType:"Tabs"},(0,o.kt)(h,{value:"python",label:"Python",mdxType:"TabItem"},(0,o.kt)(c,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-py"},'# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        """\n        Do not return anything, modify head in-place instead.\n        """\n        # Return early in the case of single node linked lists.\n        if not head.next:\n            return head\n        # Finding the middle.\n        # we will do that with a slow and fast pointer approach.\n        # We start at nodes 1 and 2 for an easy splitting and merging process.\n        slow, fast = head, head.next\n        # We must have a fast node, and a fast.next node for this to work. Once we reach\n        # the end, ie the fast pointer points to null, or the last node, we can stop.\n        while fast and fast.next:\n            # move slow pointer once\n            slow = slow.next\n            # move fast pointer twice.\n            fast = fast.next.next\n        \n        # Reverseing the second half\n        # To reverse we need two nodes, a prev for the current node to point to.\n        prev = None\n        # A head node of the list we want to reverse, note: slow will always\n        # be at the end of the first half of the linked list, so we start on \n        # slow\'s next node, for the second half.\n        node = slow.next\n        # break the linked lists in two halves before we start.\n        slow.next = None\n        # while node points to a valid node, ie we have not reached the end.\n        while node:\n            # track our temporary node.next so we don\'t lose it.\n            # Note: next is a key word in python, so we avoid overwriting it here.\n            nxt = node.next\n            # point the current node to the node behind us.\n            node.next = prev\n            # set the previous node to the current node.\n            prev = node\n            # move our node pointer to the next node in the list.\n            node = nxt\n\n        # Merging\n        # Finally to merge, we again need two pointers, one at the head of each\n        # linked list. Since l1 is always larger or equal to in size of l2, we can\n        # run our loop only while l2 points to a valid node.\n        l1, l2 = head, prev\n        while l2:\n            # make sure to create temporary nodes tracking the next node in each list.\n            l1_next, l2_next = l1.next, l2.next\n            # point our first linked list to the second one. That is 0->n\n            l1.next = l2\n            # Point our second linked list node to l1\'s next node. n->1\n            l2.next = l1_next\n            # Set both l1 and l2 to the proper next nodes in the linked list.\n            # that is 1 and n-1.\n            l1, l2 = l1_next, l2_next\n        # We haven\'t touched our head, so we can return our head.\n        return head\n')))))}w.isMDXComponent=!0}}]);