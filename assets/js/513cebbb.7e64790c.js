"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[50321],{3905:function(e,t,r){r.d(t,{Zo:function(){return m},kt:function(){return d}});var n=r(67294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function u(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?u(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):u(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},u=Object.keys(e);for(n=0;n<u.length;n++)r=u[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var u=Object.getOwnPropertySymbols(e);for(n=0;n<u.length;n++)r=u[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var s=n.createContext({}),l=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},m=function(e){var t=l(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,u=e.originalType,s=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),c=l(r),d=o,f=c["".concat(s,".").concat(d)]||c[d]||p[d]||u;return r?n.createElement(f,a(a({ref:t},m),{},{components:r})):n.createElement(f,a({ref:t},m))}));function d(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var u=r.length,a=new Array(u);a[0]=c;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:o,a[1]=i;for(var l=2;l<u;l++)a[l]=r[l];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}c.displayName="MDXCreateElement"},587:function(e,t,r){r.r(t),r.d(t,{assets:function(){return m},contentTitle:function(){return s},default:function(){return g},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return p}});var n=r(87462),o=r(63366),u=(r(67294),r(3905)),a=["components"],i={description:"Author: @wingkwong | https://leetcode.com/problems/most-frequent-subtree-sum/",tags:["Hash Table","Tree","Depth-First Search","Binary Tree"]},s="0508 - Most Frequent Subtree Sum (Medium)",l={unversionedId:"0500-0599/most-frequent-subtree-sum-medium",id:"0500-0599/most-frequent-subtree-sum-medium",title:"0508 - Most Frequent Subtree Sum (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/most-frequent-subtree-sum/",source:"@site/solutions/0500-0599/0508-most-frequent-subtree-sum-medium.md",sourceDirName:"0500-0599",slug:"/0500-0599/most-frequent-subtree-sum-medium",permalink:"/solutions/0500-0599/most-frequent-subtree-sum-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0500-0599/0508-most-frequent-subtree-sum-medium.md",tags:[{label:"Hash Table",permalink:"/solutions/tags/hash-table"},{label:"Tree",permalink:"/solutions/tags/tree"},{label:"Depth-First Search",permalink:"/solutions/tags/depth-first-search"},{label:"Binary Tree",permalink:"/solutions/tags/binary-tree"}],version:"current",sidebarPosition:508,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/most-frequent-subtree-sum/",tags:["Hash Table","Tree","Depth-First Search","Binary Tree"]},sidebar:"tutorialSidebar",previous:{title:"0500 - 0599",permalink:"/solutions/category/0500---0599"},next:{title:"0518 - Coin Change 2 (Medium)",permalink:"/solutions/0500-0599/coin-change-2-medium"}},m={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: DFS",id:"approach-1-dfs",level:2}],c=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,u.kt)("div",t)}},d=c("Tabs"),f=c("TabItem"),h=c("SolutionAuthor"),b={toc:p};function g(e){var t=e.components,r=(0,o.Z)(e,a);return(0,u.kt)("wrapper",(0,n.Z)({},b,r,{components:t,mdxType:"MDXLayout"}),(0,u.kt)("h1",{id:"0508---most-frequent-subtree-sum-medium"},"0508 - Most Frequent Subtree Sum (Medium)"),(0,u.kt)("h2",{id:"problem-link"},"Problem Link"),(0,u.kt)("p",null,(0,u.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/most-frequent-subtree-sum/"},"https://leetcode.com/problems/most-frequent-subtree-sum/")),(0,u.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,u.kt)("p",null,"Given the ",(0,u.kt)("inlineCode",{parentName:"p"},"root")," of a binary tree, return the most frequent ",(0,u.kt)("strong",{parentName:"p"},"subtree sum"),". If there is a tie, return all the values with the highest frequency in any order."),(0,u.kt)("p",null,"The ",(0,u.kt)("strong",{parentName:"p"},"subtree sum")," of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself)."),(0,u.kt)("p",null,(0,u.kt)("strong",{parentName:"p"},"Example 1:")),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre"},"Input: root = [5,2,-3]\nOutput: [2,-3,4]\n")),(0,u.kt)("p",null,(0,u.kt)("strong",{parentName:"p"},"Example 2:")),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre"},"Input: root = [5,2,-5]\nOutput: [2]\n")),(0,u.kt)("p",null,(0,u.kt)("strong",{parentName:"p"},"Constraints:")),(0,u.kt)("ul",null,(0,u.kt)("li",{parentName:"ul"},"The number of nodes in the tree is in the range ",(0,u.kt)("inlineCode",{parentName:"li"},"[1, 104]"),"."),(0,u.kt)("li",{parentName:"ul"},(0,u.kt)("inlineCode",{parentName:"li"},"-10^5 <= Node.val <= 10^5"))),(0,u.kt)("h2",{id:"approach-1-dfs"},"Approach 1: DFS"),(0,u.kt)("p",null,"We need to find all subtree sum and return the values with the highest frequency. To do so, first we can use dfs to find out the subtree sum. If the root is null, we return 0. Otherwise, the subtree sum would be ",(0,u.kt)("inlineCode",{parentName:"p"},"root->val + dfs(root->left) + dfs(root->rigth)"),". "),(0,u.kt)("p",null,"For each subtree sum, we use a hashmap to record it and update the maximum count at the same time. At the end, we iterate the hashmap to build the final answer."),(0,u.kt)(d,{mdxType:"Tabs"},(0,u.kt)(f,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,u.kt)(h,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,u.kt)("pre",null,(0,u.kt)("code",{parentName:"pre",className:"language-cpp"},"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int mx = 0;\n    unordered_map<int, int> m;\n    int dfs(TreeNode* root) {\n        // if root is null, return 0\n        if (!root) return 0;\n        // else the subtree sum would be \n        // the current root value + dfs result from left & right subtree\n        int res = root->val + dfs(root->left) + dfs(root->right);\n        // count the highest frequency\n        mx = max(mx, ++m[res]);\n        return res;\n    }\n    \n    vector<int> findFrequentTreeSum(TreeNode* root) {\n        // dfs from root\n        dfs(root);\n        // build the final answer\n        vector<int> ans;\n        for (auto [k, v] : m) {\n            // if it matches the highest frequency, push the subtree sum value. \n            if (v == mx) {\n                ans.push_back(k);\n            }\n        }\n        return ans;\n    }\n};\n")))))}g.isMDXComponent=!0}}]);