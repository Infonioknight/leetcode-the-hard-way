"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[99455],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),d=i,h=u["".concat(s,".").concat(d)]||u[d]||m[d]||o;return n?r.createElement(h,a(a({ref:t},p),{},{components:n})):r.createElement(h,a({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:i,a[1]=l;for(var c=2;c<o;c++)a[c]=n[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},20599:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>k,frontMatter:()=>o,metadata:()=>l,suggestedProblems:()=>p,toc:()=>c});var r=n(87462),i=(n(67294),n(3905));const o={title:"Cyclic Sort",description:"Cyclic Sort is a comparison sort algorithm that is theoretically optimal in terms of the total number of writes to the original array.",hide_table_of_contents:!1,keywords:["leetcode","tutorial","sorting","algorithm","cyclic sort"]},a=void 0,l={unversionedId:"basic-topics/sorting/cyclic-sort",id:"basic-topics/sorting/cyclic-sort",title:"Cyclic Sort",description:"Cyclic Sort is a comparison sort algorithm that is theoretically optimal in terms of the total number of writes to the original array.",source:"@site/tutorials/basic-topics/sorting/cyclic-sort.md",sourceDirName:"basic-topics/sorting",slug:"/basic-topics/sorting/cyclic-sort",permalink:"/tutorials/basic-topics/sorting/cyclic-sort",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/basic-topics/sorting/cyclic-sort.md",tags:[],version:"current",frontMatter:{title:"Cyclic Sort",description:"Cyclic Sort is a comparison sort algorithm that is theoretically optimal in terms of the total number of writes to the original array.",hide_table_of_contents:!1,keywords:["leetcode","tutorial","sorting","algorithm","cyclic sort"]},sidebar:"tutorialSidebar",previous:{title:"Bubble Sort",permalink:"/tutorials/basic-topics/sorting/bubble-sort"},next:{title:"Insertion Sort",permalink:"/tutorials/basic-topics/sorting/insertion-sort"}},s={},c=[{value:"Overview",id:"overview",level:2},{value:"Algorithm",id:"algorithm",level:2},{value:"Example: 442. Find All Duplicates in an Array",id:"example-442-find-all-duplicates-in-an-array",level:2}],p=[{problemName:"0268 - Missing Number",difficulty:"Easy",leetCodeLink:"https://leetcode.com/problems/missing-number/",solutionLink:""},{problemName:"0041 - First Missing Positive",difficulty:"Hard",leetCodeLink:"https://leetcode.com/problems/first-missing-positive/",solutionLink:""},{problemName:"0448 - Find All Numbers Disappeared In An Array",difficulty:"Easy",leetCodeLink:"https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/",solutionLink:""},{problemName:"0645 - Set Mismatch",difficulty:"Easy",leetCodeLink:"https://leetcode.com/problems/set-mismatch/",solutionLink:""}],u=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",t)},m=u("TutorialAuthors"),d=u("Contributors"),h=u("Tabs"),y=u("TabItem"),f=u("SolutionAuthor"),b=u("Table"),g={toc:c,suggestedProblems:p},v="wrapper";function k(e){let{components:t,...n}=e;return(0,i.kt)(v,(0,r.Z)({},g,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)(m,{names:"@prishit55",mdxType:"TutorialAuthors"}),(0,i.kt)(d,{names:"@wingkwong",mdxType:"Contributors"}),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"Cyclic Sort is an in-place, unstable-sorting algorithm."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"in-place"),": An in-place algorithm transforms input without using any other auxiliary data structure. As the algorithm executes the input is overwritten by the output."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"unstable")," : Unstable sorting algorithm don't preserve the relative order of equal elements while sorting.")),(0,i.kt)("p",null,"Cyclic Sort algorithm factors the permutation to be sorted into number of cycles, which are individually rotated to give desired sorted result."),(0,i.kt)("h2",{id:"algorithm"},"Algorithm"),(0,i.kt)("p",null,"Consider an array with $n$ distinct elements. For any element $x$ we can find the index at which it will occur in the sorted array by counting the number of elements smaller than $x$ in the entire array. Now,"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"if the element is at the correct position then do nothing "),(0,i.kt)("li",{parentName:"ul"},"else, write the element to its intended position. That position must be inhabited by a different number $y$ which has to be moved to its correct position. The process continues until we get an element at the original position of $x$.")),(0,i.kt)("p",null,"This completes one cycle. Repeating the cycle for every element will generate a sorted array."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/77775000/193418041-3fe52e97-17e9-4f32-89f8-975b6a7c788c.jpg",alt:"1"})),(0,i.kt)("p",null,"In the above example until and unless the correct element reaches its correct position, variable $i$ will not get updated. This depicts one cycle. For any element $nums","[i]","$ its correct position will be $nums[nums","[i]","-1]$, and if at any index correct element is not present that means its a duplicate element."),(0,i.kt)("h2",{id:"example-442-find-all-duplicates-in-an-array"},"Example: ",(0,i.kt)("a",{parentName:"h2",href:"https://leetcode.com/problems/find-all-duplicates-in-an-array/"},"442. Find All Duplicates in an Array")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"An array of integers in the range ","[1,n]"," is given, each integer appears once or twice. We have to find all the integers that appear twice in the array.")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Naive Approach")," would be to simply use a map or a frequency array to store the frequency of each element and return an array of elements appearing twice. But we require constant space complexity."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Efficient Approach")," is to put each element at its each correct index in the array as we have all integers in the range $","[1,n]","$, and check if any of the element is not at its correct position then it is a duplicate element. Hence we can use Cyclic Sort algorithm for this problem."),(0,i.kt)(h,{mdxType:"Tabs"},(0,i.kt)(y,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)(f,{name:"@prishit55",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    vector<int> findDuplicates(vector<int>& nums) {\n        vector<int> duplicates;\n        int n = nums.size();\n        // cyclc sort\n        int i = 0;\n        while (i < n) {\n            //correct index\n            int index = nums[i] - 1;\n            // if correct element is not present at the index        \n            if (nums[i] != nums[index]) {\n                // we swap the elements    \n                swap(nums[i], nums[index]); \n            } else {\n                //do nothing if element is present at its correct position    \n                i++;     \n            }\n        }\n        for(int i = 0; i < n; i++) {\n            // extract all those elements which are not present at their correct position\n            if (nums[i] != i + 1) {               \n                duplicates.push_back(nums[i]); \n            }\n        }\n        return duplicates;\n    }\n};\n  \n")))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Time Complexity : $$O(N)$$")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Space Complexity : $$O(1)$$")),(0,i.kt)("p",null,"Cyclic Sort pattern is very useful to solve problems involving arrays containing numbers in a given range, finding the missing or duplicate numbers."),(0,i.kt)(b,{title:"Suggested Problems",data:p,mdxType:"Table"}))}k.isMDXComponent=!0}}]);