"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[34936],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=u(n),c=i,f=h["".concat(l,".").concat(c)]||h[c]||d[c]||r;return n?a.createElement(f,o(o({ref:t},p),{},{components:n})):a.createElement(f,o({ref:t},p))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:i,o[1]=s;for(var u=2;u<r;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},50050:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>g,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var a=n(87462),i=(n(67294),n(3905));const r={description:"Author: @wingkwong | https://leetcode.com/problems/satisfiability-of-equality-equations/",tags:["Array","String","Union Find","Graph"]},o="0990 - Satisfiability of Equality Equations (Medium)",s={unversionedId:"0900-0999/satisfiability-of-equality-equations-medium",id:"0900-0999/satisfiability-of-equality-equations-medium",title:"0990 - Satisfiability of Equality Equations (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/satisfiability-of-equality-equations/",source:"@site/solutions/0900-0999/0990-satisfiability-of-equality-equations-medium.md",sourceDirName:"0900-0999",slug:"/0900-0999/satisfiability-of-equality-equations-medium",permalink:"/solutions/0900-0999/satisfiability-of-equality-equations-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0900-0999/0990-satisfiability-of-equality-equations-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"String",permalink:"/solutions/tags/string"},{label:"Union Find",permalink:"/solutions/tags/union-find"},{label:"Graph",permalink:"/solutions/tags/graph"}],version:"current",sidebarPosition:990,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/satisfiability-of-equality-equations/",tags:["Array","String","Union Find","Graph"]},sidebar:"tutorialSidebar",previous:{title:"0987 - Vertical Order Traversal of a Binary Tree (Hard)",permalink:"/solutions/0900-0999/vertical-order-traversal-of-a-binary-tree-hard"},next:{title:"0991 - Broken Calculator (Medium)",permalink:"/solutions/0900-0999/broken-calculator-medium"}},l={},u=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Union Find",id:"approach-1-union-find",level:2}],p=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",t)},h=p("Tabs"),d=p("TabItem"),c=p("SolutionAuthor"),f={toc:u},m="wrapper";function g(e){let{components:t,...n}=e;return(0,i.kt)(m,(0,a.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"0990---satisfiability-of-equality-equations-medium"},"0990 - Satisfiability of Equality Equations (Medium)"),(0,i.kt)("h2",{id:"problem-link"},"Problem Link"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/satisfiability-of-equality-equations/"},"https://leetcode.com/problems/satisfiability-of-equality-equations/")),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"You are given an array of strings ",(0,i.kt)("inlineCode",{parentName:"p"},"equations")," that represent relationships between variables where each string ",(0,i.kt)("inlineCode",{parentName:"p"},"equations[i]")," is of length ",(0,i.kt)("inlineCode",{parentName:"p"},"4")," and takes one of two different forms: ",(0,i.kt)("inlineCode",{parentName:"p"},'"xi==yi"')," or ",(0,i.kt)("inlineCode",{parentName:"p"},'"xi!=yi"'),".Here, ",(0,i.kt)("inlineCode",{parentName:"p"},"xi")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"yi")," are lowercase letters (not necessarily different) that represent one-letter variable names."),(0,i.kt)("p",null,"Return ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),(0,i.kt)("em",{parentName:"p"},"if it is possible to assign integers to variable names so as to satisfy all the given equations, or"),(0,i.kt)("inlineCode",{parentName:"p"},"false"),(0,i.kt)("em",{parentName:"p"},"otherwise"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input: equations = ["a==b","b!=a"]\nOutput: false\nExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.\nThere is no way to assign the variables to satisfy both equations.\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input: equations = ["b==a","a==b"]\nOutput: true\nExplanation: We could assign a = 1 and b = 1 to satisfy both equations.\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= equations.length <= 500")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"equations[i].length == 4")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"equations[i][0]")," is a lowercase letter."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"equations[i][1]")," is either ",(0,i.kt)("inlineCode",{parentName:"li"},"'='")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"'!'"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"equations[i][2]")," is ",(0,i.kt)("inlineCode",{parentName:"li"},"'='"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"equations[i][3]")," is a lowercase letter.")),(0,i.kt)("h2",{id:"approach-1-union-find"},"Approach 1: Union Find"),(0,i.kt)("p",null,"Based on the property of ",(0,i.kt)("inlineCode",{parentName:"p"},"=="),". If you see ",(0,i.kt)("inlineCode",{parentName:"p"},"==")," in the equation, then we can put those numbers under the same group due to the following properties."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"if a == b, then b == a"),(0,i.kt)("li",{parentName:"ul"},"if a == b, b == c, then a == c")),(0,i.kt)("p",null,"In other word, x != y means x is not in the same group as y."),(0,i.kt)("p",null,"So we need a data structure to handle the connected relationship and use contradiction to find out the false cases. Then DSU comes to mind. If we can see them as a graph. For the case ",(0,i.kt)("inlineCode",{parentName:"p"},"a == b, b == c"),", we may first think of a -> b -> c which may lead us to think about a DFS solution. However, we can compress the path like a -> b and a -> c where a is the root. By doing so, we compress b and c into the same level so that we don't need to walk all the nodes between the root and the source to achieve O(logN) per call on average. "),(0,i.kt)(h,{mdxType:"Tabs"},(0,i.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)(c,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int parent[26];\n    // find the root of node x. \n    // here we are not using parent[x],\n    // because it may not contain the updated value of the connected component that x belongs to. \n    // therefore, we walk the ancestors of the vertex until we reach the root.\n    int find(int x) {\n        // with path compression\n        if (parent[x] == x) return x;\n        return parent[x] = find(parent[x]);\n        // without path compression\n        // return parent[x] == x ? x : find(parent[x]);\n    }\n    // the idea is to put all characters in the same group if they are equal\n    // in order to do that, we can use Disjoint Set Union (dsu) aka Union Find\n    // for dsu tutorial, please check out https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/disjoint-set-union\n    bool equationsPossible(vector<string>& equations) {\n        int n = (int) equations.size();\n        // at the beginning, put each character index in its own group\n        // so we will have 26 groups with one character each\n        // i.e. 'a' in group 0, 'b' in group 1, ..., 'z' in group 25\n        for (int i = 0; i < 26; i++) parent[i] = i;\n        for (auto e : equations) {\n            // if two character is equal, \n            if (e[1] == '=') {\n                // e.g. a == b\n                // then we group them together\n                // how? we use `find` function to find out the parent group of the target character index\n                // then update parent. a & b would be in group 1 (i.e. a merged into the group where b belongs to)\n                // or you can also do `parent[find(e[3]- 'a')] = find(e[0] - 'a');` (i.e. b merged into the group where a belongs to)\n                parent[find(e[0]- 'a')] = find(e[3] - 'a');\n            }\n        }\n        // handle != case\n        for (auto e : equations) {\n            // if two characters are not equal\n            // then which means their parent must not be equal\n            if (e[1] == '!' && find(e[0] - 'a') == find(e[3] - 'a')) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n"))),(0,i.kt)(d,{value:"py",label:"Python",mdxType:"TabItem"},(0,i.kt)(c,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    # the idea is to put all characters in the same group if they are equal\n    # in order to do that, we can use Disjoint Set Union (dsu) aka Union Find\n    # for dsu tutorial, please check out https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/disjoint-set-union\n    def equationsPossible(self, equations: List[str]) -> bool:\n        # find the root of node x. \n        # here we are not using parent[x] \n        # because it may not contain the updated value of the connected component that x belongs to. \n        # Therefore, we walk the ancestors of the vertex until we reach the root.\n        def find(x):\n            # with path compress\n            if parent[x] == x:\n                return x\n            parent[x] = find(parent[x])\n            return parent[x]\n            # without path compression\n            #return x if parent[x] == x else find(parent[x])\n        # at the beginning, put each character in its own group\n        # so we will have 26 groups with one character each\n        # i.e. 'a' in group 0, 'b' in group 1, ..., 'z' in group 25\n        parent = [i for i in range(26)]\n        for e in equations:\n            if e[1] == '=':\n                # e.g. a == b\n                # then we group them together\n                # how? we use `find` function to find out the parent group of the target character index\n                # then update parent. a & b would be in group 1 (i.e. a merged into the group where b belongs to)\n                # or you can also do `parent[find(ord(e[3]) - ord('a'))] = find(ord(e[0]) - ord('a'))`\n                # i.e. b merged into the group where a belongs to\n                parent[find(ord(e[0]) - ord('a'))] = find(ord(e[3]) - ord('a'))\n        # handle != case\n        for e in equations:\n            # if two characters are not equal\n            # then which means their parent must not be equal\n            if e[1] == '!' and find(ord(e[0]) - ord('a')) == find(ord(e[3]) - ord('a')):\n                return False\n        return True\n"))),(0,i.kt)(d,{value:"go",label:"Go",mdxType:"TabItem"},(0,i.kt)(c,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"// find the root of node x. \n// here we are not using parent[x],\n// because it may not contain the updated value of the connected component that x belongs to. \n// therefore, we walk the ancestors of the vertex until we reach the root.\nfunc find(parent []int, x int) int{\n    if parent[x] == x {\n        return x\n    }\n    parent[x] = find(parent, parent[x])\n    return parent[x]\n    // without path compression\n    // if parent[x] == x {\n    //     return x\n    // }\n    // return find(parent, parent[x])\n}\n\n// the idea is to put all characters in the same group if they are equal\n// in order to do that, we can use Disjoint Set Union (dsu) aka Union Find\n// for dsu tutorial, please check out https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/disjoint-set-union\nfunc equationsPossible(equations []string) bool {\n    // at the beginning, put each character index in its own group\n    // so we will have 26 groups with one character each\n    // i.e. 'a' in group 0, 'b' in group 1, ..., 'z' in group 25\n    parent := make([]int, 26)\n    for i := range parent {\n        parent[i] = i\n    }\n    for _, e := range equations {\n        if e[1] == '=' {\n            // e.g. a == b\n            // then we group them together\n            // how? we use `find` function to find out the parent group of the target character index\n            // then update parent. a & b would be in group 1 (i.e. a merged into the group where b belongs to)\n            // or you can also do `find(parent, int(e[3] - 'a')) = find(parent, int(e[0] - 'a'))` \n            // i.e. b merged into the group where a belongs to\n            parent[find(parent, int(e[0] - 'a'))] = find(parent, int(e[3] - 'a'))\n        }\n    }\n    // handle != case\n    for _, e := range equations {\n        // if two characters are not equal\n        // then which means their parent must not be equal\n        if e[1] == '!' && find(parent, int(e[0] - 'a')) == find(parent, int(e[3] - 'a')) {\n            return false   \n        }\n    } \n    return true\n}\n"))),(0,i.kt)(d,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)(c,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    int[] parent = new int[26];\n    public int find(int x) {\n        // with path compression\n        if (parent[x] == x) return x;\n        return parent[x] = find(parent[x]);\n        // without path compression\n        // return parent[x] == x ? x : find(parent[x]);\n    }\n    // the idea is to put all characters in the same group if they are equal\n    // in order to do that, we can use Disjoint Set Union (dsu) aka Union Find\n    // for dsu tutorial, please check out https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/disjoint-set-union\n    public boolean equationsPossible(String[] equations) {\n        int n = equations.length;\n        // at the beginning, put each character index in its own group\n        // so we will have 26 groups with one character each\n        // i.e. 'a' in group 0, 'b' in group 1, ..., 'z' in group 25\n        for (int i = 0; i < 26; i++) parent[i] = i;\n        for (String e : equations) {\n            // if two character is equal, \n            if (e.charAt(1) == '=') {\n                // e.g. a = b\n                // then we group them together\n                // how? we use `find` function to find out the parent group of the target character index\n                // then update parent. a & b would be in group 1 (i.e. a merged into the group where b belongs to)\n                // or you can also do `parent[find(e.charAt(3)- 'a')] = find(e.charAt(0) - 'a');` (i.e. b merged into the group where a belongs to)\n                parent[find(e.charAt(0)- 'a')] = find(e.charAt(3) - 'a');\n            }\n        }\n        // handle != case\n        for (String e : equations) {\n            // if two characters are not equal\n            // then which means their parent must not be equal\n            if (e.charAt(1) == '!' && find(e.charAt(0) - 'a') == find(e.charAt(3) - 'a')) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n")))))}g.isMDXComponent=!0}}]);