"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[49613],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},m="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,p=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=s(n),c=a,d=m["".concat(p,".").concat(c)]||m[c]||h[c]||i;return n?r.createElement(d,o(o({ref:t},u),{},{components:n})):r.createElement(d,o({ref:t},u))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=c;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[m]="string"==typeof e?e:a,o[1]=l;for(var s=2;s<i;s++)o[s]=n[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},17449:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>g,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var r=n(87462),a=(n(67294),n(3905));const i={description:"Author: @wingkwong, @ColeB2 | https://leetcode.com/problems/kth-largest-element-in-an-array/",tags:["Priority Queue","Quick Select"]},o="0215 - Kth Largest Element in an Array (Medium)",l={unversionedId:"0200-0299/kth-largest-element-in-an-array-medium",id:"0200-0299/kth-largest-element-in-an-array-medium",title:"0215 - Kth Largest Element in an Array (Medium)",description:"Author: @wingkwong, @ColeB2 | https://leetcode.com/problems/kth-largest-element-in-an-array/",source:"@site/solutions/0200-0299/0215-kth-largest-element-in-an-array-medium.md",sourceDirName:"0200-0299",slug:"/0200-0299/kth-largest-element-in-an-array-medium",permalink:"/solutions/0200-0299/kth-largest-element-in-an-array-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0200-0299/0215-kth-largest-element-in-an-array-medium.md",tags:[{label:"Priority Queue",permalink:"/solutions/tags/priority-queue"},{label:"Quick Select",permalink:"/solutions/tags/quick-select"}],version:"current",sidebarPosition:215,frontMatter:{description:"Author: @wingkwong, @ColeB2 | https://leetcode.com/problems/kth-largest-element-in-an-array/",tags:["Priority Queue","Quick Select"]},sidebar:"tutorialSidebar",previous:{title:"0214 - Shortest Palindrome (Hard)",permalink:"/solutions/0200-0299/shortest-palindrome-hard"},next:{title:"0217 - Contains Duplicate (Easy)",permalink:"/solutions/0200-0299/contains-duplicate-easy"}},p={},s=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Priority Queue",id:"approach-1-priority-queue",level:2},{value:"Approach 2: STL",id:"approach-2-stl",level:2},{value:"Approach 3: Quick Select",id:"approach-3-quick-select",level:2}],u=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",t)},m=u("Tabs"),h=u("TabItem"),c=u("SolutionAuthor"),d={toc:s},k="wrapper";function g(e){let{components:t,...n}=e;return(0,a.kt)(k,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"0215---kth-largest-element-in-an-array-medium"},"0215 - Kth Largest Element in an Array (Medium)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/kth-largest-element-in-an-array/"},"https://leetcode.com/problems/kth-largest-element-in-an-array/")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"Given an integer array ",(0,a.kt)("inlineCode",{parentName:"p"},"nums")," and an integer ",(0,a.kt)("inlineCode",{parentName:"p"},"k"),", return ",(0,a.kt)("em",{parentName:"p"},"the")," ",(0,a.kt)("inlineCode",{parentName:"p"},"kth")," ",(0,a.kt)("em",{parentName:"p"},"largest element in the array"),"."),(0,a.kt)("p",null,"Note that it is the ",(0,a.kt)("inlineCode",{parentName:"p"},"kth")," largest element in the sorted order, not the ",(0,a.kt)("inlineCode",{parentName:"p"},"kth")," distinct element."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= k <= nums.length <= 10^4")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"-10^4 <= nums[i] <= 10^4"))),(0,a.kt)("h2",{id:"approach-1-priority-queue"},"Approach 1: Priority Queue"),(0,a.kt)("p",null,"When we look for ",(0,a.kt)("inlineCode",{parentName:"p"},"k-th")," elements, we can think of Priority Queue as it internally sorts the container. We can check if the size exceeds $k$."),(0,a.kt)("p",null,"Time Complexity: $$O(nlogk)$$. Where n is the number of values in the nums array, and k is the size of our heap. We must loop through all numbers in nums which takes $$n$$ time, but our heap can be maintained in $$logk$$ time."),(0,a.kt)("p",null,"Space Complexity: $$O(k)$$. Where $$k$$ is the size of our heap, as we are only putting $$k$$ values inside our heap."),(0,a.kt)(m,{mdxType:"Tabs"},(0,a.kt)(h,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(c,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        priority_queue<int> pq;\n        // push elements to priority queue\n        for (auto &x : nums) pq.push(x);\n        // only keep k largest elements\n        for (int i = 0; i < k - 1; i++) pq.pop();\n        // return the top which is the k-th largest element\n        return pq.top();\n    }\n};\n"))),(0,a.kt)(h,{value:"python",label:"Python",mdxType:"TabItem"},(0,a.kt)(c,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    # Python heapq is a minheap. Perfect for the question, as the\n    # the smallest value will always be at the top, and the first\n    # value popped off during a pop/pushpop. Leaving only the k largest\n    # inside the heap.\n    # Time: O(nlogk)\n    # Space: O(k)\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        # initialize our heap\n        heap = []\n        # loop through all numbers in nums\n        for num in nums:\n            # < k values in heap we can just push\n            if len(heap) < k:\n                # python uses heapq module to build heaps\n                # heapq methods typically take to args\n                # (heap, value) where the heap is the list we are using\n                # as a heap, and the value is the value we are putting\n                # into the heap.\n                heapq.heappush(heap, num)\n            else:\n                # => k we push onto the heap then pop.\n                heapq.heappushpop(heap, num)\n        # return first value inside our heap.\n        return heap[0]\n")))),(0,a.kt)("h2",{id:"approach-2-stl"},"Approach 2: STL"),(0,a.kt)("p",null,"The following STL functions can partially sort to solve the problem."),(0,a.kt)(m,{mdxType:"Tabs"},(0,a.kt)(h,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(c,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        partial_sort(nums.begin(), nums.begin() + k, nums.end(), greater<int>());\n        return nums[k - 1];\n    }\n};\n")),(0,a.kt)(c,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        nth_element(nums.begin(), nums.begin() + k - 1, nums.end(), greater<int>());\n        return nums[k - 1];\n    }\n};\n")))),(0,a.kt)("h2",{id:"approach-3-quick-select"},"Approach 3: Quick Select"),(0,a.kt)("p",null,"Quick Select is a partitioning pattern using in Quick Sort, which can be done on $$O(n)$$ time on average."),(0,a.kt)("p",null,"First, we need to choose a pivot value, and partition the values around the pivot (That is the larger numbers left, smaller on the right). If after the partitioning stage, we have $$k-1$$ elements to the left of our partition ($$k-1$$ because we are 0 indexed), it means the value at our partition index is the kth largest. If not we have to adjust our left or right pointers. Either our partition index is less than k, then we move our left pointer up $$partition + 1$$ or our right down to $$partition - 1$$. "),(0,a.kt)("p",null,"Time Complexity: Average Case $$O(n)$$. Where n is the number of values. By selecting a random pivot, we can avoid malicious inputs, and in general solve the question on $$O(n)$$ time. Whereas if we select the worst partition at each iteration, we will approach $$O(n^2)$$ time."),(0,a.kt)("p",null,"Space: $$O(1)$$. We can do this in place and just swap elements around."),(0,a.kt)(m,{mdxType:"Tabs"},(0,a.kt)(h,{value:"python",label:"Python",mdxType:"TabItem"},(0,a.kt)(c,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        # partitioning function. 2 parameters, l and r to represent\n        # left and right pointers inside our nums array.\n        def partition(l,r):\n            # pivot, select random value between l,r.\n            pivot = random.randint(l,r)\n            # swap our pivot to the end of our partition.\n            nums[r], nums[pivot] = nums[pivot], nums[r]\n            # initialize index to swap with as we loop.\n            i = l\n            # track our pivot value, swapped with right side already.\n            pivot_value = nums[r]\n            # loop from l to r + 1. Note r + 1 will swap our pivot \n            # back in place for us. \n            for j in range(l, r + 1):\n                # number looking at is larger than our pivot\n                if nums[j] >= pivot_value:\n                    # swap it to ith position\n                    nums[i], nums[j] = nums[j], nums[i]\n                    # increment our i swap index pointer.\n                    i += 1\n            # return - 1 as that was the last swapped pointer.\n            return i - 1\n        # start algorithm\n        # initialize left and right pointers to 0, n-1\n        # initialize our partition to n.\n        left, right, p = 0, len(nums) - 1, len(nums)\n        # run our algorithm until our partition index reaches k-1\n        # k - 1 means k elements inside our partition. We use k - 1 as\n        # we are 0th-indexed.\n        while p != k-1:\n            # Find our partition p\n            p = partition(left,right)\n            # too few elements inside our partition\n            if p < k-1:\n                # move left pointer up\n                left = p + 1\n            # too many\n            elif p > k-1:\n                # move right pointer down.\n                right = p - 1\n        # p == k - 1, it means our partition is the kth largest. \n        return nums[p]\n")))))}g.isMDXComponent=!0}}]);