"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[62336],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var o=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=o.createContext({}),s=function(e){var t=o.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},m=function(e){var t=s(e.components);return o.createElement(p.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,p=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=s(n),d=r,h=u["".concat(p,".").concat(d)]||u[d]||c[d]||i;return n?o.createElement(h,a(a({ref:t},m),{},{components:n})):o.createElement(h,a({ref:t},m))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,a=new Array(i);a[0]=d;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[u]="string"==typeof e?e:r,a[1]=l;for(var s=2;s<i;s++)a[s]=n[s];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},51730:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var o=n(87462),r=(n(67294),n(3905));const i={description:"Author: @wingkwong | https://leetcode.com/problems/grid-game/"},a="2017 - Grid Game (Medium)",l={unversionedId:"2000-2099/grid-game-medium",id:"2000-2099/grid-game-medium",title:"2017 - Grid Game (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/grid-game/",source:"@site/solutions/2000-2099/2017-grid-game-medium.md",sourceDirName:"2000-2099",slug:"/2000-2099/grid-game-medium",permalink:"/solutions/2000-2099/grid-game-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2000-2099/2017-grid-game-medium.md",tags:[],version:"current",sidebarPosition:2017,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/grid-game/"},sidebar:"tutorialSidebar",previous:{title:"2013 - Detect Squares (Medium)",permalink:"/solutions/2000-2099/detect-squares-medium"},next:{title:"2032 - Two Out of Three (Easy)",permalink:"/solutions/2000-2099/two-out-of-three-easy"}},p={},s=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Prefix &amp; Suffix Sum",id:"approach-1-prefix--suffix-sum",level:2}],m=(u="SolutionAuthor",function(e){return console.warn("Component "+u+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",e)});var u;const c={toc:s},d="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,o.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"2017---grid-game-medium"},"2017 - Grid Game (Medium)"),(0,r.kt)("h2",{id:"problem-link"},"Problem Link"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/grid-game/"},"https://leetcode.com/problems/grid-game/")),(0,r.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.kt)("p",null,"You are given a ",(0,r.kt)("strong",{parentName:"p"},"0-indexed")," 2D array ",(0,r.kt)("inlineCode",{parentName:"p"},"grid")," of size ",(0,r.kt)("inlineCode",{parentName:"p"},"2 x n"),", where ",(0,r.kt)("inlineCode",{parentName:"p"},"grid[r][c]")," represents the number of points at position ",(0,r.kt)("inlineCode",{parentName:"p"},"(r, c)")," on the matrix. Two robots are playing a game on this matrix."),(0,r.kt)("p",null,"Both robots initially start at ",(0,r.kt)("inlineCode",{parentName:"p"},"(0, 0)")," and want to reach ",(0,r.kt)("inlineCode",{parentName:"p"},"(1, n-1)"),". Each robot may only move to the ",(0,r.kt)("strong",{parentName:"p"},"right")," (",(0,r.kt)("inlineCode",{parentName:"p"},"(r, c)")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"(r, c + 1)"),") or ",(0,r.kt)("strong",{parentName:"p"},"down")," (",(0,r.kt)("inlineCode",{parentName:"p"},"(r, c)")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"(r + 1, c)"),")."),(0,r.kt)("p",null,"At the start of the game, the ",(0,r.kt)("strong",{parentName:"p"},"first")," robot moves from ",(0,r.kt)("inlineCode",{parentName:"p"},"(0, 0)")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"(1, n-1)"),", collecting all the points from the cells on its path. For all cells ",(0,r.kt)("inlineCode",{parentName:"p"},"(r, c)")," traversed on the path, ",(0,r.kt)("inlineCode",{parentName:"p"},"grid[r][c]")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),". Then, the ",(0,r.kt)("strong",{parentName:"p"},"second")," robot moves from ",(0,r.kt)("inlineCode",{parentName:"p"},"(0, 0)")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"(1, n-1)"),", collecting the points on its path. Note that their paths may intersect with one another."),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"first")," robot wants to ",(0,r.kt)("strong",{parentName:"p"},"minimize")," the number of points collected by the ",(0,r.kt)("strong",{parentName:"p"},"second")," robot. In contrast, the ",(0,r.kt)("strong",{parentName:"p"},"second")," robot wants to ",(0,r.kt)("strong",{parentName:"p"},"maximize")," the number of points it collects. If both robots play ",(0,r.kt)("strong",{parentName:"p"},"optimally"),", return ",(0,r.kt)("em",{parentName:"p"},"the ",(0,r.kt)("strong",{parentName:"em"},"number of points")," collected by the ",(0,r.kt)("strong",{parentName:"em"},"second")," robot.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1:")),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2021/09/08/a1.png",alt:null})),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: grid = [[2,5,4],[1,5,1]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 0 + 4 + 0 = 4 points.\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2:")),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2021/09/08/a2.png",alt:null})),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: grid = [[3,3,1],[8,5,2]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 3 + 1 + 0 = 4 points.\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 3:")),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2021/09/08/a3.png",alt:null})),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: grid = [[1,3,1,15],[1,3,3,1]]\nOutput: 7\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points.\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Constraints:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"grid.length == 2")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"n == grid[r].length")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"1 <= n <= 5 * 10^4")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"1 <= grid[r][c] <= 10^5"))),(0,r.kt)("h2",{id:"approach-1-prefix--suffix-sum"},"Approach 1: Prefix & Suffix Sum"),(0,r.kt)("p",null,"The first observation is that the first point on the top row and the last point on the bottom row would be collected by robot 1. Therefore, robot 2 can only collect some from the top or from the bottom. In this case, we can use prefix sum and suffix sum to get how many points robot 2 can collect at a certain index."),(0,r.kt)("p",null,"For each index $$i$$, robot 2 could either"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"get from the top row, i.e. $$pref","[n - 1]"," - pref","[i]","$$, or"),(0,r.kt)("li",{parentName:"ul"},"get from the bottom row, i.e. $$suff","[0]"," - suff","[i]","$$")),(0,r.kt)("p",null,"We take the maximum one at each $$i$$ and compare with the current answer. As robot 1 plays optimally, which means it would get the maximum point. We take the minimum here."),(0,r.kt)(m,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    long long gridGame(vector<vector<int>>& grid) {\n        int n = grid[0].size();\n        // build pref sum\n        vector<long long> pref(n);\n        pref[0] = grid[0][0];\n        for (int i = 1; i < n; i++) {\n            pref[i] = pref[i - 1] + grid[0][i];\n        }\n        // build suffix sum\n        vector<long long> suff(n);\n        suff[n - 1] = grid[1][n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            suff[i] = suff[i + 1] + grid[1][i];\n        }\n        // robot 1 would get the max point\n        long long ans = 1e18;\n        // iterate each index\n        for (int i = 0; i < n; i++) {\n            // either take \n            ans = min({\n                // take the min one with ans\n                ans, \n                // choose the best one\n                max(\n                    // take from the top row\n                    pref[n - 1] - pref[i], \n                    // take from the bottom row\n                    suff[0] - suff[i])}\n                );\n        }\n        return ans;\n    }\n};\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Further Question 1: What is the maximum points collected by robot 1?")),(0,r.kt)("details",null,(0,r.kt)("summary",null,"Check Answer"),(0,r.kt)("p",null,"The idea is similar. Robot 1 can collect all points till $$i$$, then move to the bottom row and go till the end. We can simply check $$pref","[i]","$$ (collected on the top row) plus $$suff","[i]","$$ (collected on the bottom row)."),(0,r.kt)(m,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    long long gridGame(vector<vector<int>>& grid) {\n        int n = grid[0].size();\n        vector<int> pref(n);\n        pref[0] = grid[0][0];\n        for (int i = 1; i < n; i++) {\n            pref[i] = pref[i - 1] + grid[0][i];\n        }\n        vector<int> suff(n);\n        suff[n - 1] = grid[1][n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            suff[i] = suff[i + 1] + grid[1][i];\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            ans = max(ans, pref[i] + suff[i]);\n        }\n        return ans;\n    }\n};\n"))),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Further Question 2: Are you able to optimise the above solution?")))}h.isMDXComponent=!0}}]);