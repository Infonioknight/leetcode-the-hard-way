"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[49713],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return u}});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=p(a),u=r,d=c["".concat(l,".").concat(u)]||c[u]||h[u]||o;return a?n.createElement(d,i(i({ref:t},m),{},{components:a})):n.createElement(d,i({ref:t},m))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},55951:function(e,t,a){a.r(t),a.d(t,{assets:function(){return m},contentTitle:function(){return l},default:function(){return k},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return h}});var n=a(87462),r=a(63366),o=(a(67294),a(3905)),i=["components"],s={description:"Author: @ColeB2 | https://leetcode.com/problems/diameter-of-binary-tree/",tags:["Tree","Depth-First Search","Binary Tree"]},l="0543 - Diameter of Binary Tree (Easy)",p={unversionedId:"0500-0599/diameter-of-binary-tree-easy",id:"0500-0599/diameter-of-binary-tree-easy",title:"0543 - Diameter of Binary Tree (Easy)",description:"Author: @ColeB2 | https://leetcode.com/problems/diameter-of-binary-tree/",source:"@site/solutions/0500-0599/0543-diameter-of-binary-tree-easy.md",sourceDirName:"0500-0599",slug:"/0500-0599/diameter-of-binary-tree-easy",permalink:"/solutions/0500-0599/diameter-of-binary-tree-easy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0500-0599/0543-diameter-of-binary-tree-easy.md",tags:[{label:"Tree",permalink:"/solutions/tags/tree"},{label:"Depth-First Search",permalink:"/solutions/tags/depth-first-search"},{label:"Binary Tree",permalink:"/solutions/tags/binary-tree"}],version:"current",sidebarPosition:543,frontMatter:{description:"Author: @ColeB2 | https://leetcode.com/problems/diameter-of-binary-tree/",tags:["Tree","Depth-First Search","Binary Tree"]},sidebar:"tutorialSidebar",previous:{title:"0540 - Single Element in a Sorted Array (Medium)",permalink:"/solutions/0500-0599/single-element-in-a-sorted-array-medium"},next:{title:"0557 - Reverse Words in a String III (Easy)",permalink:"/solutions/0500-0599/reverse-words-in-a-string-iii-easy"}},m={},h=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Recursive Depth-First Search",id:"approach-1-recursive-depth-first-search",level:2}],c=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",t)}},u=c("Tabs"),d=c("TabItem"),f=c("SolutionAuthor"),g={toc:h};function k(e){var t=e.components,a=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,n.Z)({},g,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"0543---diameter-of-binary-tree-easy"},"0543 - Diameter of Binary Tree (Easy)"),(0,o.kt)("h2",{id:"problem-link"},"Problem Link"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/diameter-of-binary-tree/"},"https://leetcode.com/problems/diameter-of-binary-tree/")),(0,o.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,o.kt)("p",null,"Given the ",(0,o.kt)("inlineCode",{parentName:"p"},"root")," of a binary tree, return ",(0,o.kt)("em",{parentName:"p"},"the length of the ",(0,o.kt)("strong",{parentName:"em"},"diameter")," of the tree"),"."),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"diameter")," of a binary tree is the ",(0,o.kt)("strong",{parentName:"p"},"length")," of the longest path between any two nodes in a tree. This path may or may not pass through the ",(0,o.kt)("inlineCode",{parentName:"p"},"root"),"."),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"length")," of a path between two nodes is represented by the number of edges between them."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 1:")),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg",alt:null})),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: root = [1,2,3,4,5]\nOutput: 3\nExplanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 2:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: root = [1,2]\nOutput: 1\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Constraints:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The number of nodes in the tree is in the range ",(0,o.kt)("inlineCode",{parentName:"li"},"[1, 10^4]"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"-100 <= Node.val <= 100"))),(0,o.kt)("h2",{id:"approach-1-recursive-depth-first-search"},"Approach 1: Recursive Depth-First Search"),(0,o.kt)("p",null,"Like most tree problems, they can often be solved using recursion. Thinking about the brute force, of solving this from the top down, that is calculating the height of the left and right sub-tree, would obviously leave us with a lot of repeated work to cacluate that for each node. So bottoms-up, which is often how our recursion will solve it sounds like a much easier plan."),(0,o.kt)("p",null,"Like any recursive algorithm we must first think of our base case. For a tree that would be, what does a null node return? We can return 0 for that since a null node would have no edges, and a parent pointing to a null node doesn't have a legitimate edge pointing to it. So it's diameter would be 0."),(0,o.kt)("p",null,"So what next? Well we know if we aren't a null node, that to get the diameter, we need the length of the longest path of both the left and right sub-trees to solve it for the current node. This is where the recursion comes in, so we can recursively call our algorithm on both the left and right sub-trees to help us get the diameter of the current node."),(0,o.kt)("p",null,"So now we have a diameter, what do we do with it? Well, we probably need a global diameter to check it against, since the max diameter doesn't necessarily run through the root, we will need to check it against what the global is. This tells us we probably need to use a helper function to calculate everything, and then update a global diameter once we find the diameter for each node."),(0,o.kt)("p",null,"Finally we can return up the length of the longest sub-tree, left or right, adding 1 to it to account for the path back to the parent so that the parent can calulate it's diameter."),(0,o.kt)("p",null,"Time Complexity: ",(0,o.kt)("span",{parentName:"p",className:"math math-inline"},(0,o.kt)("span",{parentName:"span",className:"katex"},(0,o.kt)("span",{parentName:"span",className:"katex-mathml"},(0,o.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,o.kt)("semantics",{parentName:"math"},(0,o.kt)("mrow",{parentName:"semantics"},(0,o.kt)("mi",{parentName:"mrow"},"O"),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,o.kt)("mi",{parentName:"mrow"},"n"),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,o.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n)")))),(0,o.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,o.kt)("span",{parentName:"span",className:"mopen"},"("),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,o.kt)("span",{parentName:"span",className:"mclose"},")")))))," as we are going to have to traverse each node in the tree, and can't skip any nodes."),(0,o.kt)("p",null,"Space Complexity: ",(0,o.kt)("span",{parentName:"p",className:"math math-inline"},(0,o.kt)("span",{parentName:"span",className:"katex"},(0,o.kt)("span",{parentName:"span",className:"katex-mathml"},(0,o.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,o.kt)("semantics",{parentName:"math"},(0,o.kt)("mrow",{parentName:"semantics"},(0,o.kt)("mi",{parentName:"mrow"},"O"),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,o.kt)("mi",{parentName:"mrow"},"h"),(0,o.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,o.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(h)")))),(0,o.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,o.kt)("span",{parentName:"span",className:"mopen"},"("),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal"},"h"),(0,o.kt)("span",{parentName:"span",className:"mclose"},")"))))),", as with most recursive DFS, we are only going to have the current path we are taking inside the call stack, which will scale with the height of the tree."),(0,o.kt)(u,{mdxType:"Tabs"},(0,o.kt)(d,{value:"python",label:"Python",mdxType:"TabItem"},(0,o.kt)(f,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-py"},"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        # set global diameter, our return value. Initialize as 0.\n        self.diameter = 0\n        # helper function - recursive Depth-First Search.\n        def helper(node):\n            # Base case, reaches null node, return height of 0.\n            if not node:\n                return 0\n            # recursively check left and right children nodes to get the max\n            # height of each sub-tree.\n            l = helper(node.left)\n            r = helper(node.right)\n            # diamater for the current node will be solved by calculating the \n            # max height of each sub-tree and adding them together.\n            # update global diameter, with current nodes diameter.\n            self.diameter = max(self.diameter, l + r)\n            # Now we don't want to pass the diameter up, we just want to pass the\n            # height of the longest sub-tree up. So return 1 + max height of either\n            # the left or right sub-tree.\n            return 1 + max(l, r)\n        # call helper function - helper function will update our global\n        # diameter so no need for us to assign a value to anything.\n        helper(root)\n        # return diameter we calcuated.\n        return self.diameter\n")))))}k.isMDXComponent=!0}}]);