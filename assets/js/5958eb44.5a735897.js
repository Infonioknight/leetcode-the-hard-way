"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[21648],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var r=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=r.createContext({}),m=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=m(e.components);return r.createElement(s.Provider,{value:n},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=m(t),d=i,h=u["".concat(s,".").concat(d)]||u[d]||c[d]||a;return t?r.createElement(h,o(o({ref:n},p),{},{components:t})):r.createElement(h,o({ref:n},p))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,o=new Array(a);o[0]=d;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[u]="string"==typeof e?e:i,o[1]=l;for(var m=2;m<a;m++)o[m]=t[m];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},34078:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>k,frontMatter:()=>a,metadata:()=>l,toc:()=>m});var r=t(87462),i=(t(67294),t(3905));const a={description:"Author: @jit, @martin0327, @heder | https://leetcode.com/problems/arithmetic-subarrays/",tags:["Array","Sorting"]},o="1630 - Arithmetic Subarrays (Medium)",l={unversionedId:"1600-1699/arithmetic-subarrays-medium",id:"1600-1699/arithmetic-subarrays-medium",title:"1630 - Arithmetic Subarrays (Medium)",description:"Author: @jit, @martin0327, @heder | https://leetcode.com/problems/arithmetic-subarrays/",source:"@site/solutions/1600-1699/1630-arithmetic-subarrays-medium.md",sourceDirName:"1600-1699",slug:"/1600-1699/arithmetic-subarrays-medium",permalink:"/solutions/1600-1699/arithmetic-subarrays-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1600-1699/1630-arithmetic-subarrays-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Sorting",permalink:"/solutions/tags/sorting"}],version:"current",sidebarPosition:1630,frontMatter:{description:"Author: @jit, @martin0327, @heder | https://leetcode.com/problems/arithmetic-subarrays/",tags:["Array","Sorting"]},sidebar:"tutorialSidebar",previous:{title:"1626 - Best Team With No Conflicts (Medium)",permalink:"/solutions/1600-1699/best-team-with-no-conflicts-medium"},next:{title:"1631 - Path With Minimum Effort (Medium)",permalink:"/solutions/1600-1699/path-with-minimum-effort-medium"}},s={},m=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Brute Force",id:"approach-1-brute-force",level:2},{value:"Approach 2: Mo&#39;s Algorithm",id:"approach-2-mos-algorithm",level:2},{value:"Approach 3: RMQ",id:"approach-3-rmq",level:2}],p=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",n)},u=p("Tabs"),c=p("TabItem"),d=p("SolutionAuthor"),h={toc:m},f="wrapper";function k(e){let{components:n,...t}=e;return(0,i.kt)(f,(0,r.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"1630---arithmetic-subarrays-medium"},"1630 - Arithmetic Subarrays (Medium)"),(0,i.kt)("h2",{id:"problem-link"},"Problem Link"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/arithmetic-subarrays/"},"https://leetcode.com/problems/arithmetic-subarrays/")),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"A sequence of numbers is called ",(0,i.kt)("strong",{parentName:"p"},"arithmetic")," if it consists of at least two elements, and the difference between every two consecutive elements is the same. More formally, a sequence ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," is arithmetic if and only if ",(0,i.kt)("inlineCode",{parentName:"p"},"s[i+1] - s[i] == s[1] - s[0]"),"for all valid ",(0,i.kt)("inlineCode",{parentName:"p"},"i"),"."),(0,i.kt)("p",null,"For example, these are ",(0,i.kt)("strong",{parentName:"p"},"arithmetic")," sequences:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9\n")),(0,i.kt)("p",null,"The following sequence is not ",(0,i.kt)("strong",{parentName:"p"},"arithmetic"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"1, 1, 2, 5, 7\n")),(0,i.kt)("p",null,"You are given an array of ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," integers, ",(0,i.kt)("inlineCode",{parentName:"p"},"nums"),", and two arrays of ",(0,i.kt)("inlineCode",{parentName:"p"},"m")," integers each, ",(0,i.kt)("inlineCode",{parentName:"p"},"l")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"r"),", representing the ",(0,i.kt)("inlineCode",{parentName:"p"},"m")," range queries, where the ",(0,i.kt)("inlineCode",{parentName:"p"},"ith")," query is the range ",(0,i.kt)("inlineCode",{parentName:"p"},"[l[i], r[i]]"),". All the arrays are ",(0,i.kt)("strong",{parentName:"p"},"0-indexed"),"."),(0,i.kt)("p",null,"Return ",(0,i.kt)("em",{parentName:"p"},"a list of"),(0,i.kt)("inlineCode",{parentName:"p"},"boolean")," ",(0,i.kt)("em",{parentName:"p"},"elements")," ",(0,i.kt)("inlineCode",{parentName:"p"},"answer"),(0,i.kt)("em",{parentName:"p"},", where")," ",(0,i.kt)("inlineCode",{parentName:"p"},"answer[i]")," ",(0,i.kt)("em",{parentName:"p"},"is")," ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," ",(0,i.kt)("em",{parentName:"p"},"if the subarray")," ",(0,i.kt)("inlineCode",{parentName:"p"},"nums[l[i]], nums[l[i]+1], ... , nums[r[i]]"),(0,i.kt)("em",{parentName:"p"},"can be ",(0,i.kt)("strong",{parentName:"em"},"rearranged")," to form an ",(0,i.kt)("strong",{parentName:"em"},"arithmetic")," sequence, and")," ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," ",(0,i.kt)("em",{parentName:"p"},"otherwise.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: nums = [4,6,5,9,3,7], l = [0,0,2], r = [2,3,5]\nOutput: [true,false,true]\nExplanation:\nIn the 0th query, the subarray is [4,6,5]. This can be rearranged as [6,5,4], which is an arithmetic sequence.\nIn the 1st query, the subarray is [4,6,5,9]. This cannot be rearranged as an arithmetic sequence.\nIn the 2nd query, the subarray is [5,9,3,7]. This can be rearranged as [3,5,7,9], which is an arithmetic sequence.\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]\nOutput: [false,true,false,false,true,true]\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"n == nums.length")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"m == l.length")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"m == r.length")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"2 <= n <= 500")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= m <= 500")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0 <= l[i] < r[i] < n")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-10 ^ 5 <= nums[i] <= 10 ^ 5"))),(0,i.kt)("h2",{id:"approach-1-brute-force"},"Approach 1: Brute Force"),(0,i.kt)(u,{mdxType:"Tabs"},(0,i.kt)(c,{value:"elixir",label:"Elixir",mdxType:"TabItem"},(0,i.kt)(d,{name:"@jit",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-elixir"},"@spec check_arithmetic_subarrays(nums :: [integer], l :: [integer], r :: [integer]) :: [boolean]\n# A fairly naive solution:\ndef check_arithmetic_subarrays(nums, l, r) do\n  Enum.zip_with(l, r, fn ll, rr ->\n    nums |> Enum.slice(ll..rr) |> Enum.sort() |> is_arith?()\n  end)\nend\n\ndefp is_arith?([a | [b | rest] = tl]) do\n  diff = a - b\n  Enum.zip_with(tl, rest, &-/2) |> Enum.all?(&(&1 == diff))\nend\n  \ndefp is_arith?(_), do: true\n")))),(0,i.kt)("h2",{id:"approach-2-mos-algorithm"},"Approach 2: Mo's Algorithm"),(0,i.kt)(u,{mdxType:"Tabs"},(0,i.kt)(c,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)(d,{name:"@martin0327",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"using ti3 = tuple<int,int,int>;\nconst int inf = 1e9;\n\nclass Solution {\npublic:\n    vector<bool> checkArithmeticSubarrays(vector<int>& a, vector<int>& ql, vector<int>& qr) {\n        int n = a.size(), q = ql.size(), sz = sqrt(n);\n        map<int,vector<ti3>> mo;\n        for (int i=0; i<q; i++) {\n            int l = ql[i], r = qr[i];\n            mo[l/sz].push_back({r,l,i});\n        }\n        \n        int i=0, j=0, mul = 0;\n        map<int,int> mp1, mp2;\n        mp1[a[0]]++;\n\n        auto inc1 = [&] (int x) { if (++mp1[x] == 2) mul++; };\n        auto dec1 = [&] (int x) {\n            if (mp1[x] == 2) mul--;\n            if (--mp1[x] == 0) mp1.erase(x);\n        }; \n        auto inc2 = [&] (int x) { mp2[x]++; };\n        auto dec2 = [&] (int x) { if (--mp2[x] == 0) mp2.erase(x); };\n        \n        auto lr = [&] (int x) {\n            auto it1 = mp1.lower_bound(x);\n            auto it2 = mp1.upper_bound(x);\n            int l = (it1 == mp1.begin()) ? inf : prev(it1)->first;\n            int r = (it2 == mp1.end()) ? inf : it2->first;\n            return make_pair(l,r);\n        };\n\n        auto push = [&] (int x) {\n            auto [l,r] = lr(x);\n            if (!mp1.count(x)) {\n                if (l != inf) inc2(x-l);\n                if (r != inf) inc2(r-x);\n                if (l != inf && r != inf) dec2(r-l);\n            }\n            inc1(x);\n        };\n\n        auto pop = [&] (int x) {\n            auto [l,r] = lr(x);\n            if (mp1[x] == 1) {\n                if (l != inf) dec2(x-l);\n                if (r != inf) dec2(r-x);\n                if (l != inf && r != inf) inc2(r-l);\n            }\n            dec1(x);\n        };\n        \n        vector<bool> ans(q);\n        for (auto &[_,rli] : mo) {\n            sort(rli.begin(), rli.end());\n            for (auto [r,l,idx] : rli) {\n                while (i!=l || j!=r) {\n                    if (r>j) push(a[++j]);\n                    else if (l<i) push(a[--i]);\n                    else if (r<j) pop(a[j--]);\n                    else if (l>i) pop(a[i++]);\n                }\n                if (mul+mp2.size()==1) ans[idx] = 1;\n            }\n        }\n        return ans;\n    }\n}; \n")))),(0,i.kt)("h2",{id:"approach-3-rmq"},"Approach 3: RMQ"),(0,i.kt)(u,{mdxType:"Tabs"},(0,i.kt)(c,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)(d,{name:"@heder",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"static int fast_io = []() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); return 0; }();\n\n// Using sparse table, see https://www.youtube.com/watch?v=0jWeUdxrGm4\nclass RangeMinMaxQuery {\nprivate:\n    vector<vector<pair<int, int>>> m_;\n\npublic:\n    RangeMinMaxQuery(vector<int>& nums)\n        : m_(bin_log(size(nums)) + 1, vector<pair<int, int>>(size(nums))) {\n        transform(begin(nums), end(nums), begin(m_[0]),\n                  [](int x) { return make_pair(x, x); });\n        \n        for (int k = 1; k < size(m_); ++k) {\n            for (int i = 0; i + (1 << k) - 1 < size(nums); ++i) {\n                const auto& p1 = m_[k - 1][i];\n                const auto& p2 = m_[k - 1][i + (1 << (k - 1))];\n                m_[k][i] = make_pair(\n                    min(p1.first, p2.first),\n                    max(p1.second, p2.second));\n            }\n        }\n    }\n    \n    pair<int, int> query(int l, int r) {\n        const int len = r - l + 1;\n        const int k = bin_log(len);\n        const auto& p1 = m_[k][l];\n        const auto& p2 = m_[k][r - (1 << k) + 1];\n        return make_pair(\n            min(p1.first, p2.first),\n            max(p1.second, p2.second));   \n    }\n\nprivate:\n    static constexpr int bin_log(int n) {\n        return 31 - __builtin_clz(n);\n    }\n};\n\nclass Solution {\npublic:\n    vector<bool> checkArithmeticSubarrays(vector<int>& nums, vector<int>& ls, vector<int>& rs) {\n        RangeMinMaxQuery rmq(nums);\n        \n        const int m = size(ls);\n        vector<bool> ans;\n        for (int i = 0; i < m; ++i) {\n            const int l = ls[i];\n            const int r = rs[i];\n            const int len = r - l + 1;\n            if (len <= 2) {\n                ans.push_back(true);\n                continue;\n            }\n            \n            const auto [mn, mx] = rmq.query(l, r);\n            const int d = (mx - mn) / (len - 1);\n            \n            if (mn == mx) {\n                ans.push_back(true);\n            } else if ((mx - mn) % (len -1)) {\n                ans.push_back(false);\n            } else {\n                bitset<512> seen;;\n                int j;\n                for (j = l; j <= r; ++j) {\n                    if ((nums[j] - mn) % d || seen[(nums[j] - mn) / d])\n                        break;\n                    seen[(nums[j] - mn) / d] = true;\n                }\n                ans.push_back(j > r);\n            }\n        }\n        return ans;\n    }\n};\n")))))}k.isMDXComponent=!0}}]);