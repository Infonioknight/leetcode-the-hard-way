"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[4280],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),h=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=h(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=h(n),d=r,m=c["".concat(l,".").concat(d)]||c[d]||u[d]||i;return n?a.createElement(m,s(s({ref:t},p),{},{components:n})):a.createElement(m,s({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[c]="string"==typeof e?e:r,s[1]=o;for(var h=2;h<i;h++)s[h]=n[h];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},78227:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>w,frontMatter:()=>i,metadata:()=>o,toc:()=>h});var a=n(87462),r=(n(67294),n(3905));const i={description:"Author: @vigneshshiv, @MithunPrabhu777, @AnshikaAnand222, @radojicic23 | https://leetcode.com/problems/longest-substring-without-repeating-characters/",tags:["Hash Table","String","Sliding Window"]},s="0003 - Longest Substring Without Repeating Characters (Medium)",o={unversionedId:"0000-0099/longest-substring-without-repeating-characters-medium",id:"0000-0099/longest-substring-without-repeating-characters-medium",title:"0003 - Longest Substring Without Repeating Characters (Medium)",description:"Author: @vigneshshiv, @MithunPrabhu777, @AnshikaAnand222, @radojicic23 | https://leetcode.com/problems/longest-substring-without-repeating-characters/",source:"@site/solutions/0000-0099/0003-longest-substring-without-repeating-characters-medium.md",sourceDirName:"0000-0099",slug:"/0000-0099/longest-substring-without-repeating-characters-medium",permalink:"/solutions/0000-0099/longest-substring-without-repeating-characters-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0000-0099/0003-longest-substring-without-repeating-characters-medium.md",tags:[{label:"Hash Table",permalink:"/solutions/tags/hash-table"},{label:"String",permalink:"/solutions/tags/string"},{label:"Sliding Window",permalink:"/solutions/tags/sliding-window"}],version:"current",sidebarPosition:3,frontMatter:{description:"Author: @vigneshshiv, @MithunPrabhu777, @AnshikaAnand222, @radojicic23 | https://leetcode.com/problems/longest-substring-without-repeating-characters/",tags:["Hash Table","String","Sliding Window"]},sidebar:"tutorialSidebar",previous:{title:"0002 - Add Two Numbers (Medium)",permalink:"/solutions/0000-0099/add-two-numbers-medium"},next:{title:"0004 - Median of Two Sorted Arrays",permalink:"/solutions/0000-0099/median-of-two-sorted-arrays-hard"}},l={},h=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: HashSet with One Iteration",id:"approach-1-hashset-with-one-iteration",level:2},{value:"Approach 2: Sliding Window with ASCII",id:"approach-2-sliding-window-with-ascii",level:2}],p=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",t)},c=p("Tabs"),u=p("TabItem"),d=p("SolutionAuthor"),m={toc:h},g="wrapper";function w(e){let{components:t,...n}=e;return(0,r.kt)(g,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"0003---longest-substring-without-repeating-characters-medium"},"0003 - Longest Substring Without Repeating Characters (Medium)"),(0,r.kt)("h2",{id:"problem-link"},"Problem Link"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/longest-substring-without-repeating-characters/"},"https://leetcode.com/problems/longest-substring-without-repeating-characters/")),(0,r.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.kt)("p",null,"Given a string ",(0,r.kt)("inlineCode",{parentName:"p"},"s"),", find the length of the ",(0,r.kt)("strong",{parentName:"p"},"longest substring")," without repeating characters."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Input: s = "abcabcbb"\nOutput: 3\nExplanation: The answer is "abc", with the length of 3.\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Input: s = "bbbbb"\nOutput: 1\nExplanation: The answer is "b", with the length of 1.\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 3:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Input: s = "pwwkew"\nOutput: 3\nExplanation: The answer is "wke", with the length of 3.\nNotice that the answer must be a substring, "pwke" is a subsequence and not a substring.\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Constraints:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"0 <= s.length <= 5 * 10^4")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"s")," consists of English letters, digits, symbols and spaces.")),(0,r.kt)("h2",{id:"approach-1-hashset-with-one-iteration"},"Approach 1: HashSet with One Iteration"),(0,r.kt)("p",null,"Two pointer ",(0,r.kt)("em",{parentName:"p"},"i")," and ",(0,r.kt)("em",{parentName:"p"},"j"),", initially at the start of the string. Move right (j++) till distinct characters and store them in set.\nIf repeated character occurs then move left (i++) until that repeated character is occured in left, and also remove all characters that occur before that character including character itself from set. This helps to maintain Set with longest substring. "),(0,r.kt)("p",null,"Time complexity: $O(n)$, where $n$ - # of characters in the string"),(0,r.kt)("p",null,"Space complexity: $O(s)$, where $s$ is the longest substring"),(0,r.kt)(c,{mdxType:"Tabs"},(0,r.kt)(u,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)(d,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if (s == null || s.length() == 0) return 0;\n        int i = 0, j = 0, max = 0;\n        Set<Character> seen = new HashSet<>();\n        while (j < s.length()) {\n            if (seen.add(s.charAt(j))) {\n                max = Math.max(max, seen.size());\n                j += 1;\n            } else {\n                seen.remove(s.charAt(i++));\n            }\n        }\n        return max;\n    }\n}\n"))),(0,r.kt)(u,{value:"javascript",label:"JavaScript",mdxType:"TabItem"},(0,r.kt)(d,{name:"@MithunPrabhu777",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"var lengthOfLongestSubstring = function (s) {\n    const letterCountMap = new Map();\n\n    // Destructuring assignment syntax is a JavaScript expression that pulls out values from array\n    // Here we are assigning initial values to variables\n    let [left, right, max] = [0, 0, 0];\n\n    while (right < s.length) {\n        const currentValue = s[right];\n        const canSlide = letterCountMap.has(currentValue);\n\n        // We can slide left pointer only when we find duplicate number from map\n        if (canSlide) {\n            const rightSlide = letterCountMap.get(currentValue) + 1;\n            left = Math.max(left, rightSlide);\n        }\n\n        // We are finding window from left to right of non repeating characters\n        const window = (right - left) + 1;\n        max = Math.max(window, max);\n        letterCountMap.set(currentValue, right);\n        right++;\n    }\n\n    return max;\n};\n"))),(0,r.kt)(u,{value:"python",label:"Python",mdxType:"TabItem"},(0,r.kt)(d,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        # initiate variables, left pointer of our window, right pointer of \n        # our window, and longest to track longest length of our window.\n        l, r, longest = 0,0,0\n        # create a hash set for O(1) access of letters inside our window.\n        window = set()\n        # While loop to expand right side of our sliding window.\n        while r < len(s):\n            # character @ right isn't in window, add it to the window.\n            if s[r] not in window:\n                # add character to the window set.\n                window.add(s[r])\n                # update our longest \n                # note: we add 1 as a window of size 1, will share indexes,\n                # ex. 0-0 = 0.\n                longest = max(longest, (r-l)+1)\n                # slide right side of our window forward.\n                r += 1\n            # else handles the condition of the character is in our window set.\n            # so we remove the left character and slide left side pointer forward.\n            # If the left isn't the repeating digit, it will be handled by this condition\n            # as the if statement will be false again, so we will return here to continually\n            # pop left character until we have a non-duplicate unique character set.\n            else:\n                # remove left character of window\n                window.remove(s[l])\n                # move left side of window forward.\n                l += 1\n        # return answer.\n        return longest\n"))),(0,r.kt)(u,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)(d,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        // initialize hashSet\n        unordered_set<int> hashSet;\n        // left and right pointer at position 0\n        // ans - track max length of window (substring)\n        int l = 0, r = 0, ans = 0;\n        // right pointer going through every character\n        while (r < s.length()) {\n            // if character is not in hashSet\n            if (!hashSet.count(s[r])) {\n                // add it \n                hashSet.insert(s[r]);\n                // update window size \n                ans = max(ans, r - l + 1);\n                // shift right pointer\n                r++;\n            } else {\n                // delete character at left pointer position\n                hashSet.erase(s[l]);\n                //shift left pointer\n                l++;\n            }\n        }\n        // return result\n        return ans;\n    }    \n};\n")))),(0,r.kt)("h2",{id:"approach-2-sliding-window-with-ascii"},"Approach 2: Sliding Window with ASCII"),(0,r.kt)("p",null,"We can solve this problem with Sliding Window and Two pointers ",(0,r.kt)("em",{parentName:"p"},"i")," and ",(0,r.kt)("em",{parentName:"p"},"j"),". Iterate over the string, keep moving the 2nd pointer ",(0,r.kt)("em",{parentName:"p"},"j")," forward until the character is not matched with ",(0,r.kt)("em",{parentName:"p"},"i")," th character. "),(0,r.kt)("p",null,"Since the input, may contain ",(0,r.kt)("inlineCode",{parentName:"p"},"English letters, digits, symbols and spaces"),", so maintain the ",(0,r.kt)("a",{parentName:"p",href:"https://bluesock.org/~willg/dev/ascii.html"},"ASCII")," char array of size 128. "),(0,r.kt)("p",null,"If any of the character occur more than once, then break the loop and find the difference of ",(0,r.kt)("em",{parentName:"p"},"j")," and ",(0,r.kt)("em",{parentName:"p"},"i")," and that's the longest substring length. "),(0,r.kt)("p",null,"Time complexity: $O(n)$, where $n$ - # of characters in the string. Since both ",(0,r.kt)("em",{parentName:"p"},"i")," and ",(0,r.kt)("em",{parentName:"p"},"j")," moving in one direction and it's total is $O(2n)$, constants are ignored, so it's $O(n)$."),(0,r.kt)("p",null,"Space complexity: $O(1)$ extra space, size of 128 ASCII chars for each iteration, considered as constant space."),(0,r.kt)(c,{mdxType:"Tabs"},(0,r.kt)(u,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)(d,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if (s == null || s.length() == 0) return 0;\n        if (s.length() == 1) return 1;\n        int max = 0;\n        for (int idx = 0; idx < s.length() - 1; idx++) {\n            int[] seen = new int[128];\n            int i = idx, j = idx + 1;\n            while (j < s.length() && s.charAt(i) != s.charAt(j)) {\n                if (seen[s.charAt(j)] > 0) break;\n                seen[s.charAt(j)]++;\n                j++;\n            }\n            max = Math.max(max, j - i);\n        }\n        return max;\n    }\n}\n"))),(0,r.kt)(u,{value:"javascript",label:"JavaScript",mdxType:"TabItem"},(0,r.kt)(d,{name:"@AnshikaAnand222",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"var lengthOfLongestSubstring = function(s) {\n  const set = new Set();\n  let start = 0;\n  let maxSize = 0;\n  for (let i=0; i < s.length; i++) {\n    const c = s.charAt(i);\n    // keep remove character not in the non-repetitive substring\n    while (set.has(c)) {\n      set.delete(s.charAt(start))\n      start += 1;\n    }\n    maxSize = Math.max(maxSize, i - start + 1);    \n    set.add(c);     \n  }  \n  return maxSize;\n};\n"))),(0,r.kt)(u,{value:"python",label:"Python",mdxType:"TabItem"},(0,r.kt)(d,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        # HashSet\n        char_set = set()\n        # left pointer at position zero\n        l = 0  \n        res = 0\n        # Right pointer is going through every char\n        for r in range(len(s)):\n            # If we get to a duplicate\n            while s[r] in char_set:\n                # Remove left most\n                char_set.remove(s[l])\n                # Shift left pointer by one\n                l += 1  \n            char_set.add(s[r])\n            # If the current window size is greater than what it's now\n            # Update\n            res = max(res, r - l + 1)\n        return res\n"))),(0,r.kt)(u,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)(d,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        // initialize hashSet\n        unordered_set<char> hashSet;\n        int ans = 0;\n        // left pointer at position 0\n        int l = 0;\n        // right pointer going through every char\n        for (int r = 0; r < s.length(); r++) {\n            // if we get to a duplicate\n            while (hashSet.count(s[r])) {\n                // remove left most\n                hashSet.erase(s[l]);\n                l++;\n            }\n            hashSet.insert(s[r]);\n            // update window size  \n            ans = max(ans, r - l + 1);\n        }\n        return ans;\n    }    \n};\n")))))}w.isMDXComponent=!0}}]);