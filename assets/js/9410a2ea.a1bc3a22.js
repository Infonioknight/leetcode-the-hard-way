"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[30917],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return h}});var o=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var m=o.createContext({}),l=function(e){var n=o.useContext(m),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=l(e.components);return o.createElement(m.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},p=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,m=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=l(t),h=r,d=p["".concat(m,".").concat(h)]||p[h]||c[h]||a;return t?o.createElement(d,s(s({ref:n},u),{},{components:t})):o.createElement(d,s({ref:n},u))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,s=new Array(a);s[0]=p;var i={};for(var m in n)hasOwnProperty.call(n,m)&&(i[m]=n[m]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var l=2;l<a;l++)s[l]=t[l];return o.createElement.apply(null,s)}return o.createElement.apply(null,t)}p.displayName="MDXCreateElement"},26308:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return m},default:function(){return b},frontMatter:function(){return i},metadata:function(){return l},toc:function(){return c}});var o=t(87462),r=t(63366),a=(t(67294),t(3905)),s=["components"],i={description:"Author: @wingkwong | https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/",tags:["Depth-First Search","Union Find","Graph"]},m="0947 - Most Stones Removed with Same Row or Column (Medium)",l={unversionedId:"0900-0999/most-stones-removed-with-same-row-or-column-medium",id:"0900-0999/most-stones-removed-with-same-row-or-column-medium",title:"0947 - Most Stones Removed with Same Row or Column (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/",source:"@site/solutions/0900-0999/0947-most-stones-removed-with-same-row-or-column-medium.md",sourceDirName:"0900-0999",slug:"/0900-0999/most-stones-removed-with-same-row-or-column-medium",permalink:"/leetcode-the-hard-way/solutions/0900-0999/most-stones-removed-with-same-row-or-column-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0900-0999/0947-most-stones-removed-with-same-row-or-column-medium.md",tags:[{label:"Depth-First Search",permalink:"/leetcode-the-hard-way/solutions/tags/depth-first-search"},{label:"Union Find",permalink:"/leetcode-the-hard-way/solutions/tags/union-find"},{label:"Graph",permalink:"/leetcode-the-hard-way/solutions/tags/graph"}],version:"current",sidebarPosition:947,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/",tags:["Depth-First Search","Union Find","Graph"]},sidebar:"tutorialSidebar",previous:{title:"0946 - Validate Stack Sequences (Medium)",permalink:"/leetcode-the-hard-way/solutions/0900-0999/validate-stack-sequences-medium"},next:{title:"0948 - Bag of Tokens (Medium)",permalink:"/leetcode-the-hard-way/solutions/0900-0999/bag-of-tokens-medium"}},u={},c=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: DSU",id:"approach-1-dsu",level:2}],p=function(e){return function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",n)}},h=p("Tabs"),d=p("TabItem"),f=p("SolutionAuthor"),w={toc:c};function b(e){var n=e.components,t=(0,r.Z)(e,s);return(0,a.kt)("wrapper",(0,o.Z)({},w,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"0947---most-stones-removed-with-same-row-or-column-medium"},"0947 - Most Stones Removed with Same Row or Column (Medium)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/"},"https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"On a 2D plane, we place ",(0,a.kt)("inlineCode",{parentName:"p"},"n")," stones at some integer coordinate points. Each coordinate point may have at most one stone."),(0,a.kt)("p",null,"A stone can be removed if it shares either ",(0,a.kt)("strong",{parentName:"p"},"the same row or the same column")," as another stone that has not been removed."),(0,a.kt)("p",null,"Given an array ",(0,a.kt)("inlineCode",{parentName:"p"},"stones")," of length ",(0,a.kt)("inlineCode",{parentName:"p"},"n")," where ",(0,a.kt)("inlineCode",{parentName:"p"},"stones[i] = [xi, yi]")," represents the location of the ",(0,a.kt)("inlineCode",{parentName:"p"},"ith")," stone, return ",(0,a.kt)("em",{parentName:"p"},"the largest possible number of stones that can be removed"),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]\nOutput: 5\nExplanation: One way to remove 5 stones is as follows:\n1. Remove stone [2,2] because it shares the same row as [2,1].\n2. Remove stone [2,1] because it shares the same column as [0,1].\n3. Remove stone [1,2] because it shares the same row as [1,0].\n4. Remove stone [1,0] because it shares the same column as [0,0].\n5. Remove stone [0,1] because it shares the same row as [0,0].\nStone [0,0] cannot be removed since it does not share a row/column with another stone still on the plane.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]\nOutput: 3\nExplanation: One way to make 3 moves is as follows:\n1. Remove stone [2,2] because it shares the same row as [2,0].\n2. Remove stone [2,0] because it shares the same column as [0,0].\n3. Remove stone [0,2] because it shares the same row as [0,0].\nStones [0,0] and [1,1] cannot be removed since they do not share a row/column with another stone still on the plane.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 3:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: stones = [[0,0]]\nOutput: 0\nExplanation: [0,0] is the only stone on the plane, so you cannot remove it.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= stones.length <= 1000")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"0 <= xi, yi <= 10^4")),(0,a.kt)("li",{parentName:"ul"},"No two stones are at the same coordinate point.")),(0,a.kt)("h2",{id:"approach-1-dsu"},"Approach 1: DSU"),(0,a.kt)(h,{mdxType:"Tabs"},(0,a.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(f,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// retrieved from https://wingkwong.github.io/leetcode-the-hard-way/tutorials/graph-theory/disjoint-set-union\nclass dsu {\n public:\n  vector<int> root, rank;\n  int n;\n  int cnt;\n\n  dsu(int _n) : n(_n) {\n    root.resize(n);\n    rank.resize(n);\n    for(int i = 0; i < n; i++) {\n        root[i] = i;\n        rank[i] = 1;\n    }\n    cnt = n;\n  }\n\n  inline int getCount() { return cnt; }\n\n  inline int get(int x) { return (x == root[x] ? x : (root[x] = get(root[x]))); }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n        if (rank[x] > rank[y]) {\n            root[y] = x;\n        } else if (rank[x] < rank[y]) {\n            root[x] = y;\n        } else {\n            root[y] = x;\n            rank[x] += 1;\n        }\n        cnt--;\n      return true;\n    }\n    return false;\n  }\n};\n\n// idea: \n// if two stones shares the same row or the same column, \n// we can use DSU to unite them together so that they are in the same group\n// for each group, we want to keep at least 1 stone (i.e. others will be removed)\n// hence, the answer is just the total count - the number of the connected components\nclass Solution {\npublic:\n    int removeStones(vector<vector<int>>& stones) {\n        int n = (int) stones.size();\n        // init dsu\n        dsu d = dsu(n);\n        // iterate all pairs\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // if two stones shares the same row or the same column\n                if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {\n                    // unite them together\n                    d.unite(i, j);\n                }\n            }\n        }\n        // the max number of stones that can be removed is simply\n        // the total count - the number of the connected components\n        return n - d.getCount();\n    }\n};\n")),(0,a.kt)(f,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    vector<int> parent;\n    int find(int x) {\n        return parent[x] == x ? x : find(parent[x]);\n    }\n    \n    int removeStones(vector<vector<int>>& stones) {\n        int n = (int) stones.size();\n        parent.resize(n + 1, 0);\n        // at the beginning, each element is in its own group\n        for(int i = 0; i <= n; i++) parent[i] = i;\n        // iterate each pair\n        for(int i = 0; i < n; i++) {\n            for(int j = i + 1; j < n; j++) {\n                // if two stones shares the same row or the same column\n                if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) {\n                    // get the root of `i`\n                    int a = find(i);\n                    // get the root of `j`\n                    int b = find(j);\n                    // if they don't belong to the same group, unite them together\n                    if(a != b) parent[b] = a;\n                }\n            }\n        }\n        int connected = 0;\n        // if `i` is the root, then we found a new connected component\n        for(int i = 0; i < n; i++) connected += parent[i] == i;\n        // the max number of stones that can be removed is simply\n        // the total count - the number of the connected components\n        return n - connected;\n    }\n};\n")))))}b.isMDXComponent=!0}}]);