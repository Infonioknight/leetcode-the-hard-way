"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[65053],{3905:(e,n,t)=>{t.d(n,{Zo:()=>h,kt:()=>m});var i=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)t=o[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=i.createContext({}),c=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},h=function(e){var n=c(e.components);return i.createElement(l.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},u=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),d=c(t),u=r,m=d["".concat(l,".").concat(u)]||d[u]||p[u]||o;return t?i.createElement(m,a(a({ref:n},h),{},{components:t})):i.createElement(m,a({ref:n},h))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,a=new Array(o);a[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[d]="string"==typeof e?e:r,a[1]=s;for(var c=2;c<o;c++)a[c]=t[c];return i.createElement.apply(null,a)}return i.createElement.apply(null,t)}u.displayName="MDXCreateElement"},15416:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>b,frontMatter:()=>o,metadata:()=>s,suggestedProblems:()=>h,toc:()=>c});var i=t(87462),r=(t(67294),t(3905));const o={title:"Tarjan's Algorithm",description:"Tarjan's algorithm can be used to determine the Strongly Connected Components of a directed graph.",hide_table_of_contents:!1,keywords:["leetcode","tutorial","targan's algorithm","algorithm"]},a=void 0,s={unversionedId:"graph-theory/tarjans-algorithm",id:"graph-theory/tarjans-algorithm",title:"Tarjan's Algorithm",description:"Tarjan's algorithm can be used to determine the Strongly Connected Components of a directed graph.",source:"@site/tutorials/graph-theory/tarjans-algorithm.md",sourceDirName:"graph-theory",slug:"/graph-theory/tarjans-algorithm",permalink:"/tutorials/graph-theory/tarjans-algorithm",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/graph-theory/tarjans-algorithm.md",tags:[],version:"current",frontMatter:{title:"Tarjan's Algorithm",description:"Tarjan's algorithm can be used to determine the Strongly Connected Components of a directed graph.",hide_table_of_contents:!1,keywords:["leetcode","tutorial","targan's algorithm","algorithm"]},sidebar:"tutorialSidebar",previous:{title:"Minimum Spanning Tree",permalink:"/tutorials/graph-theory/minimum-spanning-tree"},next:{title:"Topological Sorting",permalink:"/tutorials/graph-theory/topological-sorting"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Using Tarjan&#39;s algorithm to find bridges in a Undirected Graph",id:"using-tarjans-algorithm-to-find-bridges-in-a-undirected-graph",level:2},{value:"Example #1: 1192 - Critical Connections in a Network",id:"example-1-1192---critical-connections-in-a-network",level:3},{value:"Using Tarjan&#39;s algorithm to find articulation points in a Undirected Graph",id:"using-tarjans-algorithm-to-find-articulation-points-in-a-undirected-graph",level:2},{value:"Example #2: 1568 - Minimum Number of Days to Disconnect Island",id:"example-2-1568---minimum-number-of-days-to-disconnect-island",level:3},{value:"References",id:"references",level:2}],h=[{problemName:"1489 - Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree",difficulty:"Hard",leetCodeLink:"https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree",solutionLink:""}],d=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",n)},p=d("TutorialAuthors"),u=d("Contributors"),m=d("Tabs"),g=d("TabItem"),f=d("Table"),v={toc:c,suggestedProblems:h},k="wrapper";function b(e){let{components:n,...t}=e;return(0,r.kt)(k,(0,i.Z)({},v,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)(p,{names:"@BlackPanther112358",mdxType:"TutorialAuthors"}),(0,r.kt)(u,{names:"@wingkwong",mdxType:"Contributors"}),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"Tarjan's Algorithm is popular algorithm for finding the Strongly Connected Components (SCC) of a directed graph. In the below graph, the nodes in a blue envelope constitute a single connected component as any node $u$ as a path to another node $v$ and vice versa. Note that while we can reach the node $f$ from the node $e$, the opposite is not true. Hence, $f$ and $e$ are not part of the same component. Thus, the following graph has 3 strongly connected components as highlighted. A single strongly connected component can be formally described as maximal set of vertices such that for any 2 vertices belonging to the set, say $u$ and $v$, there exists a path from $u$ to $v$ and vice versa."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/83649829/198752836-3c43a6f4-e1e2-445e-b679-0df4cb8ff3e0.png",alt:"image"}),"$","\\","$\n",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Strongly_connected_component"},"Source: Strongly connected component from Wikipedia")),(0,r.kt)("p",null,"In this tutorial we will discuss the Tarjan's Algorithm to find SCC."),(0,r.kt)("h2",{id:"implementation"},"Implementation"),(0,r.kt)("p",null,"The algorithm works by using a single ",(0,r.kt)("a",{parentName:"p",href:"../../tutorials/graph-theory/depth-first-search"},"DFS")," in the graph. To understand its working first let's define a few standard terms :"),(0,r.kt)("p",null,"$in-time(u) =$ time at which node $u$ was reached for the first time or the in time of DFS for the node."),(0,r.kt)("p",null,"$low-link(u) =$ smallest time reachable of a node reachable from the DFS subtree of node u"),(0,r.kt)("p",null,"We also need to ensure that we don't mix 2 different SCC's due to a cross-edge between them. To counter this issue, we will use a stack to store the nodes which have not been assigned to an SCC and have been visited so far."),(0,r.kt)("p",null,"Thus, whenever we find an SCC, we will pop the corresponding nodes from the stack."),(0,r.kt)("p",null,"We will call the first node we discovered of an SCC the route node for sake of simplicity. Thus, we will identify the SCC by its root node. To check when we have reached a root node, we just check if $low(u)$ and $in_time(u)$ are equal."),(0,r.kt)("p",null,"The pseudo-code for the algorithm can be found ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm#The_algorithm_in_pseudocode"},"here"),"."),(0,r.kt)("p",null,"The Time and Space Complexity of the algorithm is $O(V + E)$, where $V$ represents the number of vertices and $E$ represents the number of edges, same as that os DFS."),(0,r.kt)("p",null,"The implementation of above can be as follows (along with above graph as example) :"),(0,r.kt)(m,{mdxType:"Tabs"},(0,r.kt)(g,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <bits/stdc++.h>\nusing namespace std;\n\nstruct find_SCC {\n  int timer = 0;\n  // store the in-time for DFS search\n  vector<int> in_time;\n  // stores the low-link value for every node\n  vector<int> low_link;\n  // checks whether a node is on the stack or not\n  vector<bool> on_stack;\n  // stack to store the currently available nodes\n  stack<int> stk;\n  // to store the final answer\n  vector<vector<int>> res;\n\n  // recursive function to do the DFS search on the graph\n  void dfs(int u, vector<vector<int>> &graph) {\n    // set the values for in_time and low_link, and put the node on stack\n    in_time[u] = low_link[u] = timer;\n    timer++;\n    stk.push(u);\n    on_stack[u] = true;\n\n    // DFS to neighbours of current node\n    for (int v : graph[u]) {\n      // if the node is unvisited\n      if (in_time[v] == -1) {\n        dfs(v, graph);\n        // update the low-link value for node u\n        low_link[u] = min(low_link[u], low_link[v]);\n        // else if the node was visited before, and is still on the stack\n      } else if (on_stack[v]) {\n        // update the low-link for node u\n        low_link[u] = min(low_link[u], in_time[v]);\n      }\n    }\n\n    // check if u is the root node for a SCC\n    if (low_link[u] == in_time[u]) {\n      vector<int> SCC;\n      // all the nodes above u in the stack are in SCC of u\n      while (stk.top() != u) {\n        int v = stk.top();\n        stk.pop();\n        SCC.push_back(v);\n        on_stack[v] = false;\n      }\n      // now removing u from stack and adding it to the SCC\n      stk.pop();\n      SCC.push_back(u);\n      on_stack[u] = false;\n\n      // adding the SCC to the answer\n      res.push_back(SCC);\n    }\n\n    return;\n  }\n\n  // takes input of graph as adjacency list and returns the SCC of graph as\n  // vectors\n  vector<vector<int>> tarjans(vector<vector<int>> &adjacencyList) {\n    int n = adjacencyList.size();\n    in_time.resize(n, -1);\n    low_link.resize(n, -1);\n    on_stack.resize(n, false);\n\n    for (int u = 0; u < n; u++) {\n      if (in_time[u] == -1) dfs(u, adjacencyList);\n    }\n\n    return res;\n  }\n};\n\nint main() {\n  // constructing adjacency list for example graph shown, mapping node a to 0, b\n  // to 1 and so on...\n  vector<vector<int>> graph(8);\n  graph[0].push_back(1);\n  graph[1].push_back(2);\n  graph[1].push_back(4);\n  graph[1].push_back(5);\n  graph[2].push_back(3);\n  graph[2].push_back(6);\n  graph[3].push_back(2);\n  graph[3].push_back(7);\n  graph[4].push_back(0);\n  graph[4].push_back(5);\n  graph[5].push_back(6);\n  graph[6].push_back(5);\n  graph[7].push_back(3);\n  graph[7].push_back(6);\n\n  // using the tarjan\'s algo\n  find_SCC t = find_SCC();\n  vector<vector<int>> res = t.tarjans(graph);\n\n  // output the final result\n  cout << "The Strongly Connected Components for the graph are:" << endl;\n  for (vector<int> i : res) {\n    for (int j : i) {\n      cout << (char)(\'a\' + j) << " ";\n    }\n    cout << endl;\n  }\n\n  /*\n  output of the above code is:\n  The Strongly Connected Components for the graph are:\n  f g\n  h d c\n  e b a\n  */\n\n  return 0;\n}\n')))),(0,r.kt)("p",null,"We can further cluster all the nodes belonging to an SCC into one node, and represent all the edges from and to a constituent node of the SCC to this new node. The resulting graph is called the ",(0,r.kt)("a",{parentName:"p",href:"https://cp-algorithms.com/graph/strongly-connected-components.html"},"Condensation Graph")),(0,r.kt)("h2",{id:"using-tarjans-algorithm-to-find-bridges-in-a-undirected-graph"},"Using Tarjan's algorithm to find bridges in a Undirected Graph"),(0,r.kt)("p",null,"Here, we are searching in an undirected graph, and also we don't need to remove the cross-edges. Thus, the stack is no longer required. An edge between node $u$ to $v$ will be considered a bridge if there is no other way to reach $v$ from $u$ if the edge is removed. We can check for this by using the properties of the low-link time. If the low-link time of $v$ is less than that of $u$, we can conclude that we can reach $v$ from some other path, otherwise the edge between them is a bridge. Here is an example for same."),(0,r.kt)("h3",{id:"example-1-1192---critical-connections-in-a-network"},"Example #1: ",(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/critical-connections-in-a-network/"},"1192 - Critical Connections in a Network")),(0,r.kt)("p",null,"This problem directly asks us to find bridges in the given graph. The input is provided in form of pairs of nodes with an edge between them. Thus, we will first convert this to an adjacency list and apply the same algorithm discussed above."),(0,r.kt)(m,{mdxType:"Tabs"},(0,r.kt)(g,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\n public:\n  // initializing the variables\n  int timer = 0;\n  vector<int> in_time, low_link;\n  vector<vector<int>> graph;\n  vector<vector<int>> res;\n\n  // recursive function to perform DFS\n  void dfs(int u, int p = -1) {\n    in_time[u] = low_link[u] = timer;\n    timer++;\n\n    for (int v : graph[u]) {\n      // we ignore the parent node\n      if (v == p) continue;\n      // if we discover a new node\n      if (in_time[v] == -1) {\n        dfs(v, u);\n        low_link[u] = min(low_link[u], low_link[v]);\n        // check if the edge is a bridge\n        if (low_link[v] > in_time[u]) {\n          res.push_back({u, v});\n        }\n      } else {\n        // if we visit a node which already has been visited\n        low_link[u] = min(low_link[u], in_time[v]);\n      }\n    }\n\n    return;\n  }\n\n  vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {\n    in_time.resize(n, -1);\n    low_link.resize(n, -1);\n    graph.resize(n);\n\n    // make an adjacency list from the input\n    for (auto connection : connections) {\n      graph[connection[0]].push_back(connection[1]);\n      graph[connection[1]].push_back(connection[0]);\n    }\n\n    // as the entire graph is connected, just call dfs on 0\n    dfs(0);\n\n    return res;\n  }\n};\n")))),(0,r.kt)("h2",{id:"using-tarjans-algorithm-to-find-articulation-points-in-a-undirected-graph"},"Using Tarjan's algorithm to find articulation points in a Undirected Graph"),(0,r.kt)("p",null,"Similar to bridges, articulation points are vertices which if removed will disconnect the graph. Once again, we can modify the Tarjan's algorithm to find such vertices in a given undirected graph."),(0,r.kt)("h3",{id:"example-2-1568---minimum-number-of-days-to-disconnect-island"},"Example #2: ",(0,r.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/"},"1568 - Minimum Number of Days to Disconnect Island")),(0,r.kt)("p",null,"Notice that the answer cannot be more than $2$. Any rectangular shape will have atleast 4 corner cells, and if we remove the vertical neighbour and horizontal neighbour cells of anyone one of these, we have disconnected the graph. Thus, we need to check when the answer can $0$ or $1$, and we are done."),(0,r.kt)("p",null,"The answer will be $0$ if the islands are initially disconnected. This can be checked using basic DFS. The answer will be $1$ when the graph has atleast 1 ",(0,r.kt)("a",{parentName:"p",href:"https://cp-algorithms.com/graph/cutpoints.html"},"articulation point"),". The condition for articulation points is similar to that for finding bridges, except we also check for presence of parents."),(0,r.kt)(m,{mdxType:"Tabs"},(0,r.kt)(g,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\n public:\n  // initializing the variables\n  int n, m, cnt_islands = 0;\n  int timer = 0;\n  vector<vector<int>> in_time, low_link;\n\n  // recursive function to perform DFS, return true if an articulation point is\n  // detected\n  bool dfs(pair<int, int> u, vector<vector<int>>& grid,\n           pair<int, int> p = {-1, -1}) {\n    int i = u.first, j = u.second;\n    in_time[i][j] = low_link[i][j] = timer++;\n    cnt_islands++;\n    // variable to check for articulation point in DFS subtree of the node\n    bool has_articulation_point = false;\n    // variable to count number of children visited first by the node\n    int cnt_children = 0;\n\n    // find all neighbours from the grid\n    vector<pair<int, int>> neighbours;\n    if ((i > 0) && (grid[i - 1][j])) neighbours.push_back({i - 1, j});\n    if ((i < (n - 1)) && (grid[i + 1][j])) neighbours.push_back({i + 1, j});\n    if ((j > 0) && (grid[i][j - 1])) neighbours.push_back({i, j - 1});\n    if ((j < (m - 1)) && (grid[i][j + 1])) neighbours.push_back({i, j + 1});\n\n    for (auto v : neighbours) {\n      // if the neighbour is a parent, ignore it\n      if (v == p) continue;\n      // if the neighbour was already visited\n      else if (in_time[v.first][v.second] != -1)\n        low_link[i][j] = min(low_link[i][j], in_time[v.first][v.second]);\n      // if the neighbour is a new node\n      else {\n        // if the subtree has an articulation point\n        if (dfs(v, grid, u)) has_articulation_point = true;\n        // update the low-link value\n        low_link[i][j] = min(low_link[i][j], low_link[v.first][v.second]);\n        // if the point itself is an articulation point\n        if ((low_link[v.first][v.second] >= in_time[i][j]) &&\n            (p != (pair<int, int>){-1, -1}))\n          has_articulation_point = true;\n        cnt_children++;\n      }\n    }\n\n    // if it has an articulation point, return true\n    if (((p == (pair<int, int>){-1, -1}) && (cnt_children > 1)) ||\n        has_articulation_point)\n      return true;\n    // else return false\n    return false;\n  }\n\n  int minDays(vector<vector<int>>& grid) {\n    n = grid.size();\n    m = grid[0].size();\n    int connected_comp = 0;\n    bool has_articulation_point = false;\n\n    in_time.resize(n, vector<int>(m, -1));\n    low_link.resize(n, vector<int>(m, -1));\n\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        // ignore the cells of grid with water, or who have been visited\n        if ((grid[i][j] == 0) || (in_time[i][j] != -1)) continue;\n        // we already have found a connected component, and this will be a new\n        // one, thus we directly return 0\n        if (connected_comp > 0) return 0;\n        if (dfs({i, j}, grid)) has_articulation_point = true;\n        connected_comp++;\n      }\n    }\n\n    // if there are no cells with land\n    if (cnt_islands == 0) return 0;\n    // if there is only one cell with land\n    else if (cnt_islands == 1)\n      return 1;\n    if (has_articulation_point) return 1;\n    return 2;\n  }\n};\n")))),(0,r.kt)(f,{title:"Suggested Problems",data:h,mdxType:"Table"}),(0,r.kt)("h2",{id:"references"},"References"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"https://www.topcoder.com/thrive/articles/tarjans-algorithm-for-strongly-connected-components"},"Tarjan's Algorithm For Strongly Connected Components")," "),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm"},"Tarjan's strongly connected components algorithm"))))}b.isMDXComponent=!0}}]);