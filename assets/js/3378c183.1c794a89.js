"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[36985],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),c=u(n),h=o,m=c["".concat(s,".").concat(h)]||c[h]||p[h]||a;return n?r.createElement(m,l(l({ref:t},d),{},{components:n})):r.createElement(m,l({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,l=new Array(a);l[0]=h;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[c]="string"==typeof e?e:o,l[1]=i;for(var u=2;u<a;u++)l[u]=n[u];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},34036:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>f,frontMatter:()=>a,metadata:()=>i,toc:()=>u});var r=n(87462),o=(n(67294),n(3905));const a={description:"Author: @ColeB2, @radojicic23 | https://leetcode.com/problems/kth-smallest-element-in-a-bst/",tags:["Tree","Depth-First Search","Binary Search Tree","Binary Tree"]},l="0230 - Kth Smallest Element in a BST (Medium)",i={unversionedId:"0200-0299/kth-smallest-element-in-a-bst-medium",id:"0200-0299/kth-smallest-element-in-a-bst-medium",title:"0230 - Kth Smallest Element in a BST (Medium)",description:"Author: @ColeB2, @radojicic23 | https://leetcode.com/problems/kth-smallest-element-in-a-bst/",source:"@site/solutions/0200-0299/0230-kth-smallest-element-in-a-bst-medium.md",sourceDirName:"0200-0299",slug:"/0200-0299/kth-smallest-element-in-a-bst-medium",permalink:"/solutions/0200-0299/kth-smallest-element-in-a-bst-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0200-0299/0230-kth-smallest-element-in-a-bst-medium.md",tags:[{label:"Tree",permalink:"/solutions/tags/tree"},{label:"Depth-First Search",permalink:"/solutions/tags/depth-first-search"},{label:"Binary Search Tree",permalink:"/solutions/tags/binary-search-tree"},{label:"Binary Tree",permalink:"/solutions/tags/binary-tree"}],version:"current",sidebarPosition:230,frontMatter:{description:"Author: @ColeB2, @radojicic23 | https://leetcode.com/problems/kth-smallest-element-in-a-bst/",tags:["Tree","Depth-First Search","Binary Search Tree","Binary Tree"]},sidebar:"tutorialSidebar",previous:{title:"0228 - Summary Ranges (Easy)",permalink:"/solutions/0200-0299/summary-ranges-easy"},next:{title:"0231 - Power of Two (Easy)",permalink:"/solutions/0200-0299/power-of-two-easy"}},s={},u=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Recursive Inorder Traversal",id:"approach-1-recursive-inorder-traversal",level:2},{value:"Approach 2: Iterative Inorder Traversal",id:"approach-2-iterative-inorder-traversal",level:2}],d=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",t)},c=d("Tabs"),p=d("TabItem"),h=d("SolutionAuthor"),m={toc:u},k="wrapper";function f(e){let{components:t,...n}=e;return(0,o.kt)(k,(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"0230---kth-smallest-element-in-a-bst-medium"},"0230 - Kth Smallest Element in a BST (Medium)"),(0,o.kt)("h2",{id:"problem-link"},"Problem Link"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/kth-smallest-element-in-a-bst/"},"https://leetcode.com/problems/kth-smallest-element-in-a-bst/")),(0,o.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,o.kt)("p",null,"Given the ",(0,o.kt)("inlineCode",{parentName:"p"},"root")," of a binary search tree, and an integer ",(0,o.kt)("inlineCode",{parentName:"p"},"k"),", return ",(0,o.kt)("em",{parentName:"p"},"the ",(0,o.kt)("inlineCode",{parentName:"em"},"kth")," smallest value (1-indexed) of all the values of the nodes in the tree"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 1:")),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg",alt:null})),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: root = [3,1,4,null,2], k = 1\nOutput: 1\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 2:")),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg",alt:null})),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: root = [5,3,6,2,4,null,null,1], k = 3\nOutput: 3\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Constraints:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The number of nodes in the tree is ",(0,o.kt)("inlineCode",{parentName:"li"},"n"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"1 <= k <= n <= 10^4")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"0 <= Node.val <= 10^4"))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Follow up"),": If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?"),(0,o.kt)("h2",{id:"approach-1-recursive-inorder-traversal"},"Approach 1: Recursive Inorder Traversal"),(0,o.kt)("p",null,"If you know your tree traversals, specifically inorder traversal, and you understand the layouts of a binary search tree. Then that means you know the inorder traversal of a BST will give us the node values in sorted order. Knowing that we can simply generate the inorder traversal of the tree, and return the kth element."),(0,o.kt)("p",null,"Time Complexity: $$O(n)$$, must traverse each node to create the inorder traversal array."),(0,o.kt)("p",null,"Space Complexity: $$O(n)$$, to store the values of each node inside an array and utilize recursive call stack."),(0,o.kt)(c,{mdxType:"Tabs"},(0,o.kt)(p,{value:"python",label:"Python",mdxType:"TabItem"},(0,o.kt)(h,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-py"},"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def inorder(self, root) -> [int]:\n        # initialite array\n        arr = []\n        # if root is not a null node.\n        if root:\n            # recursively call on left side, adding output to arr.\n            arr += self.inorder(root.left)\n            # add the current value to arr\n            arr.append(root.val)\n            # recursively call on right side, adding output to arr.\n            arr += self.inorder(root.right)\n        # return the array.\n        return arr\n\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        # get the inorder traversal array.\n        inorder = self.inorder(root)\n        # return k-1 value since questions wants kth smallest, 1-indexed\n        return inorder[k-1]\n"))),(0,o.kt)(p,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,o.kt)(h,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    // initialize array\n    vector<int> res;\n    // recursive function\n    void inorder(TreeNode* root) {\n        // if root exist\n        if (root != NULL) {\n            // recursive call on the left side\n            inorder(root->left);\n            // insert current node to result array\n            res.push_back(root->val);\n            // recursive call on the right side\n            inorder(root->right);\n        }\n    }\n\n    int kthSmallest(TreeNode* root, int k) {\n        // get inorder traversal array\n        inorder(root);\n        // return kth smallest value\n        return res[k - 1];\n    }\n};\n"))),(0,o.kt)(p,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,o.kt)(h,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} k\n * @return {number}\n */\n\n// recursive function\nconst inorder = function(root) {\n    // if root exist \n    if (root !== null) {\n        // recursive call on the left side\n        inorder(root.left);\n        // insert current node to result array\n        res.push(root.val);\n        // recursive call on the right side\n        inorder(root.right);\n    }\n}\n\nvar kthSmallest = function(root, k) {\n    // initialize result array\n    res = [];\n    // get inorder traversal array\n    inorder(root);\n    // return kth smallest value\n    return res[k - 1];\n};\n")))),(0,o.kt)("h2",{id:"approach-2-iterative-inorder-traversal"},"Approach 2: Iterative Inorder Traversal"),(0,o.kt)("p",null,"We can also do our inorder traversal iteratively. This time, when we reach our answer, we can exit as soon as we find it, and save on space as we don't need to completely iterate over the whole tree, just until we reach the kth smallest."),(0,o.kt)("p",null,"If you've never seen inorder traversal done iteratively before, we need both a stack and a variable to track the current node. Then we use 2 while loops, one while the stack and the current node exists."),(0,o.kt)("p",null,"The second loop goes inside the first, and tracks the current node, adding the current node to the stack, so we can backtrack in the future, then we move our node pointer to the left."),(0,o.kt)("p",null,"When we finally reach a null node, we then need to pop a node off the stack, process the node then move the node pointer right."),(0,o.kt)("p",null,"Time Complexity: $$O(h+k)$$ where $$h$$ is the height of the tree, and $$k$$ is given. We will have to traverse down the tree to the lowest value node, then traverse back up k times to reach the kth. Given a skewed tree, this could be $$O(n+k)$$"),(0,o.kt)("p",null,"Space Complexity: $$O(h)$$ where $$h$$ is the height of the tree to maintain our stack. In the worst case $$h == n$$ with a skewed trees."),(0,o.kt)(c,{mdxType:"Tabs"},(0,o.kt)(p,{value:"python",label:"Python",mdxType:"TabItem"},(0,o.kt)(h,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-py"},"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        # initialize a current node pointer\n        node = root\n        # initialize stack for backtracking purposes\n        stack = []\n        # initialize an n counter to count up to k.\n        n = 0\n        # while our current node exists or the stack has values:\n        while node or stack:\n            # while our current node exists:\n            while node:\n                # add current node to the stack for backtracking\n                stack.append(node)\n                # move our current node pointer to the left child.\n                node = node.left\n            # Done going left, now we process the node and go right.\n            # node will equal null either from the above loop, or below process. \n            # So we need to pop a new node off the stack.\n            node = stack.pop()\n            # Update our n variable.\n            n += 1\n            # Check that n == k: if so we found the kth smallest.\n            if n == k:\n                # return the kth smallest value\n                return node.val\n            # Done the above process, we can move the current node pointer right.\n            # Note: if we reach a null node, the while loop will still run\n            # as long as values are inside the stack, which will backtrack us\n            # to the next node.\n            node = node.right\n"))),(0,o.kt)(p,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,o.kt)(h,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} k\n * @return {number}\n */\nvar kthSmallest = function(root, k) {\n    // initialize variable to count up to k\n    let n = 0;\n    // initialize stack\n    let stack = [];\n    // initialize curr node pointer\n    let curr = root;\n    // while current node is not null and stack is not empty\n    while (curr || stack) {\n        // while current node is not null \n        while (curr) {\n            // add current node to the stack\n            stack.push(curr);\n            // shift current pointer to the left\n            curr = curr.left;\n        }\n        // current pointer is done going left\n        // pop that current node from the stack  \n        curr = stack.pop();\n        // update count variable\n        n++;\n        // if we found kth smallest element\n        if (n === k) {\n            // return kth smallest value\n            return curr.val;\n        }\n        // shift current pointer to the right \n        curr = curr.right;\n    }\n};\n"))),(0,o.kt)(p,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,o.kt)(h,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int kthSmallest(TreeNode* root, int k) {\n        // initialize stack\n        stack<TreeNode*> st;\n        // initialize variable to count up to k\n        int n = 0;\n        // initialize current node pointer\n        TreeNode* curr = root;\n        // while current node is not NULL and stack is not empty\n        while (curr || st.size()) {\n            // while current node is not NULL\n            while (curr) {\n                // add current node to the stacl\n                st.push(curr);\n                // shift current pointer to the left\n                curr = curr->left;\n            }\n            // current pointer is done going left\n            // pop that current node from the stack \n            curr = st.top();\n            st.pop();\n            // update count variable  \n            n++;\n            // if we found kth smallest element\n            if (n == k) {\n                // return kth smallest element\n                return curr->val;\n            }\n            // shift current pointer to the right\n            curr = curr->right;\n        }\n        // kth smallest not found so return -1 \n        return -1;\n    }\n};\n")))))}f.isMDXComponent=!0}}]);