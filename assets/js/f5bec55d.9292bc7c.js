"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[2651],{3905:function(e,t,r){r.d(t,{Zo:function(){return m},kt:function(){return h}});var n=r(67294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function a(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var s=n.createContext({}),u=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):a(a({},t),e)),r},m=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),p=u(r),h=i,d=p["".concat(s,".").concat(h)]||p[h]||c[h]||o;return r?n.createElement(d,a(a({ref:t},m),{},{components:r})):n.createElement(d,a({ref:t},m))}));function h(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=r.length,a=new Array(o);a[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,a[1]=l;for(var u=2;u<o;u++)a[u]=r[u];return n.createElement.apply(null,a)}return n.createElement.apply(null,r)}p.displayName="MDXCreateElement"},39270:function(e,t,r){r.r(t),r.d(t,{assets:function(){return c},contentTitle:function(){return u},default:function(){return g},frontMatter:function(){return s},metadata:function(){return m},toc:function(){return p}});var n,i=r(87462),o=r(63366),a=(r(67294),r(3905)),l=["components"],s={title:"Minimum Spanning Tree",description:"A minimum spanning tree is a subset of the edges of a connected undirected graph with the minimum possible total edge weight and it does not contain any cycles.",hide_table_of_contents:!0,keywords:["leetcode","tutorial","minimum spanning tree","mst","algorithm"]},u=void 0,m={unversionedId:"graph-theory/minimum-spanning-tree",id:"graph-theory/minimum-spanning-tree",title:"Minimum Spanning Tree",description:"A minimum spanning tree is a subset of the edges of a connected undirected graph with the minimum possible total edge weight and it does not contain any cycles.",source:"@site/tutorials/graph-theory/minimum-spanning-tree.md",sourceDirName:"graph-theory",slug:"/graph-theory/minimum-spanning-tree",permalink:"/tutorials/graph-theory/minimum-spanning-tree",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/graph-theory/minimum-spanning-tree.md",tags:[],version:"current",frontMatter:{title:"Minimum Spanning Tree",description:"A minimum spanning tree is a subset of the edges of a connected undirected graph with the minimum possible total edge weight and it does not contain any cycles.",hide_table_of_contents:!0,keywords:["leetcode","tutorial","minimum spanning tree","mst","algorithm"]},sidebar:"tutorialSidebar",previous:{title:"Lowest Common Ancestor(LCA)",permalink:"/tutorials/graph-theory/lca"},next:{title:"Tarjan's Algorithm",permalink:"/tutorials/graph-theory/tarjans-algorithm"}},c={},p=[{value:"Overview",id:"overview",level:2},{value:"Kruskal&#39;s Algorithm",id:"kruskals-algorithm",level:3},{value:"Prim&#39;s Algorithm",id:"prims-algorithm",level:3},{value:"Boruvka&#39;s Algorithm",id:"boruvkas-algorithm",level:3}],h=(n="TutorialAuthors",function(e){return console.warn("Component "+n+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",e)}),d={toc:p};function g(e){var t=e.components,r=(0,o.Z)(e,l);return(0,a.kt)("wrapper",(0,i.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)(h,{names:"@wingkwong",mdxType:"TutorialAuthors"}),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"A Minimum Spanning Tree (MST) is a subset of the edges of a connected, undirected graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight. There are different algorithms that can be used to find the MST of a graph, such as Kruskal's algorithm, Prim's algorithm and Boruvka's algorithm. "),(0,a.kt)("h3",{id:"kruskals-algorithm"},"Kruskal's Algorithm"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"../graph-theory/kruskals-algorithm"},"See Here")),(0,a.kt)("h3",{id:"prims-algorithm"},"Prim's Algorithm"),(0,a.kt)("p",null,"Not Available Yet"),(0,a.kt)("h3",{id:"boruvkas-algorithm"},"Boruvka's Algorithm"),(0,a.kt)("p",null,"Not Available Yet"))}g.isMDXComponent=!0}}]);