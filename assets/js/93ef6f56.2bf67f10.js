"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[17682],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=r.createContext({}),m=function(e){var n=r.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=m(e.components);return r.createElement(p.Provider,{value:n},e.children)},l="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},c=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,p=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),l=m(t),c=a,h=l["".concat(p,".").concat(c)]||l[c]||d[c]||i;return t?r.createElement(h,s(s({ref:n},u),{},{components:t})):r.createElement(h,s({ref:n},u))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,s=new Array(i);s[0]=c;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o[l]="string"==typeof e?e:a,s[1]=o;for(var m=2;m<i;m++)s[m]=t[m];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},36965:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>m});var r=t(87462),a=(t(67294),t(3905));const i={description:"Author: @wingkwong | https://leetcode.com/problems/append-k-integers-with-minimal-sum/"},s="2195 - Append K Integers With Minimal Sum (Medium)",o={unversionedId:"2100-2199/append-k-integers-with-minimal-sum-medium",id:"2100-2199/append-k-integers-with-minimal-sum-medium",title:"2195 - Append K Integers With Minimal Sum (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/append-k-integers-with-minimal-sum/",source:"@site/solutions/2100-2199/2195-append-k-integers-with-minimal-sum-medium.md",sourceDirName:"2100-2199",slug:"/2100-2199/append-k-integers-with-minimal-sum-medium",permalink:"/solutions/2100-2199/append-k-integers-with-minimal-sum-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2100-2199/2195-append-k-integers-with-minimal-sum-medium.md",tags:[],version:"current",sidebarPosition:2195,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/append-k-integers-with-minimal-sum/"},sidebar:"tutorialSidebar",previous:{title:"2194 - Cells in a Range on an Excel Sheet (Easy)",permalink:"/solutions/2100-2199/cells-in-a-range-on-an-excel-sheet-easy"},next:{title:"2196 - Create Binary Tree From Descriptions (Medium)",permalink:"/solutions/2100-2199/create-binary-tree-from-descriptions-medium"}},p={},m=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Sum of Consecutive Numbers",id:"approach-1-sum-of-consecutive-numbers",level:2}],u=(l="SolutionAuthor",function(e){return console.warn("Component "+l+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",e)});var l;const d={toc:m},c="wrapper";function h(e){let{components:n,...t}=e;return(0,a.kt)(c,(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"2195---append-k-integers-with-minimal-sum-medium"},"2195 - Append K Integers With Minimal Sum (Medium)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/append-k-integers-with-minimal-sum/"},"https://leetcode.com/problems/append-k-integers-with-minimal-sum/")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"You are given an integer array ",(0,a.kt)("inlineCode",{parentName:"p"},"nums")," and an integer ",(0,a.kt)("inlineCode",{parentName:"p"},"k"),". Append ",(0,a.kt)("inlineCode",{parentName:"p"},"k")," ",(0,a.kt)("strong",{parentName:"p"},"unique positive")," integers that do ",(0,a.kt)("strong",{parentName:"p"},"not")," appear in ",(0,a.kt)("inlineCode",{parentName:"p"},"nums")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"nums")," such that the resulting total sum is ",(0,a.kt)("strong",{parentName:"p"},"minimum"),"."),(0,a.kt)("p",null,"Return ",(0,a.kt)("em",{parentName:"p"},"the sum of the")," ",(0,a.kt)("inlineCode",{parentName:"p"},"k")," ",(0,a.kt)("em",{parentName:"p"},"integers appended to")," ",(0,a.kt)("inlineCode",{parentName:"p"},"nums"),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: nums = [1,4,25,10,25], k = 2\nOutput: 5\nExplanation: The two unique positive integers that do not appear in nums which we append are 2 and 3.\nThe resulting sum of nums is 1 + 4 + 25 + 10 + 25 + 2 + 3 = 70, which is the minimum.\nThe sum of the two integers appended is 2 + 3 = 5, so we return 5.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: nums = [5,6], k = 6\nOutput: 25\nExplanation: The six unique positive integers that do not appear in nums which we append are 1, 2, 3, 4, 7, and 8.\nThe resulting sum of nums is 5 + 6 + 1 + 2 + 3 + 4 + 7 + 8 = 36, which is the minimum. \nThe sum of the six integers appended is 1 + 2 + 3 + 4 + 7 + 8 = 25, so we return 25.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= nums.length <= 10^5")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= nums[i], k <= 10^9"))),(0,a.kt)("h2",{id:"approach-1-sum-of-consecutive-numbers"},"Approach 1: Sum of Consecutive Numbers"),(0,a.kt)("p",null,"First we sort the input. For each number $$x$$, we need to know how many numbers between $$prev$$ to $$x - 1$$, where the initial value $$prev$$ is $$0$$. For example, if the first number is $$4$$, then we need to append $$4 - 0 - 1 = 3$$ numbers. If we don't need to append any number, we simply set $$prev := x$$."),(0,a.kt)("p",null,"If we need to append some numbers, then the next question is how many numbers we can append. Remember that we just need to append $$k$$ numbers."),(0,a.kt)("p",null,"If $$k$$ is greater than / equal to what we need, we update $$k := k - need$$ and add the consecutive sum between $$prev$$ to $$x$$ which is $$((prev + 1) + (x - 1)) ",(0,a.kt)("em",{parentName:"p"}," need / 2$$.  For example, if $$prev$$ is $$1$$ and $$x$$ is $$4$$, then the consecutive sum between them is $$((1 + 1) + (4 - 1)) ")," 2 / 2 = 5$$, i.e $$2 + 3$$. Then we update $$prev := x$$. If we have already appended $$k$$ numbers, then we can return the answer."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"The consecutive sum between $$start$$ and $$end$$ is simply $$(start + end) * n / 2$$. If you are interested in how to get this formula, please check out ",(0,a.kt)("a",{parentName:"p",href:"../0800-0899/consecutive-numbers-sum-hard"},"0829 - Consecutive Numbers Sum (Hard)"),".")),(0,a.kt)("p",null,"The other case is we just need to append $$k$$ numbers. Then we simply add $$(prev ",(0,a.kt)("em",{parentName:"p"}," 2 + k + 1) ")," k$$ and return the answer."),(0,a.kt)("p",null,"In case we still need to append some numbers after the last element of the input $$last$$. Then we add $$((last + 1) + (last + k)) * k / 2$$."),(0,a.kt)(u,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    long long minimalKSum(vector<int>& nums, int k) {\n        // sort it first\n        sort(nums.begin(), nums.end());\n        // init ans & prev\n        long long ans = 0, prev = 0;\n        for (auto x : nums) {\n            // how many numbers between prev and x exclusively\n            // 1 .. 4 -> [2, 3] which is 2\n            long long need = x - prev - 1;\n            // no need to append -> update prev only\n            if (need <= 0) prev = x;\n            else {\n                // case 1: we append _need_ numbers only\n                if (k >= need) {\n                    // update k as we append _need_ numbers\n                    k -= need;\n                    // consecutive sum between prev and x (exclusive)\n                    // start = prev + 1, end = x - 1, n = need\n                    // sum = (start + end) * n / 2\n                    ans += ((prev + 1) + (x - 1)) * need / 2;\n                    // set prev\n                    prev = x;\n                    // appended k numbers already, return ans\n                    if (k == 0) return ans;\n                } else {\n                    // need > k. append k numbers then return ans\n                    // consecutive sum between prev and prev + k (exclusive)\n                    // start = prev + 1, end = prev + k, n = k\n                    // sum = (start + end) * n / 2\n                    ans += ((prev + 1) + (prev + k)) * k / 2;\n                    return ans;\n                }\n            }\n        }\n        // append k numbers after the last element of nums last\n        // consecutive sum between last and last + k (exclusive)\n        // start = last + 1, end = last + k, n = k\n        // sum = (start + end) * n / 2\n        long long last = nums.back();\n        ans += ((last + 1) + (last + k)) * k / 2;\n        return ans;\n    }\n};\n")),(0,a.kt)("p",null,"From above solution, we can see that we use the same formula on different cases based on $$need$$. In fact, we can combine different cases into one by tuning $$need$$."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    long long minimalKSum(vector<int>& nums, int k) {\n        // add the large value at the end\n        nums.push_back(INT_MAX);\n        // sort the input\n        sort(nums.begin(), nums.end());\n        long long ans = 0, prev = 0;\n        for (auto x : nums) {\n            // if we have appeneded k numbers, then skip the rest of the numbers\n            if (k <= 0) break;\n            // combine all cases into one\n            long long need = max(0, min(x - (int) prev - 1, k));\n            // substract need from k\n            k -= need;\n            // sum = (start + end) * n / 2\n            ans += ((prev + 1) + (prev + need)) * need / 2;\n            // mark prev\n            prev = 1LL * x;\n        }\n        return ans;\n    }\n};\n")))}h.isMDXComponent=!0}}]);