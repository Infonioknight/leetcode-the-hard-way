"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[56562],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>d});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function u(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var o=r.createContext({}),l=function(e){var n=r.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):u(u({},n),e)),t},m=function(e){var n=l(e.components);return r.createElement(o.Provider,{value:n},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},f=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),p=l(t),f=a,d=p["".concat(o,".").concat(f)]||p[f]||c[f]||i;return t?r.createElement(d,u(u({ref:n},m),{},{components:t})):r.createElement(d,u({ref:n},m))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,u=new Array(i);u[0]=f;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s[p]="string"==typeof e?e:a,u[1]=s;for(var l=2;l<i;l++)u[l]=t[l];return r.createElement.apply(null,u)}return r.createElement.apply(null,t)}f.displayName="MDXCreateElement"},72362:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>u,default:()=>k,frontMatter:()=>i,metadata:()=>s,suggestedProblems:()=>m,toc:()=>l});var r=t(87462),a=(t(67294),t(3905));const i={title:"Prefix Sum",description:"Prefix Sum is the sums of prefixes of the input sequence",hide_table_of_contents:!0,keywords:["leetcode","tutorial","prefix sum"]},u=void 0,s={unversionedId:"basic-topics/prefix-sum",id:"basic-topics/prefix-sum",title:"Prefix Sum",description:"Prefix Sum is the sums of prefixes of the input sequence",source:"@site/tutorials/basic-topics/prefix-sum.md",sourceDirName:"basic-topics",slug:"/basic-topics/prefix-sum",permalink:"/tutorials/basic-topics/prefix-sum",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/basic-topics/prefix-sum.md",tags:[],version:"current",frontMatter:{title:"Prefix Sum",description:"Prefix Sum is the sums of prefixes of the input sequence",hide_table_of_contents:!0,keywords:["leetcode","tutorial","prefix sum"]},sidebar:"tutorialSidebar",previous:{title:"MOD (1e9 + 7)",permalink:"/tutorials/basic-topics/mod"},next:{title:"Queue & Stack",permalink:"/tutorials/basic-topics/queue-and-stack"}},o={},l=[{value:"Overview",id:"overview",level:2},{value:"Example : 1480 - Running Sum of 1d Array",id:"example--1480---running-sum-of-1d-array",level:3},{value:"Example: 0303 - Range Sum Query - Immutable",id:"example-0303---range-sum-query---immutable",level:3}],m=[{problemName:"1480 - Running Sum of 1d Array",difficulty:"Easy",leetCodeLink:"https://leetcode.com/problems/running-sum-of-1d-array",solutionLink:"../../solutions/1400-1499/running-sum-of-1d-array-easy"},{problemName:"0303 - Range Sum Query - Immutable",difficulty:"Easy",leetCodeLink:"https://leetcode.com/problems/range-sum-query-immutable/",solutionLink:""},{problemName:"1004 - Max Consecutive Ones III",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/max-consecutive-ones-iii/",solutionLink:"../../solutions/1000-1099/max-consecutive-ones-iii-medium"},{problemName:"0974 - Subarray Sums Divisible by K",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/subarray-sums-divisible-by-k/",solutionLink:"../../solutions/0900-0999/subarray-sums-divisible-by-k-medium"}],p=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",n)},c=p("TutorialAuthors"),f=p("Tabs"),d=p("TabItem"),h=p("SolutionAuthor"),y=p("Table"),b={toc:l,suggestedProblems:m},g="wrapper";function k(e){let{components:n,...t}=e;return(0,a.kt)(g,(0,r.Z)({},b,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)(c,{names:"@wingkwong",mdxType:"TutorialAuthors"}),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"The prefix sum is a technique used to efficiently calculate the sum of all elements in an array up to a certain index. It is also known as cumulative sum, and it is often used in various computational problems such as range sum queries or dynamic programming."),(0,a.kt)("p",null,"The basic idea behind the prefix sum is to pre-compute the sum of all elements up to each index in the array and then use these pre-computed sums to quickly calculate the sum of any sub-array in the array."),(0,a.kt)("p",null,"The steps for implementing the prefix sum technique are as follows:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Create a new array of the same length as the original array, and initialize the first element to the value of the first element of the original array."),(0,a.kt)("li",{parentName:"ol"},"Starting from the second element, iterate through the rest of the original array, and at each element, calculate the prefix sum by adding the current element to the previous prefix sum, and store this value in the corresponding element of the new array."),(0,a.kt)("li",{parentName:"ol"},"To find the sum of any sub-array, we can use the pre-computed prefix sum array, by subtracting the prefix sum of the starting index of the sub-array from the prefix sum of the ending index + 1.")),(0,a.kt)("p",null,"The prefix sum has a time complexity of O(n) and a space complexity of O(n), it is efficient and widely used in various computational problems such as range sum queries, dynamic programming and more."),(0,a.kt)("p",null,"Let's say the input $a$ is $","[1, 2, 3, 4, 5]","$. The prefix sum array $pref$ would be $","[1, 3, 6, 10, 15]","$ which can be calculated as follows:"),(0,a.kt)("p",null,"$$$\npref","[0]"," = a","[0]"," ","\\","\npref","[1]"," = a","[0]"," + a","[1]"," ","\\","\npref","[2]"," = a","[0]"," + a","[1]"," + a","[2]"," ","\\","\n...\n$$$"),(0,a.kt)("p",null,"We can notice that $pref","[i]","$ is the previous value $pref","[i - 1]","$ plus the input $a","[i]","$ starting from $i = 1$, which can be illrustrated as follows:"),(0,a.kt)("p",null,"$$$\npref","[0]"," = a","[0]"," ","\\","\npref","[1]"," = pref","[0]"," + a","[1]"," ","\\","\npref","[2]"," = pref","[1]"," + a","[2]"," ","\\","\n...\n$$$"),(0,a.kt)("p",null,"To generalise, we have "),(0,a.kt)("p",null,"$$$\npref","[i]"," =\n\\begin{cases}\na","[0]",",  & \\text{if $i$ is 0} ","\\","\npref","[i - 1]"," + a","[i]",", & \\text{if $i$ >= 1}\n\\end{cases}\n$$$"),(0,a.kt)(f,{mdxType:"Tabs"},(0,a.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(h,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"vector<int> generatePrefixSum(vector<int>& a) {\n    int n = a.size();\n    vector<int> pref(n);\n    pref[0] = a[0];\n    for (int i = 1; i < n; i++) pref[i] = pref[i - 1] + a[i];\n    return pref;\n}\n")))),(0,a.kt)("h3",{id:"example--1480---running-sum-of-1d-array"},"Example : ",(0,a.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/running-sum-of-1d-array/"},"1480 - Running Sum of 1d Array")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0] ... nums[i]).\nReturn the running sum of nums.\n\nInput: nums = [1,2,3,4]\nOutput: [1,3,6,10]\nExplanation: Running sum is obtained as follows: [1, 1 + 2, 1 + 2 + 3, 1 + 2 + 3 + 4]\n")),(0,a.kt)("p",null,"Let's start with a brute force solution, we iterate each element $a","[i]","$ and we iterate from $j = ","[0 .. i]","$ to add $a","[j]","$ to $sum$. This solution is acceptable but it is slow as we have two for-loops here."),(0,a.kt)(f,{mdxType:"Tabs"},(0,a.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(h,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    vector<int> runningSum(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> ans(n);\n        for (int i = 0; i < n; i++) {\n            int sum = 0;\n            for (int j = 0; j <= i; j++) {\n                sum += nums[j];\n            }\n            ans[i] = sum;\n        }\n        return ans;\n    }\n};\n")))),(0,a.kt)("p",null,"However, if we utilise the idea of Prefix sum, we know the result at some point has been calculated. Therefore, we can just do it in a $O(n)$ way."),(0,a.kt)(f,{mdxType:"Tabs"},(0,a.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(h,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    vector<int> generatePrefixSum(vector<int>& a) {\n        int n = a.size();\n        vector<int> pref(n);\n        pref[0] = a[0];\n        for (int i = 1; i < n; i++) pref[i] = pref[i - 1] + a[i];\n        return pref;\n    }\n    vector<int> runningSum(vector<int>& nums) {\n        return generatePrefixSum(nums);\n    }\n};\n")))),(0,a.kt)("p",null,"As we don't actually need $pref$ for further process in this question, we can just write it inline instead."),(0,a.kt)(f,{mdxType:"Tabs"},(0,a.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(h,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    vector<int> runningSum(vector<int>& nums) {\n        for (int i = 1; i < nums.size(); i++) {\n            nums[i] += nums[i - 1];\n        }\n        return nums;\n    }\n};\n")))),(0,a.kt)("p",null,"Prefix Sum is useful when we want to find the sum of all elements in a given range or something related to subarray problems. Besides, it doesn't have to be sum. We can make it like product ($pref","[i]"," = pref","[i - 1]"," * a","[i]","$) or even XOR ($pref","[i]"," = pref","[i - 1]"," \\oplus a","[i]","$). "),(0,a.kt)("h3",{id:"example-0303---range-sum-query---immutable"},"Example: ",(0,a.kt)("a",{parentName:"h3",href:"https://leetcode.com/problems/range-sum-query-immutable/"},"0303 - Range Sum Query - Immutable")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Given an integer array nums, handle multiple queries of the following type:\n\nCalculate the sum of the elements of nums between indices left and right inclusive where left <= right.\nImplement the NumArray class:\n\nNumArray(int[] nums) Initializes the object with the integer array nums.\nint sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).\n\nInput\n["NumArray", "sumRange", "sumRange", "sumRange"]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\nOutput\n[null, 1, -1, -3]\n\nExplanation\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3\n')),(0,a.kt)("p",null,"Sometimes we may pad a zero as the first element in prefix sum as we want to exclude the first element. For example, let's say we have an input $","[1, 2, 3, 4, 5]","$, the prefix sum array would be $","[0, 1, 3, 6, 10, 15]","$. In this case, we can write as follows:"),(0,a.kt)(f,{mdxType:"Tabs"},(0,a.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(h,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"vector<int> generatePrefixSum(vector<int>& a) {\n    int n = a.size();\n    vector<int> pref(n + 1);\n    for (int i = 0; i < n; i++) pref[i + 1] = pref[i] + a[i];\n    return pref;\n}\n")))),(0,a.kt)("p",null,"Given $l$ and $r$, if we want to calculate the sum of the elements of $nums$ between $l$ and $r$ inclusive. The answer is simply $pref","[r + 1]"," - pref","[l]","$. "),(0,a.kt)("p",null,"Let's say we have an input $","[a,b,c,d]","$ and $pref$ would be $","[0, a, a+b, a+b+c, a+b+c+d]","$. Supposing we want to calculate the sum for the last three elements (i.e. $l = 1, r = 3$), it is easy to see the answer is $b + c + d$. "),(0,a.kt)("p",null,"If we use $pref$ to calculate, that would be "),(0,a.kt)("p",null,"$$$\nrangeSum(l, r) = pref","[r + 1]"," - pref","[l]"," ","\\","\nrangeSum(1, 3) = pref","[4]"," - pref","[1]"," ","\\","\n= (a + b + c + d) - (a) ","\\","\n= b + c + d\n$$$"),(0,a.kt)(f,{mdxType:"Tabs"},(0,a.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(h,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class NumArray {\npublic:\n    vector<int> pref;\n    vector<int> generatePrefixSum(vector<int>& a) {\n        int n = a.size();\n        vector<int> pref(n + 1);\n        for (int i = 0; i < n; i++) pref[i + 1] = pref[i] + a[i];\n        return pref;\n    }\n\n    \n    NumArray(vector<int>& nums) {\n        pref.resize(nums.size() + 1);\n        pref = generatePrefixSum(nums);\n    }\n    \n    int sumRange(int left, int right) {\n        return pref[right + 1] - pref[left];\n    }\n};\n")))),(0,a.kt)(y,{title:"Suggested Problems",data:m,mdxType:"Table"}))}k.isMDXComponent=!0}}]);