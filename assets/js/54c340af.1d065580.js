"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[1566],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>d});var o=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=o.createContext({}),p=function(e){var n=o.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=p(e.components);return o.createElement(s.Provider,{value:n},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},b=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(t),b=a,d=c["".concat(s,".").concat(b)]||c[b]||m[b]||r;return t?o.createElement(d,i(i({ref:n},u),{},{components:t})):o.createElement(d,i({ref:n},u))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,i=new Array(r);i[0]=b;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[c]="string"==typeof e?e:a,i[1]=l;for(var p=2;p<r;p++)i[p]=t[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}b.displayName="MDXCreateElement"},56750:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>$,frontMatter:()=>r,metadata:()=>l,suggestedProblems:()=>u,toc:()=>p});var o=t(87462),a=(t(67294),t(3905));const r={title:"Binary Exponentiation",description:"Binary Exponentiation is also known as Exponentiation by Squaring.",hide_table_of_contents:!0,keywords:["leetcode","tutorial","binary exponentiation","fast pow","algorithm"]},i=void 0,l={unversionedId:"math/number-theory/binary-exponentiation",id:"math/number-theory/binary-exponentiation",title:"Binary Exponentiation",description:"Binary Exponentiation is also known as Exponentiation by Squaring.",source:"@site/tutorials/math/number-theory/binary-exponentiation.md",sourceDirName:"math/number-theory",slug:"/math/number-theory/binary-exponentiation",permalink:"/tutorials/math/number-theory/binary-exponentiation",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/math/number-theory/binary-exponentiation.md",tags:[],version:"current",frontMatter:{title:"Binary Exponentiation",description:"Binary Exponentiation is also known as Exponentiation by Squaring.",hide_table_of_contents:!0,keywords:["leetcode","tutorial","binary exponentiation","fast pow","algorithm"]},sidebar:"tutorialSidebar",previous:{title:"Number Theory",permalink:"/tutorials/category/number-theory"},next:{title:"Sieve of Eratosthenes",permalink:"/tutorials/math/number-theory/sieve-of-eratosthenes"}},s={},p=[{value:"Overview",id:"overview",level:2},{value:"Implementation",id:"implementation",level:2}],u=[{problemName:"0050 - Pow(x, n)",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/powx-n/",solutionLink:"../../../solutions/0000-0099/pow-x-n-medium"}],c=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",n)},m=c("TutorialAuthors"),b=c("Tabs"),d=c("TabItem"),y=c("SolutionAuthor"),h=c("Table"),g={toc:p,suggestedProblems:u},f="wrapper";function $(e){let{components:n,...t}=e;return(0,a.kt)(f,(0,o.Z)({},g,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)(m,{names:"@wingkwong",mdxType:"TutorialAuthors"}),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,'Binary Exponentiation is a method for efficiently calculating large powers of a number, such as $a^n$. Instead of using the naive approach of repeatedly multiplying the base number by itself, which has a time complexity of $O(n)$, binary exponentiation uses a technique called "exponentiation by squaring"  to accomplish the same task in $O(log n)$ time complexity.'),(0,a.kt)("p",null,"The basic idea behind binary exponentiation is that we can express $$a ^ n$$ as $$a ",(0,a.kt)("em",{parentName:"p"}," a ")," ... ",(0,a.kt)("em",{parentName:"p"}," a$$ but it is not efficient for a large $$a$$ and $$n$$. If we display the exponent in binary representation, says $13 = 1101_2$, then we have $$3 ^{13} = 3^8"),"3^4*3^1.$$ Supposing we have a sequence $$a ^ 1, a ^ 2, a ^4, ..., a^{\\lfloor log_2 n\\rfloor}$$, we can see the an element in the sequence is the square of previous element, i.e. $$3 ^ 4 = (3^2)^2$$. Therefore, to calculate $$3 ^ {13}$$, we just need to calculate $${\\lfloor log_2 13\\rfloor} = 3$$ times, i.e. ($1$ -> $4$ -> $8$). We skip $2$ here because the bit is not set. This approach gives us $$O(log n)$$ complexity."),(0,a.kt)("p",null,"To generalise it, for a positive integer $$n$$, we have"),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/35857179/168304432-fa9ac8bb-0eb9-49d9-bdcf-5e3509c1f835.png",alt:"image"})),(0,a.kt)("h2",{id:"implementation"},"Implementation"),(0,a.kt)(b,{mdxType:"Tabs"},(0,a.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(y,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"long long fastpow(long long base, long long exp) {\n  long long res = 1;\n  while (exp > 0) {\n    // if n is odd, a ^ n can be seen as a ^ (n / 2) * a ^ (n / 2) * a\n    if (exp & 1) res *= base;\n    // if n is even, a ^ n can be seen as a ^ (n / 2) * a ^ (n / 2)\n    base *= base;\n    // shift 1 bit to the right\n    exp >>= 1;\n  }\n  return res;\n}\n")))),(0,a.kt)("p",null,"In case you need to take mod during the calculation, we can do as follows."),(0,a.kt)(b,{mdxType:"Tabs"},(0,a.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(y,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"long long modpow(long long base, long long exp, long long mod) {\n  base %= mod;\n  long long res = 1;\n  while (exp > 0) {\n    if (exp & 1) res = (res * base) % mod;\n    base = (base * base) % mod;\n    exp >>= 1;\n  }\n  return res;\n}\n")))),(0,a.kt)(h,{title:"Suggested Problems",data:u,mdxType:"Table"}))}$.isMDXComponent=!0}}]);