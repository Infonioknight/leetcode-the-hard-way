"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[94994],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>c});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),m=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=m(e.components);return r.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},g=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=m(n),g=i,c=d["".concat(s,".").concat(g)]||d[g]||u[g]||a;return n?r.createElement(c,o(o({ref:t},p),{},{components:n})):r.createElement(c,o({ref:t},p))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=g;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:i,o[1]=l;for(var m=2;m<a;m++)o[m]=n[m];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}g.displayName="MDXCreateElement"},16749:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>b,frontMatter:()=>a,metadata:()=>l,suggestedProblems:()=>p,toc:()=>m});var r=n(87462),i=(n(67294),n(3905));const a={title:"Merge Sort",description:"A sorting algorithm based on divide-and-conquer strategy",hide_table_of_contents:!1,keywords:["leetcode","tutorial","sorting","algorithm","merge sort"]},o=void 0,l={unversionedId:"basic-topics/sorting/merge-sort",id:"basic-topics/sorting/merge-sort",title:"Merge Sort",description:"A sorting algorithm based on divide-and-conquer strategy",source:"@site/tutorials/basic-topics/sorting/merge-sort.md",sourceDirName:"basic-topics/sorting",slug:"/basic-topics/sorting/merge-sort",permalink:"/tutorials/basic-topics/sorting/merge-sort",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/basic-topics/sorting/merge-sort.md",tags:[],version:"current",frontMatter:{title:"Merge Sort",description:"A sorting algorithm based on divide-and-conquer strategy",hide_table_of_contents:!1,keywords:["leetcode","tutorial","sorting","algorithm","merge sort"]},sidebar:"tutorialSidebar",previous:{title:"Insertion Sort",permalink:"/tutorials/basic-topics/sorting/insertion-sort"},next:{title:"Selection Sort",permalink:"/tutorials/basic-topics/sorting/selection-sort"}},s={},m=[{value:"Overview",id:"overview",level:2},{value:"Algorithm",id:"algorithm",level:2},{value:"Divide",id:"divide",level:3},{value:"Conquer",id:"conquer",level:3},{value:"Merge",id:"merge",level:3},{value:"Example: 0912 - Sort an Array",id:"example-0912---sort-an-array",level:2},{value:"Top Down Approach",id:"top-down-approach",level:3},{value:"Algorithm",id:"algorithm-1",level:4},{value:"Bottom Up Approach / Iterative technique",id:"bottom-up-approach--iterative-technique",level:3},{value:"Algorithm",id:"algorithm-2",level:4},{value:"Example: 0148 - Sort List",id:"example-0148---sort-list",level:2},{value:"Approach for Bottom-Up Merge Sort of Linked list",id:"approach-for-bottom-up-merge-sort-of-linked-list",level:3},{value:"Approach for Top-down Merge Sort of Linked list",id:"approach-for-top-down-merge-sort-of-linked-list",level:3},{value:"Steps to apply merge sort to a Linked list",id:"steps-to-apply-merge-sort-to-a-linked-list",level:3}],p=[{problemName:"912-Sort an Array",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/sort-an-array/",solutionLink:"../../../solutions/0900-0999/sort-an-array-medium"},{problemName:"56-Merge Intervals",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/merge-intervals/",solutionLink:""},{problemName:"148-Sort List",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/sort-list/",solutionLink:"../../../solutions/0100-0199/sort-list-medium"},{problemName:"327-Count of Range Sum",difficulty:"Hard",leetCodeLink:"https://leetcode.com/problems/count-of-range-sum/",solutionLink:"../../../solutions/0300-0399/count-of-range-sum-hard"},{problemName:"23-Merge k Sorted Lists",difficulty:"Hard",leetCodeLink:"https://leetcode.com/problems/merge-k-sorted-lists/",solutionLink:"../../../solutions/0000-0099/merge-k-sorted-lists-hard"}],d=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",t)},u=d("TutorialAuthors"),g=d("Contributors"),c=d("Tabs"),h=d("TabItem"),f=d("Table"),k={toc:m,suggestedProblems:p},y="wrapper";function b(e){let{components:t,...n}=e;return(0,i.kt)(y,(0,r.Z)({},k,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)(u,{names:"@Sreetama2001",mdxType:"TutorialAuthors"}),(0,i.kt)(g,{names:"@wingkwong",mdxType:"Contributors"}),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"Merge Sort works by recursively breaking down an array into multiple subarrays and then after comparing each of the subarrays. It arranges them into ascending or descending order by value and merges them into a single sorted array. "),(0,i.kt)("p",null,"Suppose we have an array of integers $","[6, 5, 3, 1, 8, 7, 2, 4]","$."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"In Python it is called ",(0,i.kt)("strong",{parentName:"p"},"list")," and in C++ it can be called either ",(0,i.kt)("strong",{parentName:"p"},"array or vector")," and in Java it is called a ",(0,i.kt)("strong",{parentName:"p"},"ArrayList"),".")),(0,i.kt)("p",null,"Then we can see that merge sort is performed in this way. "),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://miro.medium.com/max/600/1*opwN0BhtH4zvPF697fPlow.gif",alt:"image"})," "),(0,i.kt)("p",null,"Image by Brian Hans via ",(0,i.kt)("a",{parentName:"p",href:"https://medium.com/@brianhans/merge-sort-a1d031eaa40f"},"Medium")),(0,i.kt)("h2",{id:"algorithm"},"Algorithm"),(0,i.kt)("h3",{id:"divide"},"Divide"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Calculate the midpoint by checking if the left index is less than the right index, if yes divide the array. "),(0,i.kt)("li",{parentName:"ul"},"Now continue dividing the array until $index",(0,i.kt)("em",{parentName:"li"},"{left} < index"),"{right}$ becomes false, that is until the division is not possible.\n")),(0,i.kt)("h3",{id:"conquer"},"Conquer"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"After dividing the array into the smallest units, start merging the elements again by comparing them."),(0,i.kt)("li",{parentName:"ul"},"We need to compare and merge starting from the last splits or last smallest units. So ",(0,i.kt)("strong",{parentName:"li"},"Recursion")," needs to be done here.")),(0,i.kt)("h3",{id:"merge"},"Merge"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Since each half is already sorted so we need to just sort between 2 halves to ",(0,i.kt)("strong",{parentName:"li"},"combine / merge")," than to make a bigger sorted array. ")),(0,i.kt)("h2",{id:"example-0912---sort-an-array"},"Example: ",(0,i.kt)("a",{parentName:"h2",href:"https://leetcode.com/problems/sort-an-array/"},"0912 - Sort an Array")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Given an array of integers nums, sort the array in ascending order and return it.\nYou must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.")),(0,i.kt)("h3",{id:"top-down-approach"},"Top Down Approach"),(0,i.kt)("h4",{id:"algorithm-1"},"Algorithm"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"if $left == right$",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"array has only one element, hence return."))),(0,i.kt)("li",{parentName:"ul"},"if $right > left$",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"find the middle point to divide the array into two halves: $middle = left + (right - left) / 2$"),(0,i.kt)("li",{parentName:"ul"},"call mergeSort again for first half for further dividing: call $mergeSort(array, left, middle)$"),(0,i.kt)("li",{parentName:"ul"},"call mergeSort again for second half for further dividing: call $mergeSort(array, middle + 1, right)$"),(0,i.kt)("li",{parentName:"ul"},"merge the two halves sorted: call $merge(array, left, middle, right)$"),(0,i.kt)("li",{parentName:"ul"},"merge function is called to compare and merge the elements into an array")))),(0,i.kt)(c,{mdxType:"Tabs"},(0,i.kt)(h,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    void merge(vector<int>& nums, int l, int m, int r) {\n        // create a temporary array\n        vector<int> tmp(r - l + 1);\n        // index for left subarray \n        int i = l;\n        // index for right subarray \n        int j = m + 1; \n        // index for temporary array\n        int k = 0; \n        while (i <= m && j <= r) {\n            // increment the left pointer \n            // if the right pointer element is bigger \n            // Since we are sorting in ascending order,left(smaller element) goes first\n            if(nums[i] <= nums[j]) tmp[k++] = nums[i++];   \n            else tmp[k++] = nums[j++];\n        }\n        // Since in the above while loop if one condition stop satisfying loop breaks \n        // Then we need to take care of  next / remaining  elements  \n        // Hence adding remaining elements of left half\n        while (i <= m) tmp[k++] = nums[i++];\n        // adding remaining elements of right half\n        while (j <= r) tmp[k++] = nums[j++]; \n        // Copy data to nums\n        for (i = 0; i < k; i++) nums[l + i] = tmp[i];\n    }\n\n    void mergeSort(vector<int>& nums, int l, int r) {\n        if (l >= r) return;\n        // middle index, same as (l + r) / 2\n        int m = l + (r - l) / 2;\n        mergeSort(nums, l, m);\n        mergeSort(nums, m + 1, r);\n        merge(nums, l, m, r);\n    }\n\n    // function to return sorted array in leetcode\n    vector<int> sortArray(vector<int>& nums) {\n        mergeSort(nums, 0, nums.size() - 1);\n        return nums;\n    }\n};\n"))),(0,i.kt)(h,{value:"py",label:"Python3",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n\n    def sortArray(self, nums: List[int]) -> List[int]:\n        self.merge_Sort(nums)\n        return nums\n    \n    def merge_Sort(self,nums: List[int]) -> List[int]:\n       if len(nums) > 1:\n           # calculate the middle to divide by mid \n           mid = len(nums) // 2  \n           leftArray = nums[:mid]  \n           rightArray = nums[mid:]  \n\n           self.merge_Sort(leftArray)\n           self.merge_Sort(rightArray)\n\n           i = j = k = 0\n\n           while i < len(leftArray) and j < len(rightArray): \n               if leftArray[i] < rightArray[j]:\n                   # smaller element is merged first\n                   # remember we are sorting in ascending order  \n                   nums[k] = leftArray[i] \n                   # incrementing the pointer of the smaller element\n                   i +=1 \n               else: \n                   nums[k] = rightArray[j]\n                   # incrementing the pointer of the larger element \n                   j +=1\n               k +=1\n\n           # for the left out elements we are performing it seperately \n           # Since in the above while loop if one condition stop satisfying loop breaks \n           # Then we need to merge next / remaining  elements   \n           while i < len(leftArray): \n               nums[k] = leftArray[i] \n               i +=1\n               k +=1\n           # merging remaining elements of right half\n           while j < len(rightArray): \n               nums[k] = rightArray[j] \n               j +=1\n               k +=1\n"))),(0,i.kt)(h,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public int[] sortArray(int[] nums) {\n        int n = nums.length;\n        mergeSort(nums, 0, n - 1);\n        return nums;\n    }\n    \n    void mergeSort(int[] nums, int start, int end) {\n        if (end - start + 1 <= 1) return; \n        int mi = start + (end - start) / 2;\n        mergeSort(nums, start, mi);\n        mergeSort(nums, mi + 1, end);\n        merge(nums, start, mi, end);\n    }\n    \n    void merge(int[] nums, int start, int mi, int end) {\n        int lp = start;\n        int rp = mi + 1;\n        int[] buffer = new int[end - start + 1];\n        // buffer pointer\n        int t = 0; \n        while (lp <= mi && rp <= end) {\n            // increment the left pointer \n            // if the right pointer element is bigger \n            // Since we are sorting in ascending order, left(smaller element) goes first\n            if (nums[lp] < nums[rp]) {\n                buffer[t++] = nums[lp++];\n            } else {\n                buffer[t++] = nums[rp++];\n            }\n        }\n        // Since in the above while loop if one condition stop satisfying loop breaks \n        // Then we need to take care of  next / remaining  elements\n        // merging remaining elements of left half \n        while (lp <= mi) buffer[t++] = nums[lp++];\n        // Merging remaining elements of right half\n        while (rp <= end) buffer[t++] = nums[rp++];\n        // copy sorted buffer into original array\n        for (int i = start; i <= end; i++) {\n            nums[i] = buffer[i - start];\n        }\n    }\n}\n")))),(0,i.kt)("h3",{id:"bottom-up-approach--iterative-technique"},"Bottom Up Approach / Iterative technique"),(0,i.kt)("h4",{id:"algorithm-2"},"Algorithm"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"It starts with an element in the array. It is an iterative approach and because one item array is always sorted")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Compares two nearby elements to merge into a sorted subarray. Similarly, we then merge the sorted subarrays like we have done in top-down recursive approach (two-pointer approach)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Continues until we have a sorted array "))),(0,i.kt)(c,{mdxType:"Tabs"},(0,i.kt)(h,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public List<Integer> sortArray(int[] nums) {\n        List<Integer> res = new ArrayList<>();\n        if (nums == null || nums.length == 0) return res;\n        mergeSort(nums);\n        for (int i : nums) res.add(i);\n        return res;\n    }    \n\n    // iterative only \n    private void mergeSort(int[] nums) { \n        // here the size is doubled by 2\n        // Since we are taking 2 elements at a time\n        // That is the size of elements to be merged are becoming 2, 4, 8, 16 ...\n        for (int size = 1; size < nums.length; size *= 2) {\n            for (int i = 0; i < nums.length - size; i += 2 * size) {\n                int mid = i + size - 1;\n                int end = Math.min(i + 2 * size - 1, nums.length - 1);\n                merge(nums, i, mid, end);\n            }\n        }\n    }\n\n    // Same as the merge function of the top down approach\n    private void merge(int[] nums, int l, int mid, int r) {\n        int[] tmp = new int[r - l + 1];\n        int i = l, j = mid + 1, k = 0;\n        while (i <= mid || j <= r) {\n            if (i > mid || j <= r && nums[i] > nums[j]) {\n                tmp[k++] = nums[j++];\n            } else {\n                tmp[k++] = nums[i++];\n            }\n        }\n        // merging rest of the elements \n        // this code is same as that of top down approach of merging remaining elements\n        System.arraycopy(tmp, 0, nums, l, r - l + 1);\n    }\n}\n")))),(0,i.kt)("p",null,"Merging of $n$ elements takes $n$ time and since each time the array is cut into half it takes $\\log",(0,i.kt)("em",{parentName:"p"},"{2}n$ time to reach the top.\nSo ",(0,i.kt)("strong",{parentName:"em"},"total time complexity is")," $O(n\\log"),"{2} n)$."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://cdn.kastatic.org/ka-perseus-images/5fcbebf66560d8fc490de2a0d8a0e5b1d65c5c54.png",alt:"image"})),(0,i.kt)("p",null,"Image taken from ",(0,i.kt)("a",{parentName:"p",href:"https://cdn.kastatic.org/"},"Khan Academy")),(0,i.kt)("p",null,"Merge Sort is a ",(0,i.kt)("strong",{parentName:"p"},"stable sort")," because the same element in an array maintain their original positions with respect to each other that means the original order of elements of input set is preserved. "),(0,i.kt)("p",null,"Merge sort copies of more than a constant number of array elements. Hence it requires additional space which depends upon the input size of the array elements.\nSo is an ",(0,i.kt)("strong",{parentName:"p"},"out of place algorithm"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Time Complexity"),": Best & Worst & Average is   $O(n \\log_{2} n)$"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Space Complexity"),": $O(n)$ "),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"For very large arrays Merge sort is in effienct as it allocates an extra space of $O(n)$ so we should go for Quick sort.")),(0,i.kt)("h2",{id:"example-0148---sort-list"},"Example: ",(0,i.kt)("a",{parentName:"h2",href:"https://leetcode.com/problems/sort-list/"},"0148 - Sort List")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Given the head of a linked list, return the list after sorting it in ascending order.")),(0,i.kt)("p",null,"Here we can follow both top-down and bottom-up merge sort."),(0,i.kt)("h3",{id:"approach-for-bottom-up-merge-sort-of-linked-list"},"Approach for Bottom-Up Merge Sort of Linked list"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The two lists to be merged must be ordered respectively."),(0,i.kt)("li",{parentName:"ol"},"We can only start to merge two lists that only have one element."),(0,i.kt)("li",{parentName:"ol"},"Then we get an ordered list that has two elements"),(0,i.kt)("li",{parentName:"ol"},'Do this again (that is "recursion").')),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/73426684/194309297-280720ca-b0fe-47be-a083-e0231336814d.jpg",alt:"bottom_up"})),(0,i.kt)("h3",{id:"approach-for-top-down-merge-sort-of-linked-list"},"Approach for Top-down Merge Sort of Linked list"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Keep recursively dividing the list until there is only one node in the linked list. "),(0,i.kt)("li",{parentName:"ol"},"Sort each sublist and merge each sorted sublist in a new array."),(0,i.kt)("li",{parentName:"ol"},"The two lists to be merged must be ordered respectively."),(0,i.kt)("li",{parentName:"ol"},"Here to order we must follow two pointer approach discussed above.")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/73426684/194311820-3cbf873e-1e57-4ebb-b336-4d6dc4475863.jpg",alt:"top_down_image"})),(0,i.kt)("h3",{id:"steps-to-apply-merge-sort-to-a-linked-list"},"Steps to apply merge sort to a Linked list"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note: Implementation is based on Merge Sort on an array as discussed above.")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Divide the linked list into two equal parts until when only one element is left."),(0,i.kt)("li",{parentName:"ol"},"To Divide, we need to find mid in the linked list using ",(0,i.kt)("strong",{parentName:"li"},"slow and fast pointers")," method."),(0,i.kt)("li",{parentName:"ol"},"Then merge the left and the right nodes of the linked list.")),(0,i.kt)(c,{mdxType:"Tabs"},(0,i.kt)(h,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"/*\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\n    void mergeSort(ListNode **head) {\n        // create a current pointer\n        ListNode *curr = *head ; \n        \n        ListNode * left;\n        ListNode * right;\n\n        // if the linked list is null \n        // or the size is one return back the same\n        if(curr == NULL || curr->next == NULL) return; \n\n        // call to find the middle node between left and right\n        findMiddle(curr, &left, &right);\n        \n        // call merge_sort again to divide left half\n        mergeSort(&left);\n        \n        // call merge_sort again to divide right half\n        mergeSort(&right);\n        \n        // call to merge left and right by sorting them\n        *head = merge(left, right);\n    }\n\n    void findMiddle(ListNode *curr, ListNode **left, ListNode **right) {\n        // make a slow pointer\n        ListNode* slow = curr;\n\n        // make a fast pointer \n        ListNode* fast = curr-> next; \n        \n        // then we move our fast up to it not become null\n        while(fast != NULL) {\n            fast = fast-> next;\n            if(fast != NULL) {\n                fast = fast-> next;\n                slow = slow-> next;\n            }\n        }\n        *left = curr;\n        // right to slow next\n        *right = slow-> next;\n\n        // and slow next to null \n        slow-> next = NULL;         \n    }\n\n    ListNode* merge(ListNode* left, ListNode* right) {\n        ListNode* res = NULL; \n        // Check if left is null, nothing to merge\n        if(left == NULL) return right;\n\n        if(right == NULL) return left;\n    \n        // if value of the left <= value of right\n        // then res = left\n\n        if(left-> val <= right-> val) {\n            res = left;\n            // and again call merge for res's next\n            res-> next = merge(left-> next, right);     \n        } else {\n            res = right;\n            // and again call merge for res's next\n            res-> next = merge(left, right-> next);      \n        }       \n        return res;\n    }\n\n    ListNode* sortList(ListNode* head) {\n        mergeSort(&head);\n        return head;\n    }\n};\n\n")))),(0,i.kt)(f,{title:"Suggested Problems",data:p,mdxType:"Table"}))}b.isMDXComponent=!0}}]);