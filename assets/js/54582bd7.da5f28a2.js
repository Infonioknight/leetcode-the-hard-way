"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[16998],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return u}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=c(n),u=r,g=m["".concat(s,".").concat(u)]||m[u]||p[u]||o;return n?a.createElement(g,i(i({ref:t},d),{},{components:n})):a.createElement(g,i({ref:t},d))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7902:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return s},default:function(){return f},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return p}});var a=n(87462),r=n(63366),o=(n(67294),n(3905)),i=["components"],l={description:"Author: @wingkwong | https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/",tags:["Array","Hash Table","String","Greedy","Counting"]},s="2131 - Longest Palindrome by Concatenating Two Letter Words (Medium)",c={unversionedId:"2100-2199/longest-palindrome-by-concatenating-two-letter-words-medium",id:"2100-2199/longest-palindrome-by-concatenating-two-letter-words-medium",title:"2131 - Longest Palindrome by Concatenating Two Letter Words (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/",source:"@site/solutions/2100-2199/2131-longest-palindrome-by-concatenating-two-letter-words-medium.md",sourceDirName:"2100-2199",slug:"/2100-2199/longest-palindrome-by-concatenating-two-letter-words-medium",permalink:"/leetcode-the-hard-way/solutions/2100-2199/longest-palindrome-by-concatenating-two-letter-words-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2100-2199/2131-longest-palindrome-by-concatenating-two-letter-words-medium.md",tags:[{label:"Array",permalink:"/leetcode-the-hard-way/solutions/tags/array"},{label:"Hash Table",permalink:"/leetcode-the-hard-way/solutions/tags/hash-table"},{label:"String",permalink:"/leetcode-the-hard-way/solutions/tags/string"},{label:"Greedy",permalink:"/leetcode-the-hard-way/solutions/tags/greedy"},{label:"Counting",permalink:"/leetcode-the-hard-way/solutions/tags/counting"}],version:"current",sidebarPosition:2131,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/",tags:["Array","Hash Table","String","Greedy","Counting"]},sidebar:"tutorialSidebar",previous:{title:"2127 - Maximum Employees to Be Invited to a Meeting (Hard)",permalink:"/leetcode-the-hard-way/solutions/2100-2199/maximum-employees-to-be-invited-to-a-meeting-hard"},next:{title:"2144 - Minimum Cost of Buying Candies With Discount (Easy)",permalink:"/leetcode-the-hard-way/solutions/2100-2199/minimum-cost-of-buying-candies-with-discount-easy"}},d={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Hash Map",id:"approach-1-hash-map",level:2}],m=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",t)}},u=m("Tabs"),g=m("TabItem"),h=m("SolutionAuthor"),b={toc:p};function f(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},b,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"2131---longest-palindrome-by-concatenating-two-letter-words-medium"},"2131 - Longest Palindrome by Concatenating Two Letter Words (Medium)"),(0,o.kt)("h2",{id:"problem-link"},"Problem Link"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/"},"https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/")),(0,o.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,o.kt)("p",null,"You are given an array of strings ",(0,o.kt)("inlineCode",{parentName:"p"},"words"),". Each element of ",(0,o.kt)("inlineCode",{parentName:"p"},"words")," consists of ",(0,o.kt)("strong",{parentName:"p"},"two")," lowercase English letters."),(0,o.kt)("p",null,"Create the ",(0,o.kt)("strong",{parentName:"p"},"longest possible palindrome")," by selecting some elements from ",(0,o.kt)("inlineCode",{parentName:"p"},"words")," and concatenating them in ",(0,o.kt)("strong",{parentName:"p"},"any order"),". Each element can be selected ",(0,o.kt)("strong",{parentName:"p"},"at most once"),"."),(0,o.kt)("p",null,"Return ",(0,o.kt)("em",{parentName:"p"},"the ",(0,o.kt)("strong",{parentName:"em"},"length")," of the longest palindrome that you can create"),". If it is impossible to create any palindrome, return ",(0,o.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,o.kt)("p",null,"A ",(0,o.kt)("strong",{parentName:"p"},"palindrome")," is a string that reads the same forward and backward."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 1:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'Input: words = ["lc","cl","gg"]\nOutput: 6\nExplanation: One longest palindrome is "lc" + "gg" + "cl" = "lcggcl", of length 6.\nNote that "clgglc" is another longest palindrome that can be created.\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 2:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'Input: words = ["ab","ty","yt","lc","cl","ab"]\nOutput: 8\nExplanation: One longest palindrome is "ty" + "lc" + "cl" + "yt" = "tylcclyt", of length 8.\nNote that "lcyttycl" is another longest palindrome that can be created.\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 3:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'Input: words = ["cc","ll","xx"]\nOutput: 2\nExplanation: One longest palindrome is "cc", of length 2.\nNote that "ll" is another longest palindrome that can be created, and so is "xx".\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Constraints:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"1 <= words.length <= 105")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"words[i].length == 2")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"words[i]")," consists of lowercase English letters.")),(0,o.kt)("h2",{id:"approach-1-hash-map"},"Approach 1: Hash Map"),(0,o.kt)(u,{mdxType:"Tabs"},(0,o.kt)(g,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,o.kt)(h,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'// a palindrome is a string that reads the same forward and backward\n// e.g. "aa", "abba", "aaaa", "lcggcl", etc ...\n// we can see that the left half part is the reversed version of the right half part\n// e.g. "a | a", "ab | ba", "aa | aa", "lcg | gcl", etc ...\n// for example, if we have "ab" and "ba", we can form "abba" which is a palindrome\n// and if we have "lc" and "cl", we can form "lccl"\n// and we can add it to the previous palindrome in the middle place to make it longer\n// e.g. ab[lccl]ba -> ablcclba\n\n// case 1: the word is not same as the reversed self, e.g. "ab" != "ba"\n// in this case, we need its reveresd string, i.e. ba to form "abba" as a palindrome\n\n// case 2: the word is same as the reversed self, e.g. "aa" == "aa"\n// case 2.1: if it is even, we could place it in the middle or on the side\n// e.g. [aa]abba[aa]\n// case 2.2: if the frequency of "aa" is odd, we could only place it in the middle\n// e.g. ab[aa]ba\n// since even + 1 = odd, we can put all even "aa" on the side, and put one in the middle\n// e.g. [aa]ab[aa]ba[aa]\n\nclass Solution {\npublic:\n    // to reverse a string, there are multiple ways to do it\n    // in this example, STL reverse will be used\n    string reversed(string s) {\n        string t = s;\n        reverse(t.begin(), t.end());\n        return t;\n    }\n    int longestPalindrome(vector<string>& words) {\n        int ans = 0, middle = 0;\n        // count the frequency of each word\n        unordered_map<string, int> cnt;\n        for (auto word : words) cnt[word]++;\n        for (auto [s, f] : cnt) {\n            // using rev(s) is just to generalise the solution\n            // in this problem, we can just check if s[0] != s[1]\n            string rev = reversed(s);\n            if (s != rev) {\n                // case 1: the word is not same as the reversed self, e.g. "ab" != "ba"\n                // find the reversed self\n                if (cnt.count(rev)) {\n                    // if it can be found, \n                    // then we can only include the min of their counts\n                    // e.g. "ab", "ba", "ba", "ba"\n                    // we can only form "abba" as we don\'t have enough "ab" for the rest of "ba"\n                    // p.s `cnt[s]` is same as `f`\n                    ans += min(cnt[s], cnt[rev]);\n                }\n                // Alternatively, you can use STL\n                // auto it = cnt.find(rev);\n                // if (it != cnt.end()) ans += min(f, it->second);\n                \n            } else {\n                // case 2: both character are same, e.g. aa\n                // we can put it on both side\n                ans += f;\n                // however, if the frequency is odd\n                if (f & 1) {\n                    // we can place one in the middle and others on the side\n                    middle = 1;\n                    ans -= 1;\n                }\n            }\n        }\n        ans += middle;\n        // at the end, we need to multiply the answer by 2\n        // e.g. if frequency of "aa" is 2, the longest palindrome is 4 ("aaaa")\n        return 2 * ans;\n    }\n};\n')))))}f.isMDXComponent=!0}}]);