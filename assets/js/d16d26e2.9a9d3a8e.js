"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[1263],{3905:(e,a,t)=>{t.d(a,{Zo:()=>h,kt:()=>u});var n=t(67294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function l(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=n.createContext({}),c=function(e){var a=n.useContext(s),t=a;return e&&(t="function"==typeof e?e(a):i(i({},a),e)),t},h=function(e){var a=c(e.components);return n.createElement(s.Provider,{value:a},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},d=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),p=c(t),d=r,u=p["".concat(s,".").concat(d)]||p[d]||m[d]||o;return t?n.createElement(u,i(i({ref:a},h),{},{components:t})):n.createElement(u,i({ref:a},h))}));function u(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=d;var l={};for(var s in a)hasOwnProperty.call(a,s)&&(l[s]=a[s]);l.originalType=e,l[p]="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=t[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}d.displayName="MDXCreateElement"},95275:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>s,contentTitle:()=>i,default:()=>g,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var n=t(87462),r=(t(67294),t(3905));const o={description:"Author: @wingkwong | https://leetcode.com/problems/break-a-palindrome/",tags:["String","Greedy"]},i="1328 - Break a Palindrome (Medium)",l={unversionedId:"1300-1399/break-a-palindrome-medium",id:"1300-1399/break-a-palindrome-medium",title:"1328 - Break a Palindrome (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/break-a-palindrome/",source:"@site/solutions/1300-1399/1328-break-a-palindrome-medium.md",sourceDirName:"1300-1399",slug:"/1300-1399/break-a-palindrome-medium",permalink:"/solutions/1300-1399/break-a-palindrome-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1300-1399/1328-break-a-palindrome-medium.md",tags:[{label:"String",permalink:"/solutions/tags/string"},{label:"Greedy",permalink:"/solutions/tags/greedy"}],version:"current",sidebarPosition:1328,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/break-a-palindrome/",tags:["String","Greedy"]},sidebar:"tutorialSidebar",previous:{title:"1305 - All Elements in Two Binary Search Trees (Medium)",permalink:"/solutions/1300-1399/all-elements-in-two-binary-search-trees-medium"},next:{title:"1329 - Sort the Matrix Diagonally (Medium)",permalink:"/solutions/1300-1399/sort-the-matrix-diagonally-medium"}},s={},c=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Greedy",id:"approach-1-greedy",level:2}],h=e=>function(a){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",a)},p=h("Tabs"),m=h("TabItem"),d=h("SolutionAuthor"),u={toc:c},b="wrapper";function g(e){let{components:a,...t}=e;return(0,r.kt)(b,(0,n.Z)({},u,t,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"1328---break-a-palindrome-medium"},"1328 - Break a Palindrome (Medium)"),(0,r.kt)("h2",{id:"problem-link"},"Problem Link"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/break-a-palindrome/"},"https://leetcode.com/problems/break-a-palindrome/")),(0,r.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.kt)("p",null,"Given a palindromic string of lowercase English letters ",(0,r.kt)("inlineCode",{parentName:"p"},"palindrome"),", replace ",(0,r.kt)("strong",{parentName:"p"},"exactly one")," character with any lowercase English letter so that the resulting string is ",(0,r.kt)("strong",{parentName:"p"},"not")," a palindrome and that it is the ",(0,r.kt)("strong",{parentName:"p"},"lexicographically smallest")," one possible."),(0,r.kt)("p",null,"Return ",(0,r.kt)("em",{parentName:"p"},"the resulting string. If there is no way to replace a character to make it not a palindrome, return an ",(0,r.kt)("strong",{parentName:"em"},"empty string"),".")),(0,r.kt)("p",null,"A string ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," is lexicographically smaller than a string ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," (of the same length) if in the first position where ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," differ, ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," has a character strictly smaller than the corresponding character in ",(0,r.kt)("inlineCode",{parentName:"p"},"b"),". For example, ",(0,r.kt)("inlineCode",{parentName:"p"},'"abcc"')," is lexicographically smaller than ",(0,r.kt)("inlineCode",{parentName:"p"},'"abcd"')," because the first position they differ is at the fourth character, and ",(0,r.kt)("inlineCode",{parentName:"p"},"'c'")," is smaller than ",(0,r.kt)("inlineCode",{parentName:"p"},"'d'"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Input: palindrome = "abccba"\nOutput: "aaccba"\nExplanation: There are many ways to make "abccba" not a palindrome, such as "zbccba", "aaccba", and "abacba".\nOf all the ways, "aaccba" is the lexicographically smallest.\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Input: palindrome = "a"\nOutput: ""\nExplanation: There is no way to replace a single character to make "a" not a palindrome, so return an empty string.\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Constraints:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"1 <= palindrome.length <= 1000")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"palindrome")," consists of only lowercase English letters.")),(0,r.kt)("h2",{id:"approach-1-greedy"},"Approach 1: Greedy"),(0,r.kt)("p",null,"If the input $$s$$ has the length of $1$, then the answer is an empty string because a single letter is always a palindrome. There is no way to make it not a palindrome."),(0,r.kt)("p",null,"If we need to make it lexicographically smallest one, that means we should replace a character with $a$ as early as possible (from the left to right). Therefore, we iterate the input and check the first index $$i$$ where $s","[i]","$ is not $a$. This is the position where we need to replace."),(0,r.kt)("p",null,"If there is no such position, that means all characters are $a$. In this case, the lexicographically smallest one is $$aaaaaab$$. We can simply change the last character to $b$."),(0,r.kt)(p,{mdxType:"Tabs"},(0,r.kt)(m,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'// Time Complexity: O(N)\n// Space Complexity: O(1)\nclass Solution {\npublic:\n    string breakPalindrome(string palindrome) {\n        int n = palindrome.size();\n        // there is no way to replace a single character to make "a" not a palindrome\n        // because no matter what we change, it is still a palindrome\n        if (n == 1) return "";\n        \n        // let\'s think about n = 2 case, e.g. "bb"\n        // in this case, to acheive the lexicographically smallest one\n        // we should replace from the left and the best character to use is "a"\n        // for "bb", we replace the first "b" to "a" to become "ab"\n        \n        // let\'s think about another n = 2 case, e.g. "aa"\n        // in this case, to acheive the lexicographically smallest one\n        // we should replace from the left and the best character to use is "a"\n        // however, for "aa", we cannot use "a" here and the best character to use is "b" now\n        // for "aa", we replace the second "a" to "b" to become "ab"\n        // why not replace the first "a"? because "ba" is not smallest.\n        \n        // since the input is a palindrome, we just need to check the first half only\n        for (int i = 0; i < n / 2; i++) {\n            //  here we know that as long as palindrome[i] is "a", we skip it\n            if (palindrome[i] != \'a\') {\n                // otherwise, we replace the first character that is not "a"\n                palindrome[i] = \'a\';\n                // replaced -> we can return the result here\n                return palindrome;\n            }\n        }\n        // by the time it reaches here, the possible cases would be like "aaa", "aba" etc. \n        // so that we haven\'t changed anything in above logic\n        // in this case, as mentioned above, the best character to use is "b"\n        // and we should replace the last character to achieve the smallest one possible\n        palindrome[n - 1] = \'b\';\n        return palindrome;\n    }\n};\n'))),(0,r.kt)(m,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'// Time Complexity: O(N)\n// Space Complexity: O(N) since we need to convert the string to char array\nclass Solution {\n    public String breakPalindrome(String palindrome) {\n        int n = palindrome.length();\n        // there is no way to replace a single character to make "a" not a palindrome\n        // because no matter what we change, it is still a palindrome\n        if (n == 1) return "";\n        \n        char[] p = palindrome.toCharArray();\n        \n        // let\'s think about n = 2 case, e.g. "bb"\n        // in this case, to acheive the lexicographically smallest one\n        // we should replace from the left and the best character to use is "a"\n        // for "bb", we replace the first "b" to "a" to become "ab"\n        \n        // let\'s think about another n = 2 case, e.g. "aa"\n        // in this case, to acheive the lexicographically smallest one\n        // we should replace from the left and the best character to use is "a"\n        // however, for "aa", we cannot use "a" here and the best character to use is "b" now\n        // for "aa", we replace the second "a" to "b" to become "ab"\n        // why not replace the first "a"? because "ba" is not smallest.\n        \n        for (int i = 0; i < n / 2; i++) {\n            //  here we know that as long as palindrome[i] is "a", we skip it\n            if (p[i] != \'a\') {\n                // otherwise, we replace the first character that is not "a"\n                p[i] = \'a\';\n                // replaced -> we can return the result here\n                return new String(p);\n            }\n        }\n        // by the time it reaches here, the possible cases would be like "aaa", "aba" etc. \n        // so that we haven\'t changed anything in above logic\n        // in this case, as mentioned above, the best character to use is "b"\n        // and we should replace the last character to achieve the smallest one possible\n        p[n - 1] = \'b\';\n        return new String(p);\n    }\n}\n'))),(0,r.kt)(m,{value:"go",label:"Go",mdxType:"TabItem"},(0,r.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'// Time Complexity: O(N)\n// Space Complexity: O(1)\nfunc breakPalindrome(palindrome string) string {\n    n := len(palindrome)\n    // there is no way to replace a single character to make "a" not a palindrome\n    // because no matter what we change, it is still a palindrome\n    if n == 1 {\n        return ""\n    }\n    // let\'s think about n = 2 case, e.g. "bb"\n    // in this case, to acheive the lexicographically smallest one\n    // we should replace from the left and the best character to use is "a"\n    // for "bb", we replace the first "b" to "a" to become "ab"\n    \n    // let\'s think about another n = 2 case, e.g. "aa"\n    // in this case, to acheive the lexicographically smallest one\n    // we should replace from the left and the best character to use is "a"\n    // however, for "aa", we cannot use "a" here and the best character to use is "b" now\n    // for "aa", we replace the second "a" to "b" to become "ab"\n    // why not replace the first "a"? because "ba" is not smallest.\n    \n    // since the input is a palindrome, we just need to check the first half only\n    for i := 0; i < n / 2; i++ {\n        //  here we know that as long as palindrome[i] is "a", we skip it\n        if palindrome[i] != \'a\' {\n            // otherwise, we replace the first character that is not "a"\n            // replaced -> we can return the result here\n            return palindrome[:i] + "a" + palindrome[i + 1:]\n        }\n    }\n    // by the time it reaches here, the possible cases would be like "aaa", "aba" etc. \n    // so that we haven\'t changed anything in above logic\n    // in this case, as mentioned above, the best character to use is "b"\n    // and we should replace the last character to achieve the smallest one possible\n    return palindrome[: n - 1] + "b"\n}\n'))),(0,r.kt)(m,{value:"py",label:"Python",mdxType:"TabItem"},(0,r.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'# Time Complexity: O(N)\n# Space Complexity: O(1)\nclass Solution:\n    def breakPalindrome(self, palindrome: str) -> str:\n        n = len(palindrome)\n        # there is no way to replace a single character to make "a" not a palindrome\n        # because no matter what we change, it is still a palindrome\n        if n == 1:\n            return \'\'\n        # let\'s think about n = 2 case, e.g. "bb"\n        # in this case, to acheive the lexicographically smallest one\n        # we should replace from the left and the best character to use is "a"\n        # for "bb", we replace the first "b" to "a" to become "ab"\n        \n        # let\'s think about another n = 2 case, e.g. "aa"\n        # in this case, to acheive the lexicographically smallest one\n        # we should replace from the left and the best character to use is "a"\n        # however, for "aa", we cannot use "a" here and the best character to use is "b" now\n        # for "aa", we replace the second "a" to "b" to become "ab"\n        # why not replace the first "a"? because "ba" is not smallest.\n        for i in range(n // 2):\n            #  here we know that as long as palindrome[i] is "a", we skip it\n            if palindrome[i] != \'a\':\n                # otherwise, we replace the first character that is not "a"\n                return palindrome[:i] + \'a\' + palindrome[i + 1:]\n        # by the time it reaches here, the possible cases would be like "aaa", "aba" etc. \n        # so that we haven\'t changed anything in above logic\n        # in this case, as mentioned above, the best character to use is "b"\n        # and we should replace the last character to achieve the smallest one possible\n        return palindrome[:-1] + \'b\'\n')))))}g.isMDXComponent=!0}}]);