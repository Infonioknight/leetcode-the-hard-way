"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[84810],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>k});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),d=i,k=u["".concat(l,".").concat(d)]||u[d]||m[d]||o;return n?a.createElement(k,r(r({ref:t},p),{},{components:n})):a.createElement(k,r({ref:t},p))}));function k(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},32239:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,suggestedProblems:()=>p,toc:()=>c});var a=n(87462),i=(n(67294),n(3905));const o={title:"Backtracking",description:"A backtracking algorithm is used to construct a solution recursively by starting with an empty solution and adding solution one by one.",hide_table_of_contents:!0,keywords:["leetcode","tutorial","backtracking","algorithm"]},r=void 0,s={unversionedId:"basic-topics/backtracking",id:"basic-topics/backtracking",title:"Backtracking",description:"A backtracking algorithm is used to construct a solution recursively by starting with an empty solution and adding solution one by one.",source:"@site/tutorials/basic-topics/backtracking.md",sourceDirName:"basic-topics",slug:"/basic-topics/backtracking",permalink:"/tutorials/basic-topics/backtracking",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/basic-topics/backtracking.md",tags:[],version:"current",frontMatter:{title:"Backtracking",description:"A backtracking algorithm is used to construct a solution recursively by starting with an empty solution and adding solution one by one.",hide_table_of_contents:!0,keywords:["leetcode","tutorial","backtracking","algorithm"]},sidebar:"tutorialSidebar",previous:{title:"Arrays",permalink:"/tutorials/basic-topics/arrays"},next:{title:"Binary Search",permalink:"/tutorials/basic-topics/binary-search"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Example: 0046 - Permutations (Medium)",id:"example-0046---permutations-medium",level:2}],p=[{problemName:"0039 - Combination Sum",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/combination-sum/",solutionLink:"../../solutions/0000-0099/combination-sum-medium"},{problemName:"0040 - Combination Sum II",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/combination-sum-ii/",solutionLink:"../../solutions/0000-0099/combination-sum-ii-medium"},{problemName:"0046 - Permutations",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/permutations/",solutionLink:"../../solutions/0000-0099/permutations-medium"},{problemName:"0078 - Subsets",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/subsets/",solutionLink:"../../solutions/0000-0099/subsets-medium"}],u=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",t)},m=u("TutorialAuthors"),d=u("Table"),k={toc:c,suggestedProblems:p},b="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(b,(0,a.Z)({},k,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)(m,{names:"@wingkwong",mdxType:"TutorialAuthors"}),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,'Backtracking is a general algorithmic technique that involves exploring all possible solutions to a problem by incrementally building a solution and then undoing (or "backtracking" on) the choices that lead to dead ends. It is a form of depth-first search and is particularly useful for solving problems that involve searching through a large number of possibilities, such as finding all possible solutions to a problem or finding the one solution that satisfies a set of constraints.'),(0,i.kt)("p",null,"The steps for using backtracking to solve a problem are as follows:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Understand the problem and its requirements by reading the problem statement and examples."),(0,i.kt)("li",{parentName:"ol"},"Develop a recursive algorithm that incrementally builds a solution and backtracks when a dead end is reached."),(0,i.kt)("li",{parentName:"ol"},"Define a base case for the recursion that indicates when a complete solution has been found, and a terminating condition that indicates when to stop the recursion."),(0,i.kt)("li",{parentName:"ol"},"Test the solution on the provided test cases to check if it works correctly and returns the expected output.")),(0,i.kt)("p",null,"Backtracking can be used for various of problems such as:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Generating all possible combinations of a set of items."),(0,i.kt)("li",{parentName:"ul"},"Finding all possible solutions to a problem"),(0,i.kt)("li",{parentName:"ul"},"Finding a specific solution that satisfies a set of constraints."),(0,i.kt)("li",{parentName:"ul"},"Solving puzzles or other combinatorial problems"),(0,i.kt)("li",{parentName:"ul"},"And many more")),(0,i.kt)("p",null,"Backtracking can be very inefficient, especially when the number of possible solutions or the size of the input is large. Therefore, it is important to carefully analyze the problem and develop an efficient backtracking algorithm."),(0,i.kt)("h2",{id:"example-0046---permutations-medium"},"Example: ",(0,i.kt)("a",{parentName:"h2",href:"../../solutions/0000-0099/permutations-medium"},"0046 - Permutations (Medium)")),(0,i.kt)("p",null,"If we have an array $nums$ of distinct integers, what are all the possible permutations? If the input is $","[1,2,3]","$, then the permutations would be $[","[1,2,3]",",","[1,3,2]",",","[2,1,3]",",","[2,3,1]",",","[3,1,2]",",","[3,2,1]","]$. In C++, it is easy to solve this problem by using the built-in STL ",(0,i.kt)("strong",{parentName:"p"},"next_permutation"),". However, we can also solve it using backtracking."),(0,i.kt)("p",null,"The general steps are as follows."),(0,i.kt)("p",null,"1","."," Sort the input array if necessary. However, in this example, sorting is not necessary."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"sort(nums.begin(), nums.end());\n")),(0,i.kt)("p",null,"2","."," Define ",(0,i.kt)("inlineCode",{parentName:"p"},"ans")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"tmp")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"ans")," is the array storing all final permutations and ",(0,i.kt)("inlineCode",{parentName:"p"},"tmp")," is used to store possible permutations at some point."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"vector<vector<int>> ans;\nvector<int> tmp;\n")),(0,i.kt)("p",null,"3","."," Call ",(0,i.kt)("inlineCode",{parentName:"p"},"backtrack()")," function in main"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"backtrack(nums, ans, tmp);\n")),(0,i.kt)("p",null,"4","."," Let's add logic in ",(0,i.kt)("inlineCode",{parentName:"p"},"backtrack()")," function. First we need to define the exit criteria. When should we push ",(0,i.kt)("inlineCode",{parentName:"p"},"tmp")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"ans"),"? If ",(0,i.kt)("inlineCode",{parentName:"p"},"tmp")," already got enough candidates, then we can push ",(0,i.kt)("inlineCode",{parentName:"p"},"tmp")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"ans"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"if ((int) tmp.size() == (int) nums.size()) {\n    ans.push_back(tmp);\n    return;\n}\n")),(0,i.kt)("p",null,"5","."," Iterate each number, check If the candidate has been used or not, skip it if it is already in ",(0,i.kt)("inlineCode",{parentName:"p"},"tmp"),". Otherwise, push it to ",(0,i.kt)("inlineCode",{parentName:"p"},"tmp")," and call ",(0,i.kt)("inlineCode",{parentName:"p"},"backtrack()")," again. After that, remove the previous candidate from ",(0,i.kt)("inlineCode",{parentName:"p"},"tmp")," and move to the next candidate."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"for (auto x : nums) {\n    if (find(tmp.begin(), tmp.end(), x) != tmp.end()) continue;\n    tmp.push_back(x);\n    backtrack(nums, ans, tmp);\n    tmp.pop_back();   \n}\n")),(0,i.kt)(d,{title:"Suggested Problems",data:p,mdxType:"Table"}))}h.isMDXComponent=!0}}]);