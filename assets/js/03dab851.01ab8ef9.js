"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[5613],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>f});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),d=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=d(e.components);return r.createElement(s.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),p=d(n),c=o,f=p["".concat(s,".").concat(c)]||p[c]||u[c]||a;return n?r.createElement(f,i(i({ref:t},h),{},{components:n})):r.createElement(f,i({ref:t},h))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:o,i[1]=l;for(var d=2;d<a;d++)i[d]=n[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},9117:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>g,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var r=n(87462),o=(n(67294),n(3905));const a={description:"Author: @ColeB2, @radojicic23 | https://leetcode.com/problems/invert-binary-tree/",tags:["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},i="0226 - Invert Binary Tree (Easy)",l={unversionedId:"0200-0299/invert-binary-tree-easy",id:"0200-0299/invert-binary-tree-easy",title:"0226 - Invert Binary Tree (Easy)",description:"Author: @ColeB2, @radojicic23 | https://leetcode.com/problems/invert-binary-tree/",source:"@site/solutions/0200-0299/0226-invert-binary-tree-easy.md",sourceDirName:"0200-0299",slug:"/0200-0299/invert-binary-tree-easy",permalink:"/solutions/0200-0299/invert-binary-tree-easy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0200-0299/0226-invert-binary-tree-easy.md",tags:[{label:"Tree",permalink:"/solutions/tags/tree"},{label:"Depth-First Search",permalink:"/solutions/tags/depth-first-search"},{label:"Breadth-First Search",permalink:"/solutions/tags/breadth-first-search"},{label:"Binary Tree",permalink:"/solutions/tags/binary-tree"}],version:"current",sidebarPosition:226,frontMatter:{description:"Author: @ColeB2, @radojicic23 | https://leetcode.com/problems/invert-binary-tree/",tags:["Tree","Depth-First Search","Breadth-First Search","Binary Tree"]},sidebar:"tutorialSidebar",previous:{title:"0225 - Implement Stack using Queues (Easy)",permalink:"/solutions/0200-0299/implement-stack-using-queues-easy"},next:{title:"0228 - Summary Ranges (Easy)",permalink:"/solutions/0200-0299/summary-ranges-easy"}},s={},d=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Recursive Depth-First Search",id:"approach-1-recursive-depth-first-search",level:2},{value:"Approach 2: Iterative Depth-First Search",id:"approach-2-iterative-depth-first-search",level:2},{value:"Approach 3: Iterative Breadth-First Search",id:"approach-3-iterative-breadth-first-search",level:2}],h=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",t)},p=h("Tabs"),u=h("TabItem"),c=h("SolutionAuthor"),f={toc:d},m="wrapper";function g(e){let{components:t,...n}=e;return(0,o.kt)(m,(0,r.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"0226---invert-binary-tree-easy"},"0226 - Invert Binary Tree (Easy)"),(0,o.kt)("h2",{id:"problem-link"},"Problem Link"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/invert-binary-tree/"},"https://leetcode.com/problems/invert-binary-tree/")),(0,o.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,o.kt)("p",null,"Given the ",(0,o.kt)("inlineCode",{parentName:"p"},"root")," of a binary tree, invert the tree, and return ",(0,o.kt)("em",{parentName:"p"},"its root"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 1:")),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg",alt:null})),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 2:")),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg",alt:null})),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: root = [2,1,3]\nOutput: [2,3,1]\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 3:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: root = []\nOutput: []\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Constraints:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The number of nodes in the tree is in the range ",(0,o.kt)("inlineCode",{parentName:"li"},"[0, 100]"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"100 <= Node.val <= 100"))),(0,o.kt)("h2",{id:"approach-1-recursive-depth-first-search"},"Approach 1: Recursive Depth-First Search"),(0,o.kt)("p",null,"Like many tree problems, they can often be solved with recursion, and this problem is no exception. When solving problems recursively it helps to think the problem through and think up the base case(s)."),(0,o.kt)("p",null,"So looking at the problem, and the images, it appears that this problem is asking us to swap each child for each node. Then know that we can think about what happens if we reach the end, a node that has a value of null. That is our base case. If we reach a null node, we can just return the node. "),(0,o.kt)("p",null,"Knowing that is our base case, all we are left with is understanding how to swap our children nodes. We can do that using a temporary variable to track the left child so we don't lose it. Setting the root node's left pointer to the right child, then setting the root node's right pointer to the temporary variable, which was our left child."),(0,o.kt)("p",null,"Simply that is it, then we can call our algorithm recursively on both the left and right children (or right to left, we will end up with the same answer), and finally return our root."),(0,o.kt)("p",null,"Time Complexity: $$O(n)$$ where n is the number of nodes in our binary tree, as we have to visit each node at least once."),(0,o.kt)("p",null,"Space Complexity: $$O(n)$$ for the size of our recursive call stack. Their will be $$O(h)$$ where h is the height of the tree function calls in our call stack, but in the worst case, ie a tree with only right child nodes, that will reach $$O(n)$$."),(0,o.kt)(p,{mdxType:"Tabs"},(0,o.kt)(u,{value:"python",label:"Python",mdxType:"TabItem"},(0,o.kt)(c,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-py"},"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        # Base case\n        if not root:\n            return root\n        # Temp node so as not to lose the left child.\n        tmp = root.left\n        # set root's left pointer to the right child node.\n        root.left = root.right\n        # set root's right pointer to point at the tmp node, which is our left\n        # child node.\n        root.right = tmp\n        # Note in python we could simplify the swapping as:\n        # root.left, root.right = root.right, root.left\n        # call our function recursively on both the left and right children.\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        # return root node.\n        return root\n"))),(0,o.kt)(u,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,o.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar invertTree = function(root) {\n    // base case\n    if (!root) {\n        return root;\n    }\n    // swap left and right nodes\n    let tmp = root.left;\n    root.left = root.right;\n    root.right = tmp;\n    // call function recursively on left and right nodes\n    invertTree(root.left);\n    invertTree(root.right);\n    // return root node \n    return root;\n};\n"))),(0,o.kt)(u,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,o.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        // base case\n        if (!root) {\n            return root;\n        }\n        // swap left and right node\n        TreeNode* tmp = root->left;\n        root->left = root->right;\n        root->right = tmp;\n        // call function recursively on left and right nodes\n        invertTree(root->left);\n        invertTree(root->right);\n        // return root node\n        return root;\n    }\n};\n")))),(0,o.kt)("h2",{id:"approach-2-iterative-depth-first-search"},"Approach 2: Iterative Depth-First Search"),(0,o.kt)("p",null,"The iterative approach may be a little tricky if you've never seen it done before. To pull it off, we need a stack, and we can initialize it with our root node. Then while the stack contains values, we can pop them off the stack during each iteration. Similar to the recursive, during each iteration, all we have to do is swap our left and right child nodes, then add them to the stack to be processed themselves."),(0,o.kt)("p",null,"Time Complexity: $$O(n)$$ where n is the number of nodes in our binary tree, as we have to visit each node at least once."),(0,o.kt)("p",null,"Space Complexity: $$O(n)$$ for the size of the stack, as the size our stack reaches will be dependent on the number of nodes in the binary tree."),(0,o.kt)(p,{mdxType:"Tabs"},(0,o.kt)(u,{value:"python",label:"Python",mdxType:"TabItem"},(0,o.kt)(c,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-py"},"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        # Given null as a tree, return early.\n        if not root:\n            return root\n        # Initialize our stack with the root node inside.\n        stack = [root]\n        # Iterate through each value in the stack.\n        while stack:\n            # pop the node off the end of the stack. O(1) time\n            node = stack.pop()\n            # Python we can swap left and right children simply like this:\n            node.left, node.right = node.right, node.left\n            # Check if the node has a child before adding it to the stack:\n            # this makes error checking a lot easier, as we don't need to check\n            # whether the node exists before swapping the left and right children\n            # as we won't ever add the None nodes to the stack.\n            if node.left:\n                stack.append(node.left)\n            # repeat for right child\n            if node.right:\n                stack.append(node.right)\n        # return root node.\n        return root\n"))),(0,o.kt)(u,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,o.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar invertTree = function(root) {\n    // base case\n    if (!root) {\n        return root;\n    }\n    // initialize stack and add root inside\n    stack = [];\n    stack.push(root);\n    // go through every value in stack\n    while (stack.length) {\n        // pop the last node from the stack\n        let node = stack.pop();\n        if (node != null) {\n            // swap left and right nodes\n            let tmp = node.left;\n            node.left = node.right;\n            node.right = tmp;\n            // add left and right nodes in stack\n            stack.push(node.left, node.right);\n        } \n    }\n    // return root node \n    return root;\n};\n"))),(0,o.kt)(u,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,o.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        // base case \n        if (!root) {\n            return root;\n        }\n        // initialize stack and add root inside \n        stack<TreeNode*> st;\n        st.push(root);\n        // go through every value in stack\n        while (!st.empty()) {\n            // pop the last node from the stack\n            TreeNode* node = st.top();\n            st.pop();\n            // if node exist\n            if (node != NULL) {\n                // swap left and right nodes\n                TreeNode* tmp = node->left;\n                node->left = node->right;\n                node->right = tmp;\n                // insert left and right nodes in stack\n                st.push(node->left);\n                st.push(node->right);\n            }\n        }\n        // return root node\n        return root;\n    }\n};\n")))),(0,o.kt)("h2",{id:"approach-3-iterative-breadth-first-search"},"Approach 3: Iterative Breadth-First Search"),(0,o.kt)("p",null,"Similarly, in most cases where you can do an iterative DFS, you can also do an iterative BFS using a queue. It will be the same idea as iterative DFS, just using a queue, meaning we will add nodes to the right side of our queue and pop them off the left side of our queue instead."),(0,o.kt)("p",null,"Time Complexity: $$O(n)$$ where n is the number of nodes in our binary tree, as we have to visit each node at least once."),(0,o.kt)("p",null,"Space Complexity: $$O(n)$$ for the size of the queue. In the worst case we will have a full level of nodes inside our queue, which in a full tree, the last level will contain $$\\frac {n}{2}$$ nodes, which for our case means $$O(n)$$ space."),(0,o.kt)(p,{mdxType:"Tabs"},(0,o.kt)(u,{value:"python",label:"Python",mdxType:"TabItem"},(0,o.kt)(c,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-py"},"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        # Given None as a root node, we can return early.\n        if not root:\n            return root\n        # initialize our our queue with root node as our first value.\n        q = deque([root])\n        while q:\n            # pop root node off the left side of our queue.\n            node = q.popleft()\n            # swap the children nodes.\n            node.left, node.right = node.right, node.left\n            # only add the node to the q's right side, if the node exists.\n            if node.left:\n                q.append(node.left)\n            # same for the right node.\n            if node.right:\n                q.append(node.right)\n        # return the root.\n        return root\n"))),(0,o.kt)(u,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,o.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        // base case\n        if (!root) {\n            return root;\n        }\n        // inititalize queue\n        queue<TreeNode*> q;\n        // insert root inside queue\n        q.push(root);\n        // go through all values in queue\n        while (!q.empty()) {\n            // pop the front node from queue\n            TreeNode* node = q.front();\n            q.pop();\n            // if node exist\n            if (node != NULL) {\n                // swap left and right nodes\n                TreeNode* tmp = node->left;\n                node->left = node->right;\n                node->right = tmp;\n                // insert left and right nodes in queue\n                q.push(node->left);\n                q.push(node->right);\n            }\n        }\n        // return root node\n        return root;\n    }\n};\n"))),(0,o.kt)(u,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,o.kt)(c,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar invertTree = function(root) {\n    // base case\n    if (!root) {\n        return root;\n    }\n    // initialize queue and insert root inside queue\n    let q = new Queue();\n    q.enqueue(root);\n    // go through all elements in queue\n    while (!q.isEmpty()) {\n        // pop the front node from queue\n        let node = q.dequeue();\n        // if node exist\n        if (node) {\n            // swap left and right nodes\n            let tmp = node.left;\n            node.left = node.right;\n            node.right = tmp;\n            // insert left and right nodes in queue\n            q.enqueue(node.left);\n            q.enqueue(node.right);\n        }\n    }\n    // return root node\n    return root;\n};\n")))))}g.isMDXComponent=!0}}]);