"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[18041],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},h="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),h=p(n),c=o,d=h["".concat(s,".").concat(c)]||h[c]||m[c]||r;return n?a.createElement(d,i(i({ref:t},u),{},{components:n})):a.createElement(d,i({ref:t},u))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[h]="string"==typeof e?e:o,i[1]=l;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},36361:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>f,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(87462),o=(n(67294),n(3905));const r={description:"Author: @ColeB2 | https://leetcode.com/problems/evaluate-reverse-polish-notation/",tags:["Array","Math","Stack"]},i="0150 - Evaluate Reverse Polish Notation (Medium)",l={unversionedId:"0100-0199/evaluate-reverse-olish-notation-medium",id:"0100-0199/evaluate-reverse-olish-notation-medium",title:"0150 - Evaluate Reverse Polish Notation (Medium)",description:"Author: @ColeB2 | https://leetcode.com/problems/evaluate-reverse-polish-notation/",source:"@site/solutions/0100-0199/0150-evaluate-reverse-olish-notation-medium.md",sourceDirName:"0100-0199",slug:"/0100-0199/evaluate-reverse-olish-notation-medium",permalink:"/solutions/0100-0199/evaluate-reverse-olish-notation-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0100-0199/0150-evaluate-reverse-olish-notation-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Math",permalink:"/solutions/tags/math"},{label:"Stack",permalink:"/solutions/tags/stack"}],version:"current",sidebarPosition:150,frontMatter:{description:"Author: @ColeB2 | https://leetcode.com/problems/evaluate-reverse-polish-notation/",tags:["Array","Math","Stack"]},sidebar:"tutorialSidebar",previous:{title:"0148 - Sort List (Medium)",permalink:"/solutions/0100-0199/sort-list-medium"},next:{title:"0152 - Maximum Product Subarray (Medium)",permalink:"/solutions/0100-0199/maximum-product-subarray-medium"}},s={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Stack",id:"approach-1-stack",level:2}],u=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",t)},h=u("Tabs"),m=u("TabItem"),c=u("SolutionAuthor"),d={toc:p},k="wrapper";function f(e){let{components:t,...n}=e;return(0,o.kt)(k,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"0150---evaluate-reverse-polish-notation-medium"},"0150 - Evaluate Reverse Polish Notation (Medium)"),(0,o.kt)("h2",{id:"problem-link"},"Problem Link"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/evaluate-reverse-polish-notation/"},"https://leetcode.com/problems/evaluate-reverse-polish-notation/")),(0,o.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,o.kt)("p",null,"Evaluate the value of an arithmetic expression in ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Reverse_Polish_notation"},"Reverse Polish Notation"),"."),(0,o.kt)("p",null,"Valid operators are ",(0,o.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"-"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"*"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"/"),". Each operand may be an integer or another expression."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note")," that division between two integers should truncate toward zero."),(0,o.kt)("p",null,"It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 1:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'Input: tokens = ["2","1","+","3","*"]\nOutput: 9\nExplanation: ((2 + 1) * 3) = 9\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 2:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'Input: tokens = ["4","13","5","/","+"]\nOutput: 6\nExplanation: (4 + (13 / 5)) = 6\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 3:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'Input: tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]\nOutput: 22\nExplanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Constraints:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"1 <= tokens.length <= 10^4")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"tokens[i]")," is either an operator: ",(0,o.kt)("inlineCode",{parentName:"li"},'"+"'),", ",(0,o.kt)("inlineCode",{parentName:"li"},'"-"'),", ",(0,o.kt)("inlineCode",{parentName:"li"},'"*"'),", or ",(0,o.kt)("inlineCode",{parentName:"li"},'"/"'),", or an integer in the range ",(0,o.kt)("inlineCode",{parentName:"li"},"[-200, 200]"),".")),(0,o.kt)("h2",{id:"approach-1-stack"},"Approach 1: Stack"),(0,o.kt)("p",null,"We need to understand that Reverse Polish Notation aka postfix notation, is a notation where the operators follow the operands. Meaning when we iterate through ",(0,o.kt)("inlineCode",{parentName:"p"},"tokens")," we are going to reach at least 2 numbers before we reach an operator. Example: ",(0,o.kt)("inlineCode",{parentName:"p"},'["2","1","+"]')," This also resembles how a stack works, so by placing numbers in a stack, we will have access to the last 2 numbers that entered the stack, so that we can pop them off to perform the operation whenever we reach the operator."),(0,o.kt)("p",null,"The main problem to solve is now that we know we need to use a stack, but in which order do we handle our operations? For addition and multiplication, the order won't matter, but for subtraction and division, there is a difference depending on which number subtracts from which, or which is the dividend. By analyzing the examples we can see that the first number that gets popped off the stack appears to be our ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," value, and the second appears to be our ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," value in any expression $x / y$ or $x - y$."),(0,o.kt)("p",null,"Example: if our stack looks like: ",(0,o.kt)("inlineCode",{parentName:"p"},"[4,2]"),", and our token is ",(0,o.kt)("inlineCode",{parentName:"p"},"/"),". The expression should be analyzed as y=2, x=4 as we pop off the y first then the x, which will give us an answer of $4/2=2$ and not $2/4=0.5$ which would truncate towards 0 as 0."),(0,o.kt)("p",null,"Note: We can also significantly improve readability by utilizing a hash map, and lambda functions to map our operators to the operations they perform, instead of nesting a bunch of if/else clauses. But we could also utilize if/else, or switch cases, then for each case, ",(0,o.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"-"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"*"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"/"),", perform the required operation/function utilizing the top 2 numbers from the stack as the parameters."),(0,o.kt)("p",null,"Time Complexity: $$O(n)$$ where n is the length of the input, tokens."),(0,o.kt)("p",null,"Space Complexity: $$O(n)$$ for our stack, which will depend on the length of the input, tokens."),(0,o.kt)(h,{mdxType:"Tabs"},(0,o.kt)(m,{value:"python",label:"Python",mdxType:"TabItem"},(0,o.kt)(c,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-py"},'class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        # First we initialize our hash map which will map our\n        # operators directly to the operations they perform.\n        # We also utilize lambda functions, which are just anonymous,\n        # nameless function.\n        # "+" maps to function which takes params x,y and adds them.\n        # "-" maps to function which takes params x,y and subtracts them.\n        # "*" maps to function which takes params x,y and multiplies them.\n        # "/" maps to function which takes params x,y and divides them.\n        # Note "/" utilizes regular division, but converts the float to an \n        # int to handle the requirement of needing to truncate towards 0.\n        ops = {\n            "+": lambda x, y : (x + y),\n            "-": lambda x, y : (x - y),\n            "*": lambda x, y : (x * y),\n            "/": lambda x, y : int(x/y)\n        }\n        # initialize an empty stack.\n        stack = []\n        # Loop through each token in tokens, O(n) time, where n is the number of tokens.\n        for token in tokens:\n            # Check if our token is in our ops hash map. O(1) to check.\n            if token in ops:\n                # It is, then we pop, remembering the order of y first, then x.\n                y,x = stack.pop(), stack.pop()\n                # solve our answer, by calling our lambda function by first\n                # accessing the value of our hash map the same way we would any \n                # hash map, then, since we know it will return a function, to supply\n                # the parameters that the function will need, which we know is x,y.\n                answer = ops[token](x,y)\n                # remember to append the answer to the stack.\n                stack.append(answer)\n            # If token is NOT a operator, but a number, add the token to the stack.\n            # Remember that we are reading through an array of strings, so \n            # we will convert to an integer first here, to prevent having to convert\n            # later when we need to pop it off.\n            else:\n                stack.append(int(token))\n        # Our stack should be empty except for the answer, so we can return that\n        # value that is left in the stack.\n        return stack[-1]\n')))))}f.isMDXComponent=!0}}]);