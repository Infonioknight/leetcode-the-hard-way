"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[26050],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),s=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=s(e.components);return r.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,m=p(e,["components","mdxType","originalType","parentName"]),u=s(n),c=a,h=u["".concat(l,".").concat(c)]||u[c]||d[c]||i;return n?r.createElement(h,o(o({ref:t},m),{},{components:n})):r.createElement(h,o({ref:t},m))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=c;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p[u]="string"==typeof e?e:a,o[1]=p;for(var s=2;s<i;s++)o[s]=n[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},4982:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>y,frontMatter:()=>i,metadata:()=>p,toc:()=>s});var r=n(87462),a=(n(67294),n(3905));const i={description:"Author: @Kavita613 | https://leetcode.com/problems/path-with-maximum-probability/",tags:["Graph","Heap (Priority Queue)","Shortest Path"]},o="1514 - Path with Maximum Probability (Medium)",p={unversionedId:"1500-1599/path-with-maximum-probability",id:"1500-1599/path-with-maximum-probability",title:"1514 - Path with Maximum Probability (Medium)",description:"Author: @Kavita613 | https://leetcode.com/problems/path-with-maximum-probability/",source:"@site/solutions/1500-1599/1514-path-with-maximum-probability.md",sourceDirName:"1500-1599",slug:"/1500-1599/path-with-maximum-probability",permalink:"/solutions/1500-1599/path-with-maximum-probability",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1500-1599/1514-path-with-maximum-probability.md",tags:[{label:"Graph",permalink:"/solutions/tags/graph"},{label:"Heap (Priority Queue)",permalink:"/solutions/tags/heap-priority-queue"},{label:"Shortest Path",permalink:"/solutions/tags/shortest-path"}],version:"current",sidebarPosition:1514,frontMatter:{description:"Author: @Kavita613 | https://leetcode.com/problems/path-with-maximum-probability/",tags:["Graph","Heap (Priority Queue)","Shortest Path"]},sidebar:"tutorialSidebar",previous:{title:"1510 - Stone Game IV (Hard)",permalink:"/solutions/1500-1599/stone-game-iv-hard"},next:{title:"1519 - Number of Nodes in the Sub-Tree With the Same Label (Medium)",permalink:"/solutions/1500-1599/number-of-nodes-in-the-sub-tree-with-the-same-label-medium"}},l={},s=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Dijkstra&#39;s Algorithm",id:"approach-1-dijkstras-algorithm",level:2},{value:"Time Complexity",id:"time-complexity",level:3},{value:"Space Complexity",id:"space-complexity",level:3}],m=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",t)},u=m("Tabs"),d=m("TabItem"),c=m("SolutionAuthor"),h={toc:s},b="wrapper";function y(e){let{components:t,...n}=e;return(0,a.kt)(b,(0,r.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"1514---path-with-maximum-probability-medium"},"1514 - Path with Maximum Probability (Medium)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/path-with-maximum-probability/"},"https://leetcode.com/problems/path-with-maximum-probability/")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"You are given an undirected weighted graph of\xa0",(0,a.kt)("inlineCode",{parentName:"p"},"n"),"\xa0nodes (0-indexed), represented by an edge list where\xa0",(0,a.kt)("inlineCode",{parentName:"p"},"edges[i] = [a, b]"),"\xa0is an undirected edge connecting the nodes\xa0",(0,a.kt)("inlineCode",{parentName:"p"},"a"),"\xa0and\xa0",(0,a.kt)("inlineCode",{parentName:"p"},"b"),"\xa0with a probability of success of traversing that edge\xa0",(0,a.kt)("inlineCode",{parentName:"p"},"succProb[i]"),"."),(0,a.kt)("p",null,"Given two nodes\xa0",(0,a.kt)("inlineCode",{parentName:"p"},"start"),"\xa0and\xa0",(0,a.kt)("inlineCode",{parentName:"p"},"end"),", find the path with the maximum probability of success to go from\xa0",(0,a.kt)("inlineCode",{parentName:"p"},"start"),"\xa0to\xa0",(0,a.kt)("inlineCode",{parentName:"p"},"end"),"\xa0and return its success probability."),(0,a.kt)("p",null,"If there is no path from\xa0",(0,a.kt)("inlineCode",{parentName:"p"},"start"),"\xa0to\xa0",(0,a.kt)("inlineCode",{parentName:"p"},"end"),", ",(0,a.kt)("strong",{parentName:"p"},"return\xa00"),". Your answer will be accepted if it differs from the correct answer by at most ",(0,a.kt)("strong",{parentName:"p"},"1e-5"),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2\nOutput: 0.25000\nExplanation:\xa0There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2\nOutput: 0.30000\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 3:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2\nOutput: 0.00000\nExplanation:\xa0There is no path between 0 and 2.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"2 <= n <= 10^4")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"0 <= start, end < n")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"start != end")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"0 <= a, b < n")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"a != b")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"0 <= succProb.length == edges.length <= 2*10^4")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"0 <= succProb[i] <= 1")),(0,a.kt)("li",{parentName:"ul"},"There is at most one edge between every two nodes.")),(0,a.kt)("h2",{id:"approach-1-dijkstras-algorithm"},"Approach 1: Dijkstra's Algorithm"),(0,a.kt)("p",null,"First, we will create adjanacy list $graph$ from given input. Now we have to find maximum success probability from soruce node to every node.  "),(0,a.kt)("p",null,'In standard djikstra algorithm, we will find the shortest path from start to end and update the "minimum distance" array accordingly for each $from$ -> $to$ pair.'),(0,a.kt)("p",null,"In this problem, we have to find maximum probability so we create a max heap $pq$ and an array $sp$ which will store success probability for every node. Now, we will iterate for top node of $pq$ priority queue and upadate the $sp$ array. After iterating through $graph$, we will return $sp","[end]","$."),(0,a.kt)(u,{mdxType:"Tabs"},(0,a.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(c,{name:"@Kavita613",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {    \n        int e = edges.size();\n  \n        // First, Create Adjanacy list   \n        vector<vector<pair<int, double>>> graph(n);\n        for (int i = 0; i < e; i++) {\n            graph[edges[i][0]].push_back({edges[i][1], succProb[i]});\n            graph[edges[i][1]].push_back({edges[i][0], succProb[i]});\n        }\n        \n        // Max heap, pair<success_probability, node>\n        priority_queue<pair<double, int>> pq;\n           \n        // success probability vector\n        vector<double> sp(n, (double)0.0);       \n        \n        // Source Node is having max success probability which is equal to 1\n        pq.push({1.0, start});\n        \n        while (!pq.empty()) {\n            double prob = pq.top().first;\n            int node = pq.top().second;\n            pq.pop();\n            // Now, we will iterate for adj nodes of our priority_queue's top node\n            for (auto x : graph[node]) {\n                // we have to find maximum success probability path from source to target\n                if (prob * x.second > sp[x.first]) {\n                    sp[x.first] = (double)(prob * x.second);\n                    pq.push({sp[x.first], x.first});\n                }\n            }\n        }\n        return sp[end];\n    }\n")))),(0,a.kt)("h3",{id:"time-complexity"},"Time Complexity"),(0,a.kt)("p",null,"Time Complexity of this solution is $O(e * log(n))$, where $e$ is the length of $edges$ array and $n$ is total nodes in given graph.  "),(0,a.kt)("h3",{id:"space-complexity"},"Space Complexity"),(0,a.kt)("p",null,"Space Complexity of this solution is $O(n)$, since we use $sp$ array of length $n$."))}y.isMDXComponent=!0}}]);