"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[56693],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>c});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},m="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),m=p(n),d=i,c=m["".concat(l,".").concat(d)]||m[d]||h[d]||s;return n?r.createElement(c,a(a({ref:t},u),{},{components:n})):r.createElement(c,a({ref:t},u))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=n.length,a=new Array(s);a[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[m]="string"==typeof e?e:i,a[1]=o;for(var p=2;p<s;p++)a[p]=n[p];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6504:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>g,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var r=n(87462),i=(n(67294),n(3905));const s={description:"Author: @1SundayMorning | https://leetcode.com/problems/minimize-result-by-adding-parentheses-to-expression/"},a="2232 -  Minimize Result by Adding Parentheses to Expression (Medium)",o={unversionedId:"2200-2299/minimize-result-by-adding-parentheses-to-expression-medium",id:"2200-2299/minimize-result-by-adding-parentheses-to-expression-medium",title:"2232 -  Minimize Result by Adding Parentheses to Expression (Medium)",description:"Author: @1SundayMorning | https://leetcode.com/problems/minimize-result-by-adding-parentheses-to-expression/",source:"@site/solutions/2200-2299/2232-minimize-result-by-adding-parentheses-to-expression-medium.md",sourceDirName:"2200-2299",slug:"/2200-2299/minimize-result-by-adding-parentheses-to-expression-medium",permalink:"/solutions/2200-2299/minimize-result-by-adding-parentheses-to-expression-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2200-2299/2232-minimize-result-by-adding-parentheses-to-expression-medium.md",tags:[],version:"current",sidebarPosition:2232,frontMatter:{description:"Author: @1SundayMorning | https://leetcode.com/problems/minimize-result-by-adding-parentheses-to-expression/"},sidebar:"tutorialSidebar",previous:{title:"2231 -  Largest Number After Digit Swaps by Parity (Easy)",permalink:"/solutions/2200-2299/largest-number-after-digit-swaps-by-parity-easy"},next:{title:"2233 - Maximum Product After K Increments (Medium)",permalink:"/solutions/2200-2299/maximum-product-after-k-increments-medium"}},l={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Iterative",id:"approach-1-iterative",level:2}],u=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",t)},m=u("Tabs"),h=u("TabItem"),d=u("SolutionAuthor"),c={toc:p},f="wrapper";function g(e){let{components:t,...n}=e;return(0,i.kt)(f,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"2232----minimize-result-by-adding-parentheses-to-expression-medium"},"2232 -  Minimize Result by Adding Parentheses to Expression (Medium)"),(0,i.kt)("h2",{id:"problem-link"},"Problem Link"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/minimize-result-by-adding-parentheses-to-expression/"},"https://leetcode.com/problems/minimize-result-by-adding-parentheses-to-expression/")),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"You are given a ",(0,i.kt)("strong",{parentName:"p"},"0-indexed")," string expression of the form ",(0,i.kt)("inlineCode",{parentName:"p"},'"<num1>+<num2>"')," where ",(0,i.kt)("inlineCode",{parentName:"p"},"<num1>")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"<num2>")," represent positive integers."),(0,i.kt)("p",null,"Add a pair of parentheses to expression such that after the addition of parentheses, expression is a ",(0,i.kt)("strong",{parentName:"p"},"valid")," mathematical expression and evaluates to the ",(0,i.kt)("strong",{parentName:"p"},"smallest")," possible value. The left parenthesis ",(0,i.kt)("strong",{parentName:"p"},"must")," be added to the left of '+' and the right parenthesis ",(0,i.kt)("strong",{parentName:"p"},"must")," be added to the right of '+'."),(0,i.kt)("p",null,"Return expression after adding a pair of parentheses such that expression evaluates to the ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"smallest"))," possible value. If there are multiple answers that yield the same result, return any of them."),(0,i.kt)("p",null,"The input has been generated such that the original value of expression, and the value of expression after adding any pair of parentheses that meets the requirements fits within a signed 32-bit integer."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input: expression = "247+38"\nOutput: "2(47+38)"\nExplanation: The expression evaluates to 2 * (47 + 38) = 2 * 85 = 170.\nNote that "2(4)7+38" is invalid because the right parenthesis must be to the right of the \'+\'.\nIt can be shown that 170 is the smallest possible value.\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input: expression = "12+34"\nOutput: "1(2+3)4"\nExplanation: The expression evaluates to 1 * (2 + 3) * 4 = 1 * 5 * 4 = 20.\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 3:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input: expression = "999+999"\nOutput: "(999+999)"\nExplanation: The expression evaluates to 999 + 999 = 1998.\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"3 <= expression.length <= 10")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"expression consists of digits from '1' to '9' and '+'.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"expression starts and ends with digits.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"expression contains exactly one '+'.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"The original value of expression, and the value of expression after adding any pair of parentheses that meets the requirements fits within a signed 32-bit integer."))),(0,i.kt)("h2",{id:"approach-1-iterative"},"Approach 1: Iterative"),(0,i.kt)("p",null,"To solve, separate the expression into the two operands of the sum expression."),(0,i.kt)("p",null,"Then, iteratively place the open and close parenthesis at every possible location in the left and right substrings"),(0,i.kt)("p",null,"Next, evaluate the expression by computing the inner sum, and then multiplying the outer values contained in the substrings\noutside of the parenthesis."),(0,i.kt)("p",null,"Compare the result of the expression to the current minimum, and if it's lower, save the minimum and the locations of the\nopen and close parenthesis."),(0,i.kt)("p",null,"Once all possible expressions have been evaluated, construct the final expression using the saved locations of the open and\nclose parenthesis."),(0,i.kt)("p",null,"Return the expression."),(0,i.kt)("p",null,"Time Complexity: $O(a * b)$"),(0,i.kt)("p",null,"Space Complexity: $O(n ",(0,i.kt)("em",{parentName:"p"}," a ")," b)$"),(0,i.kt)("p",null,"where $a$ and $b$ are the length of the left and right operands of the input sum"),(0,i.kt)(m,{mdxType:"Tabs"},(0,i.kt)(h,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)(d,{name:"@1SundayMorning",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'class Solution {\npublic:\n    string minimizeResult(string expression) {\n        // find the location of the plus and separate the left and right operands\n        int plus_idx = 0;\n        while (expression[plus_idx] != \'+\') {\n            plus_idx++;\n        }\n        \n        string left = expression.substr(0, plus_idx);\n        string right = expression.substr(plus_idx + 1, expression.length() - plus_idx);\n        \n        // set initial value of min to be INT_MAX\n        int min = INT_MAX;\n        int final_p1 = 0;\n        int final_p2 = 0;\n        \n        // iterate through all valid parenthesis locations in each of the\n        // left and right operands\n        for(int p1 = 0; p1 < left.length(); p1++) {\n            for (int p2 = 1; p2 <= right.length(); p2++) {\n                // saving the substrings on either side of the parenthesis\n                // to be converted to integers later\n                string left_mul_str = left.substr(0, p1);\n                string left_sum_str = left.substr(p1);\n                string right_sum_str = right.substr(0, p2);\n                string right_mul_str = right.substr(p2);\n                \n                // in the case where the entire expression is enclosed in parenthesis, \n                // set left mul and right mul to none.\n                // This will be the case when their respective substrings are empty.\n                int left_mul = 1;\n                int left_sum = stoi(left_sum_str);\n                int right_sum = stoi(right_sum_str);\n                int right_mul = 1;\n                \n                if (!left_mul_str.empty())\n                    left_mul = stoi(left_mul_str);\n                if (!right_mul_str.empty()) {\n                    right_mul = stoi(right_mul_str);\n                }\n                \n                // evaluate the expression.\n                int exp_result = left_mul * (left_sum + right_sum) * right_mul;\n                \n                // if final value is our new min, save the indices of the parenthesis\n                if (exp_result < min) {\n                    min = exp_result;\n                    final_p1 = p1;\n                    final_p2 = p2;\n                }\n            }\n        }\n        \n        // construct and return the final expression with parenthesis added\n        return left.substr(0, final_p1) +     \\\n            "(" + left.substr(final_p1) +     \\\n            "+" + right.substr(0, final_p2) + \\\n            ")" + right.substr(final_p2);\n    }\n};\n')))))}g.isMDXComponent=!0}}]);