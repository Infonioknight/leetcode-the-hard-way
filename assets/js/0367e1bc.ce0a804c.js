"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[35066],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>h});var i=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,o=function(e,n){if(null==e)return{};var t,i,o={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=i.createContext({}),s=function(e){var n=i.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},m=function(e){var n=s(e.components);return i.createElement(c.Provider,{value:n},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},d=i.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),p=s(t),d=o,h=p["".concat(c,".").concat(d)]||p[d]||u[d]||r;return t?i.createElement(h,a(a({ref:n},m),{},{components:t})):i.createElement(h,a({ref:n},m))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,a=new Array(r);a[0]=d;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l[p]="string"==typeof e?e:o,a[1]=l;for(var s=2;s<r;s++)a[s]=t[s];return i.createElement.apply(null,a)}return i.createElement.apply(null,t)}d.displayName="MDXCreateElement"},36370:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var i=t(87462),o=(t(67294),t(3905));const r={description:"Author: @wingkwong | https://leetcode.com/problems/connecting-cities-with-minimum-cost/"},a="1135 - Connecting Cities With Minimum Cost (Medium)",l={unversionedId:"1100-1199/connecting-cities-with-minimum-cost-medium",id:"1100-1199/connecting-cities-with-minimum-cost-medium",title:"1135 - Connecting Cities With Minimum Cost (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/connecting-cities-with-minimum-cost/",source:"@site/solutions/1100-1199/1135-connecting-cities-with-minimum-cost-medium.md",sourceDirName:"1100-1199",slug:"/1100-1199/connecting-cities-with-minimum-cost-medium",permalink:"/solutions/1100-1199/connecting-cities-with-minimum-cost-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1100-1199/1135-connecting-cities-with-minimum-cost-medium.md",tags:[],version:"current",sidebarPosition:1135,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/connecting-cities-with-minimum-cost/"},sidebar:"tutorialSidebar",previous:{title:"1125 - Smallest Sufficient Team (Hard)",permalink:"/solutions/1100-1199/smallest-sufficient-team-hard"},next:{title:"1137 - N-th Tribonacci Number (Easy)",permalink:"/solutions/1100-1199/n-th-tribonacci-number-easy"}},c={},s=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: <strong>Kruskal&#39;s Algorithm</strong>",id:"approach-1-kruskals-algorithm",level:2}],m=(p="SolutionAuthor",function(e){return console.warn("Component "+p+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",e)});var p;const u={toc:s},d="wrapper";function h(e){let{components:n,...t}=e;return(0,o.kt)(d,(0,i.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"1135---connecting-cities-with-minimum-cost-medium"},"1135 - Connecting Cities With Minimum Cost (Medium)"),(0,o.kt)("h2",{id:"problem-link"},"Problem Link"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/connecting-cities-with-minimum-cost/"},"https://leetcode.com/problems/connecting-cities-with-minimum-cost/")),(0,o.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,o.kt)("p",null,"There are ",(0,o.kt)("inlineCode",{parentName:"p"},"n")," cities labeled from ",(0,o.kt)("inlineCode",{parentName:"p"},"1")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"n"),". You are given the integer ",(0,o.kt)("inlineCode",{parentName:"p"},"n")," and an array ",(0,o.kt)("inlineCode",{parentName:"p"},"connections")," where ",(0,o.kt)("inlineCode",{parentName:"p"},"connections[i] = [xi, yi, costi]")," indicates that the cost of connecting city ",(0,o.kt)("inlineCode",{parentName:"p"},"xi")," and city ",(0,o.kt)("inlineCode",{parentName:"p"},"yi")," (bidirectional connection) is ",(0,o.kt)("inlineCode",{parentName:"p"},"costi"),"."),(0,o.kt)("p",null,"Return ",(0,o.kt)("em",{parentName:"p"},"the minimum ",(0,o.kt)("strong",{parentName:"em"},"cost")," to connect all the")," ",(0,o.kt)("inlineCode",{parentName:"p"},"n")," ",(0,o.kt)("em",{parentName:"p"},"cities such that there is at least one path between each pair of cities"),". If it is impossible to connect all the ",(0,o.kt)("inlineCode",{parentName:"p"},"n")," cities, return ",(0,o.kt)("inlineCode",{parentName:"p"},"-1"),","),(0,o.kt)("p",null,"The ",(0,o.kt)("strong",{parentName:"p"},"cost")," is the sum of the connections' costs used."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 1:")),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2019/04/20/1314_ex2.png",alt:null})),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: n = 3, connections = [[1,2,5],[1,3,6],[2,3,1]]\nOutput: 6\nExplanation: Choosing any 2 edges will connect all cities so we choose the minimum 2.\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 2:")),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2019/04/20/1314_ex1.png",alt:null})),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: n = 4, connections = [[1,2,3],[3,4,4]]\nOutput: -1\nExplanation: There is no way to connect all cities even if all edges are used. \n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Constraints:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"1 <= n <= 10^4")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"1 <= connections.length <= 10^4")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"connections[i].length == 3")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"1 <= xi, yi <= n")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"xi != yi")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"0 <= costi <= 10^5"))),(0,o.kt)("h2",{id:"approach-1-kruskals-algorithm"},"Approach 1: ",(0,o.kt)("strong",{parentName:"h2"},"Kruskal's Algorithm")),(0,o.kt)("p",null,"If we treat it as a graph problem, it is actually same as finding Minimum Spanning Tree. Hence, we can use Kruskal's Algorithm with DSU to solve it."),(0,o.kt)("p",null,"In order to get the MST, we sort the edges based on the weights in an increasing order. Then we iterate them one by one, and greedily pick edges which does not result in cycle with the previous edges. At the end, we should have $$N - 1$$edges in MST. Otherwise, we return $$-1$$."),(0,o.kt)(m,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class dsu {\n public:\n  vector<int> root, rank;\n  int n;\n  int cnt;\n\n  dsu(int _n) : n(_n) {\n    root.resize(n);\n    rank.resize(n);\n    for(int i = 0; i < n; i++) {\n        root[i] = i;\n        rank[i] = 1;\n    }\n    cnt = n;\n  }\n\n  inline int getCount() { return cnt; }\n\n  inline int get(int x) { return (x == root[x] ? x : (root[x] = get(root[x]))); }\n\n  inline bool unite(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x != y) {\n        if (rank[x] > rank[y]) {\n            root[y] = x;\n        } else if (rank[x] < rank[y]) {\n            root[x] = y;\n        } else {\n            root[y] = x;\n            rank[x] += 1;\n        }\n        cnt--;\n      return true;\n    }\n    return false;\n  }\n};\n\nclass Solution {\npublic:\n    int minimumCost(int n, vector<vector<int>>& connections) {\n        vector<array<int, 3>> edges;\n        for (auto x : connections) {\n            edges.push_back({x[2], x[0], x[1]});\n        }\n        sort(edges.begin(), edges.end());\n        dsu d(n + 1);\n        int ans = 0, cnt = 0;\n        for (auto x : edges) {\n            if (d.unite(x[1], x[2])) {\n                ans += x[0];\n                cnt += 1;\n            }\n        }\n        return cnt == n - 1 ? ans : -1;\n    }\n};\n")))}h.isMDXComponent=!0}}]);