"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[95486],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>g});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=p(n),d=a,g=u["".concat(s,".").concat(d)]||u[d]||c[d]||i;return n?r.createElement(g,o(o({ref:t},m),{},{components:n})):r.createElement(g,o({ref:t},m))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,o[1]=l;for(var p=2;p<i;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},79045:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>$,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var r=n(87462),a=(n(67294),n(3905));const i={description:"Author: @ColeB2 | https://leetcode.com/problems/interleaving-string/",tags:["String","Dynamic Programming"]},o="0097 - Interleaving String (Medium)",l={unversionedId:"0000-0099/interleaving-string-medium",id:"0000-0099/interleaving-string-medium",title:"0097 - Interleaving String (Medium)",description:"Author: @ColeB2 | https://leetcode.com/problems/interleaving-string/",source:"@site/solutions/0000-0099/0097-interleaving-string-medium.md",sourceDirName:"0000-0099",slug:"/0000-0099/interleaving-string-medium",permalink:"/solutions/0000-0099/interleaving-string-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0000-0099/0097-interleaving-string-medium.md",tags:[{label:"String",permalink:"/solutions/tags/string"},{label:"Dynamic Programming",permalink:"/solutions/tags/dynamic-programming"}],version:"current",sidebarPosition:97,frontMatter:{description:"Author: @ColeB2 | https://leetcode.com/problems/interleaving-string/",tags:["String","Dynamic Programming"]},sidebar:"tutorialSidebar",previous:{title:"0094 - Binary Tree Inorder Traversal (Easy)",permalink:"/solutions/0000-0099/binary-tree-inorder-traversal-easy"},next:{title:"0098 - Validate Binary Search Tree (Medium)",permalink:"/solutions/0000-0099/validate-binary-search-tree-medium"}},s={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: 2D Dynamic Programming",id:"approach-1-2d-dynamic-programming",level:2}],m=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",t)},u=m("Tabs"),c=m("TabItem"),d=m("SolutionAuthor"),g={toc:p},h="wrapper";function $(e){let{components:t,...n}=e;return(0,a.kt)(h,(0,r.Z)({},g,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"0097---interleaving-string-medium"},"0097 - Interleaving String (Medium)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/interleaving-string/"},"https://leetcode.com/problems/interleaving-string/")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"Given strings ",(0,a.kt)("inlineCode",{parentName:"p"},"s1"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"s2"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"s3"),", find whether ",(0,a.kt)("inlineCode",{parentName:"p"},"s3")," is formed by an ",(0,a.kt)("strong",{parentName:"p"},"interleaving")," of ",(0,a.kt)("inlineCode",{parentName:"p"},"s1")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"s2"),"."),(0,a.kt)("p",null,"An ",(0,a.kt)("strong",{parentName:"p"},"interleaving")," of two strings ",(0,a.kt)("inlineCode",{parentName:"p"},"s")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"t")," is a configuration where ",(0,a.kt)("inlineCode",{parentName:"p"},"s")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"t")," are divided into ",(0,a.kt)("inlineCode",{parentName:"p"},"n")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"m")," substrings respectively, such that:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"s = s1 + s2 + ... + sn")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"t = t1 + t2 + ... + tm")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"|n - m| <= 1")),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("strong",{parentName:"li"},"interleaving")," is ",(0,a.kt)("inlineCode",{parentName:"li"},"s1 + t1 + s2 + t2 + s3 + t3 + ...")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"t1 + s1 + t2 + s2 + t3 + s3 + ..."))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Note"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"a + b")," is the concatenation of strings ",(0,a.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"b"),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg",alt:null})),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"\nOutput: true\nExplanation: One way to obtain s3 is:\nSplit s1 into s1 = "aa" + "bc" + "c", and s2 into s2 = "dbbc" + "a".\nInterleaving the two splits, we get "aa" + "dbbc" + "bc" + "a" + "c" = "aadbbcbcac".\nSince s3 can be obtained by interleaving s1 and s2, we return true.\n\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"\nOutput: false\nExplanation: Notice how it is impossible to interleave s2 with any other string to obtain s3.\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 3:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Input: s1 = "", s2 = "", s3 = ""\nOutput: true\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"0 <= s1.length, s2.length <= 100")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"0 <= s3.length <= 200")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"s1"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"s2"),", and ",(0,a.kt)("inlineCode",{parentName:"li"},"s3")," consist of lowercase English letters.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Follow up"),": Could you solve it using only ",(0,a.kt)("inlineCode",{parentName:"p"},"O(s2.length)")," additional memory space?"),(0,a.kt)("h2",{id:"approach-1-2d-dynamic-programming"},"Approach 1: 2D Dynamic Programming"),(0,a.kt)("p",null,"If we try to break down our problem into a sub problem we get that we are trying to find whether the characters in $$s1$$ up to $$i$$ and the characters in $$s2$$ up to $$j$$ can interleave to create a string in $$s3$$ up to $$i + j$$. "),(0,a.kt)("p",null,"So to construct our 2D grid we would need a grid of size $$s2.length + 1$$ wide and $$s1.length + 1$$ tall of all false/falsy values. This allows us to account for the empty string prefix of both $$s1$$ and $$s2$$. We would then initialize the $$0,0$$ position as a true/truthy value, as we know we can create the empty $$s3$$ using the empty $$s1$$ and $$s2$$ strings."),(0,a.kt)("p",null,"For $$i,j$$ values in our grid, it maps out $$i$$ values to position is $$s1$$ and $$j$$ values to position in $$s2$$. This means that for each $$i,j$$ value in our grid it tells us whether we can create $$s3","[:i+j]","$$ using the characters from $$s1","[:i]","$$ and $$s2","[:j]","$$."),(0,a.kt)("p",null,"So then for each i,j we know if it isn't the first row or column (our empty string values), and that if the character from the previous iteration of $$s1$$ matches the previous iteration character of $$s3$$ "),(0,a.kt)("p",null,"Time Complexity: $$O(n",(0,a.kt)("em",{parentName:"p"},"m)$$ where $$n$$ is the length of $$s1$$ and $$m$$ is the length of $$s2$$. We are iterating over our dp array of size $$n"),"m$$."),(0,a.kt)("p",null,"Space Complexity: $$O(n",(0,a.kt)("em",{parentName:"p"},"m)$$. Our dp array will be of size $$n"),"m$$."),(0,a.kt)(u,{mdxType:"Tabs"},(0,a.kt)(c,{value:"python",label:"Python",mdxType:"TabItem"},(0,a.kt)(d,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},'class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        # return early if s1 and s2 combined aren\'t same size as s3.\n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        # create our 2d grid, we need an extra row/col to account for\n        # the empty string case when comparing either empty s1/s2 values.\n        dp = [[0 for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n        # initialize first value to be truthy, as we know we can create\n        # s3="" using s1="" and s2="". This is the initial base case of\n        # interleaving 2 empty string to equal an empty string.\n        dp[0][0] = 1\n        # loop through the 2d dp array. Remembering the first row/col\n        # handles the empty string sub-problems.\n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                # check 3 things for each position in s1, s2.\n                #1. i/j > 0: We can\'t check positions of less than\n                # the empty "" string value. i/j == 0, that handles\n                # empty strings, and their is no way to be < empty.\n                #2. Check string value at s1[i-1] == s3[i+j-1]. This\n                # is checking if the letters at the proper position are\n                # equal. Note we subtract 1, since we added a extra \n                # row/col to the start of each row/col in dp table.\n                #3. And if prevs 2 are truthy, We check that it held the\n                # same for the previous i value.\n                if i > 0 and s1[i-1] == s3[i+j-1] and dp[i-1][j]:\n                    # if so, we can call this true/truthy\n                    dp[i][j] = 1\n                if j > 0 and s2[j-1] == s3[i+j-1] and dp[i][j-1]:\n                    dp[i][j] = 1\n        # the full string would be represented by the length os s1,s2\n        # in our dp table.\n        return dp[len(s1)][len(s2)] \n')))))}$.isMDXComponent=!0}}]);