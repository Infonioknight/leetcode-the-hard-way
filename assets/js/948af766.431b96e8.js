"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[8892],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var a=n(67294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,i=e.originalType,c=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=l(n),h=s,d=u["".concat(c,".").concat(h)]||u[h]||p[h]||i;return n?a.createElement(d,r(r({ref:t},m),{},{components:n})):a.createElement(d,r({ref:t},m))}));function d(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var i=n.length,r=new Array(i);r[0]=h;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o[u]="string"==typeof e?e:s,r[1]=o;for(var l=2;l<i;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},44194:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var a=n(87462),s=(n(67294),n(3905));const i={description:"Author: @wingkwong | https://leetcode.com/problems/matchsticks-to-square/"},r="0473 - Matchsticks to Square (Medium)",o={unversionedId:"0400-0499/matchsticks-to-square-medium",id:"0400-0499/matchsticks-to-square-medium",title:"0473 - Matchsticks to Square (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/matchsticks-to-square/",source:"@site/solutions/0400-0499/0473-matchsticks-to-square-medium.md",sourceDirName:"0400-0499",slug:"/0400-0499/matchsticks-to-square-medium",permalink:"/solutions/0400-0499/matchsticks-to-square-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0400-0499/0473-matchsticks-to-square-medium.md",tags:[],version:"current",sidebarPosition:473,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/matchsticks-to-square/"},sidebar:"tutorialSidebar",previous:{title:"0472 - Concatenated Words (Hard)",permalink:"/solutions/0400-0499/concatenated-words-hard"},next:{title:"0491 - Non-decreasing Subsequences (Medium)",permalink:"/solutions/0400-0499/non-decreasing-subsequences-medium"}},c={},l=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Bitmask DP",id:"approach-1-bitmask-dp",level:2}],m=(u="SolutionAuthor",function(e){return console.warn("Component "+u+" was not imported, exported, or provided by MDXProvider as global scope"),(0,s.kt)("div",e)});var u;const p={toc:l},h="wrapper";function d(e){let{components:t,...n}=e;return(0,s.kt)(h,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"0473---matchsticks-to-square-medium"},"0473 - Matchsticks to Square (Medium)"),(0,s.kt)("h2",{id:"problem-link"},"Problem Link"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/matchsticks-to-square/"},"https://leetcode.com/problems/matchsticks-to-square/")),(0,s.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,s.kt)("p",null,"You are given an integer array ",(0,s.kt)("inlineCode",{parentName:"p"},"matchsticks")," where ",(0,s.kt)("inlineCode",{parentName:"p"},"matchsticks[i]")," is the length of the ",(0,s.kt)("inlineCode",{parentName:"p"},"ith")," matchstick. You want to use ",(0,s.kt)("strong",{parentName:"p"},"all the matchsticks")," to make one square. You ",(0,s.kt)("strong",{parentName:"p"},"should not break")," any stick, but you can link them up, and each matchstick must be used ",(0,s.kt)("strong",{parentName:"p"},"exactly one time"),"."),(0,s.kt)("p",null,"Return ",(0,s.kt)("inlineCode",{parentName:"p"},"true")," if you can make this square and ",(0,s.kt)("inlineCode",{parentName:"p"},"false")," otherwise."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example 1:")),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2021/04/09/matchsticks1-grid.jpg",alt:null})),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Input: matchsticks = [1,1,2,2,2]\nOutput: true\nExplanation: You can form a square with length 2, one side of the square came two sticks with length 1.\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example 2:")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"Input: matchsticks = [3,3,3,3,4]\nOutput: false\nExplanation: You cannot find a way to form a square with all the matchsticks.\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Constraints:")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"1 <= matchsticks.length <= 15")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"1 <= matchsticks[i] <= 10^8"))),(0,s.kt)("h2",{id:"approach-1-bitmask-dp"},"Approach 1: Bitmask DP"),(0,s.kt)("p",null,"If we need to put all matchsticks to form a square, then each side should equally have a length of$$sum(matchsticks) / 4$$. If the perimeter cannot be divided by $$4$$, then the answer is false. If the longest matchstick is greater than the target side, then it is also false."),(0,s.kt)("p",null,"We can use bitmask to track which matchsticks are used. For example, for matchsticks = ","[","1, 1, 2, 2, 2], then bitmask $$10001_2$$simply means the first and the last matchsticks are used. If we have a state $$10001_2$$, then we can only put the middle three matchsticks to some positions."),(0,s.kt)("p",null,"Let $$dp","[mask]","$$ be the length of matchsticks we have put in the state $$mask$$. For example, If $$mask := 10001_2$$, $$dp","[mask]"," := 5$$, $$side := 7$$, then it means we have put two matchsticks with the length of $$5$$ in total."),(0,s.kt)("p",null,"Hence, we iterate the mask. If the mask cannot be used, then skip it. Otherwise, we iterate $$n$$ times to check if $$i$$-th bit is used. If not, it means we may take this matchstick. However, we can only set this bit (take the matchstick) only if putting it won't exceed the length of side, i.e. $$dp","[mask]"," + matchsticks","[i]"," <= side$$. Once we choose it, then we update the new state $$(dp","[mask]"," + matchsticks","[i]",") \\mod side$$. We take $$mod$$ here because if we want to reset it if the prefect match for a side is found. At the end, choosing all $$5$$ matchsticks would give $$dp","[(11111_2)]"," = 0$$."),(0,s.kt)(m,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    bool makesquare(vector<int>& matchsticks) {\n        int n = matchsticks.size();\n        // sum all lengths\n        int perimeter = accumulate(matchsticks.begin(), matchsticks.end(), 0);\n        // each side should have equally a length of (sum / 4)\n        // return false if it is not satisfied\n        if (perimeter % 4) return false;\n        // get the length of side\n        int side = perimeter / 4;\n        // return false if the longest matchstick is greater than the side\n        if (*max_element(matchsticks.begin(), matchsticks.end()) > side) return false;\n        // we have (1 << n) states\n        vector<int> dp(1 << n, -1);\n        // base case - putting 0 matchstick\n        dp[0] = 0;\n        for (int mask = 0; mask < (1 << n); mask++) {\n            // cannot use this state - skip it\n            if (dp[mask] == -1) continue;\n            // try to put each matchstick \n            for (int i = 0; i < n; i++) {\n                // if matchsticks[i] is available to be put\n                // and the length won't exceed side after putting it\n                if (!(mask & (1 << i)) && dp[mask] + matchsticks[i] <= side) {\n                    // then put it and update the state\n                    // if it perfectly forms a side, it would be 0 \n                    dp[mask | (1 << i)] = (dp[mask] + matchsticks[i]) % side;\n                }\n            }\n        }\n        // (1 << n) - 1 means all bits set = all matchsticks are used\n        return dp[(1 << n) - 1] == 0;\n    }\n};\n")))}d.isMDXComponent=!0}}]);