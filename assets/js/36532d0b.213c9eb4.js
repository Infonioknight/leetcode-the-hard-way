"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[9807],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>g});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),u=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=u(e.components);return r.createElement(l.Provider,{value:n},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},h=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),m=u(t),h=a,g=m["".concat(l,".").concat(h)]||m[h]||c[h]||i;return t?r.createElement(g,o(o({ref:n},p),{},{components:t})):r.createElement(g,o({ref:n},p))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=h;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[m]="string"==typeof e?e:a,o[1]=s;for(var u=2;u<i;u++)o[u]=t[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}h.displayName="MDXCreateElement"},20421:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>b,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var r=t(87462),a=(t(67294),t(3905));const i={description:"Author: @ColeB2 | https://leetcode.com/problems/longest-increasing-subsequence/",tags:["Array","Binary Search","Dynamic Programming"]},o="0300 - Longest Increasing Subsequence (Medium)",s={unversionedId:"0300-0399/longest-increasing-subsequence-medium",id:"0300-0399/longest-increasing-subsequence-medium",title:"0300 - Longest Increasing Subsequence (Medium)",description:"Author: @ColeB2 | https://leetcode.com/problems/longest-increasing-subsequence/",source:"@site/solutions/0300-0399/0300-longest-increasing-subsequence-medium.md",sourceDirName:"0300-0399",slug:"/0300-0399/longest-increasing-subsequence-medium",permalink:"/solutions/0300-0399/longest-increasing-subsequence-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0300-0399/0300-longest-increasing-subsequence-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Binary Search",permalink:"/solutions/tags/binary-search"},{label:"Dynamic Programming",permalink:"/solutions/tags/dynamic-programming"}],version:"current",sidebarPosition:300,frontMatter:{description:"Author: @ColeB2 | https://leetcode.com/problems/longest-increasing-subsequence/",tags:["Array","Binary Search","Dynamic Programming"]},sidebar:"tutorialSidebar",previous:{title:"0300 - 0399",permalink:"/solutions/category/0300---0399"},next:{title:"0307 - Range Sum Query - Mutable (Medium)",permalink:"/solutions/0300-0399/range-sum-query-mutable-medium"}},l={},u=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Dynamic Programming",id:"approach-1-dynamic-programming",level:2},{value:"Approach 2: Binary Search",id:"approach-2-binary-search",level:2}],p=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",n)},m=p("Tabs"),c=p("TabItem"),h=p("SolutionAuthor"),g={toc:u},d="wrapper";function b(e){let{components:n,...t}=e;return(0,a.kt)(d,(0,r.Z)({},g,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"0300---longest-increasing-subsequence-medium"},"0300 - Longest Increasing Subsequence (Medium)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/longest-increasing-subsequence/"},"https://leetcode.com/problems/longest-increasing-subsequence/")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"Given an integer array ",(0,a.kt)("inlineCode",{parentName:"p"},"nums"),", return ",(0,a.kt)("em",{parentName:"p"},"the length of the longest ",(0,a.kt)("strong",{parentName:"em"},"strictly increasing subsequence")),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: nums = [0,1,0,3,2,3]\nOutput: 4\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 3:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: nums = [7,7,7,7,7,7,7]\nOutput: 1\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= nums.length <= 2500")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"-10^4 <= nums[i] <= 10^4"))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Follow up"),": Can you come up with an algorithm that runs in ",(0,a.kt)("inlineCode",{parentName:"p"},"O(n log(n))")," time complexity?"),(0,a.kt)("h2",{id:"approach-1-dynamic-programming"},"Approach 1: Dynamic Programming"),(0,a.kt)("p",null,"We can solve this using a dynamic programming approach. We can initialize a $$dp$$ array of size $$nums$$. The array represensts the longest subsequence up to and including that number. So then we can iterate through the $$nums$$ array and for each num in the array, check if it's greater than each num before it, and if it is update our $$dp$$ array based on the longest subsequence that the position of the number we checked it against."),(0,a.kt)("p",null,"Time Complexity: $$O(n^2)$$, Where n is the length of $$nums$$. We are going to loop through each num, then for each num, loop through each num before it."),(0,a.kt)("p",null,"Space Complexity: $$O(n)$$, our dp array, will be the same size as our $$nums$$ array."),(0,a.kt)(m,{mdxType:"Tabs"},(0,a.kt)(c,{value:"python",label:"Python",mdxType:"TabItem"},(0,a.kt)(h,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        # initialize dp array.\n        # dp[i] represents length of longest subsequence up to i.\n        dp = [0] * len(nums)\n        # iterate over the nums array\n        for i, num in enumerate(nums):\n            # iterate over each num from 0 to the current num.\n            for j in range(0, i + 1):\n                # current num, num > nums[j] it creates \n                # a stricly increasing subsequence.\n                if num > nums[j]:\n                    # update length of longest subsequence.\n                    # dp[j] + 1 represents length of subsequence ending\n                    # at j, updated including current value, dp[i], will\n                    # be the current subsequence, which may be updated\n                    # in previous loops, and 1 represents the subsequence\n                    # if a single number.\n                    dp[i] = max(dp[j] + 1, dp[i], 1)\n                # num not greater:\n                else:\n                    # update it to be either 1, or previous value.\n                    dp[i] = max(dp[i], 1)\n        # return largest subsequence.\n        return max(dp)\n")))),(0,a.kt)("h2",{id:"approach-2-binary-search"},"Approach 2: Binary Search"),(0,a.kt)("p",null,"Our follow-up asks for a $$O(nlogn)$$ solution, which we can achieve using binary search. The method is called Patience Sorting and involves creating $$piles$$ of numbers to stack our numbers on top. This $$piles$$ array is what we will binary search over. "),(0,a.kt)("p",null,'For each number in $$nums$$ we can run a binary search on our $$piles$$ array to find where we can place the number. We are looking for the best position in the $$piles$$ array where we can "place" our number on top. If the number is greater than all numbers, we create a new pile and append the number to $$piles$$, if not, binary search will find us a number to place it on top of. Meaning we overwrite the number with the current number.'),(0,a.kt)("p",null,'By "placing" the number on top of the pile in which the number is less than, we create an array in which the "top" number of each pile is in increasing order which allows us to binary search. This also means that the length of $$piles$$ array represents our longest increasing subsequence.'),(0,a.kt)("p",null,"Time Complexity: $$O(nlogn)$$, where n is the length of $$nums$$. For each number in $$nums$$ we are going to do a binary search over our $$piles$$ array, which in the worst case may be size n."),(0,a.kt)("p",null,"Space Complexity: $$O(n)$$, our $$piles$$ array may be of size $$n$$ in the worst case."),(0,a.kt)(m,{mdxType:"Tabs"},(0,a.kt)(c,{value:"python",label:"Python",mdxType:"TabItem"},(0,a.kt)(h,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        # initialize piles array\n        piles = []\n        # iterate through all the numbers in nums\n        for num in nums:\n            #binary search piles\n            l, r = 0, len(piles)\n            while l < r:\n                m = l + (r - l) // 2\n                if num > piles[m]:\n                    l = m + 1\n                else:\n                    r = m\n            # if our left pointer isn't larger than piles array\n            # it means we found a place to put our number\n            if l < len(piles):\n                # overwrite piles[l] with the current num\n                piles[l] = num\n            # l > length of piles array, it means there is no\n            # pile with a large enough number to put this number\n            # on top of\n            else:\n                # create a new pile, by appending current number to end.\n                piles.append(num)\n        # return length of piles.\n        return len(piles)\n")))))}b.isMDXComponent=!0}}]);