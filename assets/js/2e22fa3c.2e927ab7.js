"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[79324],{3905:(n,t,e)=>{e.d(t,{Zo:()=>d,kt:()=>h});var a=e(67294);function i(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function r(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,a)}return e}function o(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?r(Object(e),!0).forEach((function(t){i(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}function s(n,t){if(null==n)return{};var e,a,i=function(n,t){if(null==n)return{};var e,a,i={},r=Object.keys(n);for(a=0;a<r.length;a++)e=r[a],t.indexOf(e)>=0||(i[e]=n[e]);return i}(n,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(a=0;a<r.length;a++)e=r[a],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(i[e]=n[e])}return i}var l=a.createContext({}),c=function(n){var t=a.useContext(l),e=t;return n&&(e="function"==typeof n?n(t):o(o({},t),n)),e},d=function(n){var t=c(n.components);return a.createElement(l.Provider,{value:t},n.children)},p="mdxType",u={inlineCode:"code",wrapper:function(n){var t=n.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(n,t){var e=n.components,i=n.mdxType,r=n.originalType,l=n.parentName,d=s(n,["components","mdxType","originalType","parentName"]),p=c(e),m=i,h=p["".concat(l,".").concat(m)]||p[m]||u[m]||r;return e?a.createElement(h,o(o({ref:t},d),{},{components:e})):a.createElement(h,o({ref:t},d))}));function h(n,t){var e=arguments,i=t&&t.mdxType;if("string"==typeof n||i){var r=e.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=n,s[p]="string"==typeof n?n:i,o[1]=s;for(var c=2;c<r;c++)o[c]=e[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,e)}m.displayName="MDXCreateElement"},83612:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>k,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=e(87462),i=(e(67294),e(3905));const r={description:"Author: @wingkwong, @ColeB2 | https://leetcode.com/problems/palindrome-partitioning/",tags:["String","Dynamic Programming","Backtracking"]},o="0131 - Palindrome Partitioning (Medium)",s={unversionedId:"0100-0199/palindrome-partitioning-medium",id:"0100-0199/palindrome-partitioning-medium",title:"0131 - Palindrome Partitioning (Medium)",description:"Author: @wingkwong, @ColeB2 | https://leetcode.com/problems/palindrome-partitioning/",source:"@site/solutions/0100-0199/0131-palindrome-partitioning-medium.md",sourceDirName:"0100-0199",slug:"/0100-0199/palindrome-partitioning-medium",permalink:"/solutions/0100-0199/palindrome-partitioning-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0100-0199/0131-palindrome-partitioning-medium.md",tags:[{label:"String",permalink:"/solutions/tags/string"},{label:"Dynamic Programming",permalink:"/solutions/tags/dynamic-programming"},{label:"Backtracking",permalink:"/solutions/tags/backtracking"}],version:"current",sidebarPosition:131,frontMatter:{description:"Author: @wingkwong, @ColeB2 | https://leetcode.com/problems/palindrome-partitioning/",tags:["String","Dynamic Programming","Backtracking"]},sidebar:"tutorialSidebar",previous:{title:"0130 Surrounded Regions (Medium)",permalink:"/solutions/0100-0199/surrounded-regions-medium"},next:{title:"0133 - Clone Graph (Medium)",permalink:"/solutions/0100-0199/clone-graph-medium"}},l={},c=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Backtracking",id:"approach-1-backtracking",level:2},{value:"Approach 2: Iterative Backtracking",id:"approach-2-iterative-backtracking",level:2}],d=n=>function(t){return console.warn("Component "+n+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",t)},p=d("Tabs"),u=d("TabItem"),m=d("SolutionAuthor"),h={toc:c},g="wrapper";function k(n){let{components:t,...e}=n;return(0,i.kt)(g,(0,a.Z)({},h,e,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"0131---palindrome-partitioning-medium"},"0131 - Palindrome Partitioning (Medium)"),(0,i.kt)("h2",{id:"problem-link"},"Problem Link"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/palindrome-partitioning/"},"https://leetcode.com/problems/palindrome-partitioning/")),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"Given a string ",(0,i.kt)("inlineCode",{parentName:"p"},"s"),", partition ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," such that every substring of the partition is a ",(0,i.kt)("strong",{parentName:"p"},"palindrome"),". Return ",(0,i.kt)("em",{parentName:"p"},"all possible palindrome partitioning of"),(0,i.kt)("inlineCode",{parentName:"p"},"s"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input: s = "aab"\nOutput: [["a","a","b"],["aa","b"]]\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input: s = "a"\nOutput: [["a"]]\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= s.length <= 16")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"s")," contains only lowercase English letters.")),(0,i.kt)("h2",{id:"approach-1-backtracking"},"Approach 1: Backtracking"),(0,i.kt)(p,{mdxType:"Tabs"},(0,i.kt)(u,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)(m,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'class Solution {\npublic:\n    vector<vector<string>> partition(string s) {\n        // backtracking \n        // 1. define `ans` to hold `candidates`\n        vector<vector<string>> ans;\n        // 2. define `candidates` to hold all potential candidates (palindromic substring)\n        vector<string> candidates;\n        // 3. start backtrack from index 0\n        backtrack(s, ans, candidates, 0);\n        // 4. return ans\n        return ans;\n    }\n    \n     void backtrack(string s, vector<vector<string>>& ans, vector<string>& candidates, int start) {\n        // 1. check if the goal is fulfilled, \n        // i.e. reaching the end of string in this problem\n        if (start == s.size()) {\n            // if so, we push `candidates` to ans since we\'ve processed all characters\n            ans.push_back(candidates);\n            return;\n        }\n        // 2. find all potential candidates\n        for (int i = start; i < s.size(); i++) {\n            // we want to test all substrings, each substring is a potential candidate\n            // e.g. "aab" -> "a", "a", "b", "ab", "aa", "b", "aab"\n            string candidate = s.substr(start, i - start + 1);\n            // 3. check if the current candidate is palindrome or not \n            // if not, then we cannot push to `candidates`\n            if(!is_palindrome(candidate)) continue;\n            // 4. if so, push it to candidates\n            candidates.push_back(candidate);\n            // 5. backtrack with index + 1\n            backtrack(s, ans, candidates, i + 1);\n            // 6. remove the current substring from `candidates`\n            candidates.pop_back();\n        }\n    }\n    \n    \n    // there are different ways to check if `s` is palindrome \n    // here\'s my favourite one\n    bool is_palindrome(string s) {\n        return equal(s.begin(), s.begin() + s.size() / 2, s.rbegin());\n    }\n};\n'))),(0,i.kt)(u,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)(m,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'class Solution {\n    public List<List<String>> partition(String s) {\n        // backtracking \n        // 1. define `ans` to hold `candidates`\n        List<List<String>> ans = new ArrayList<>();\n        // 2. define `candidates` to hold all potential candidates (palindromic substring)\n        List<String> candidates = new ArrayList<>();\n        // 3. start backtrack from index 0\n        backtrack(s, ans, candidates, 0);\n        // 4. return ans\n        return ans;\n    }\n    \n    private void backtrack(String s, List<List<String>> ans, List<String> candidates, int start) {\n        // 1. check if the goal is fulfilled, \n        // i.e. reaching the end of string in this problem\n        if (start == s.length()) {\n            ans.add(new ArrayList<>(candidates));\n            return;\n        }\n        // 2. find all potential candidates\n        for (int i = start; i < s.length(); i++) {\n            // we want to test all substrings, each substring is a potential candidate\n            // e.g. "aab" -> "a", "a", "b", "ab", "aa", "b", "aab"\n            String candidate = s.substring(start, i + 1);\n            // 3. check if the current candidate is palindrome or not \n            // if not, then we cannot push to `candidates`\n            if (!isPalindrome(candidate)) continue;\n            // 4. if so, push it to candidates\n            candidates.add(candidate);\n            // 5. backtrack with index + 1\n            backtrack(s, ans, candidates, i + 1);\n            // 6. remove the current substring from `candidates`\n            candidates.remove(candidates.size() - 1);\n        }\n    }\n    \n    // there are different ways to check if `s` is palindrome \n    // here\'s one of the ways\n    private boolean isPalindrome(String s) {\n        return new StringBuilder(s).reverse().toString().equals(s);\n    }\n}\n'))),(0,i.kt)(u,{value:"py",label:"Python",mdxType:"TabItem"},(0,i.kt)(m,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},'class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def is_palindrome(s):\n            return s == s[::-1]\n    \n        def backtrack(s, ans, candidates, start):\n            # 1. check if the goal is fulfilled, \n            # i.e. reaching the end of string in this problem\n            if start == len(s):\n                # if so, we push `candidates` to ans since we\'ve processed all characters\n                ans.append(list(candidates))\n                return\n            # 2. find all potential candidates\n            for i in range(start, len(s)):\n                # we want to test all substrings, each substring is a potential candidate\n                # e.g. "aab" -> "a", "a", "b", "ab", "aa", "b", "aab"\n                candidate = s[start:i+1]\n                # 3. check if the current candidate is palindrome or not \n                # if not, then we cannot push to `candidates`\n                if not is_palindrome(candidate):\n                    continue\n                # 4. if so, push it to candidates\n                candidates.append(candidate)\n                # 5. backtrack with index + 1\n                backtrack(s, ans, candidates, i + 1)\n                # 6. remove the current substring from `candidates`\n                candidates.pop()\n\n        # backtracking \n        # 1. define `ans` to hold `candidates`\n        ans = []\n        # 2. define `candidates` to hold all potential candidates (palindromic substring)\n        candidates = []\n        # 3. start backtrack from index 0\n        backtrack(s, ans, candidates, 0)\n        # 4. return ans\n        return ans\n'))),(0,i.kt)(u,{value:"rs",label:"Rust",mdxType:"TabItem"},(0,i.kt)(m,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rs"},'impl Solution {\n    fn partition(s: String) -> Vec<Vec<String>> {\n        // backtracking \n        // 1. define `ans` to hold `candidates`\n        let mut ans = Vec::new();\n        // 2. define `candidates` to hold all potential candidates (palindromic substring)\n        let mut candidates = Vec::new();\n        // 3. start backtrack from index 0\n        Solution::backtrack(&s, &mut ans, &mut candidates, 0);\n        // 4. return ans\n        ans\n    }\n\n    fn backtrack(s: &String, ans: &mut Vec<Vec<String>>, candidates: &mut Vec<String>, start: usize) {\n        // 1. check if the goal is fulfilled, \n        // i.e. reaching the end of string in this problem\n        if start == s.len() {\n            // if so, we push `candidates` to ans since we\'ve processed all characters\n            ans.push(candidates.clone());\n            return;\n        }\n        // 2. find all potential candidates\n        for i in start..s.len() {\n            // we want to test all substrings, each substring is a potential candidate\n            // e.g. "aab" -> "a", "a", "b", "ab", "aa", "b", "aab"\n            let candidate = &s[start .. i + 1];\n            // 3. check if the current candidate is palindrome or not \n            // if not, then we cannot push to `candidates`\n            if !Solution::is_palindrome(candidate) {\n                continue;\n            }\n            // 4. if so, push it to candidates\n            candidates.push(candidate.to_string());\n            // 5. backtrack with index + 1\n            Solution::backtrack(s, ans, candidates, i + 1);\n            // 6. remove the current substring from `candidates`\n            candidates.pop();\n        }\n    }\n\n    fn is_palindrome(s: &str) -> bool {\n        s.chars().eq(s.chars().rev())\n    }\n}\n\n')))),(0,i.kt)("h2",{id:"approach-2-iterative-backtracking"},"Approach 2: Iterative Backtracking"),(0,i.kt)("p",null,"We can do a similar approach, but iteratively. That is create our own stack to track our processes. That process is to generate all possible partitions of the input string by considering each character as a potential starting point and exploring all possible substrings from those starting points, which are palindromes."),(0,i.kt)("p",null,'In the example of $$"aaab"$$, we can see that $$"a"$$, $$"aa"$$, $$"aaa"$$ would all be palindrome partitions we would want to check if we started at index, $$i == 0$$. We also see $$"aaab"$$ is not a palindrome, so we wouldn\'t further check that partition.'),(0,i.kt)("p",null,'If we further follow our example, we can see for $$"aaa"$$, we would check if "b" was a palindrome, then add it to the partition, and that would be 1 complete partition $$','["aaa", "b"]',"$$"),(0,i.kt)("p",null,'For $$"aa"$$, we would check $$"a"$$, and $$"ab"$$, and only add $$','["aa", "a"]',"$$ to our stack. Then again finish with $$",'["aa", "a", "b"]',"$$"),(0,i.kt)("p",null,'Finally for $$"a"$$, we would check the substrings, $$"a"$$, $$"aa"$$, and $$"aab"$$ and would and would create partitions using the first two as: $$','["a", "a"]',"$$ and $$",'["a", "aa"]',"$$. If we continued to follow the same logic, you could see we would eventually finish the question off with 4 partitions:\n$$",'["aaa", "b"]',"$$, $$",'["aa", "a", "b"]',"$$, $$",'["a", "aa", "b"]',"$$ and $$",'["a", "a", "a", "b"]',"$$"),(0,i.kt)("p",null,"Time Complexity: $$O(n*2^n)$$. For each character in string, we have 2 choices, to include it or don't include it in the current partition, creating up to $$2^n$$ partitions. We also do our palindrome check in $$O(n)$$ time."),(0,i.kt)("p",null,"Space Complexity: $$(n*2^n)$$, in the worst case, we will have $$2^n$$ partitions of size $$n$$"),(0,i.kt)(p,{mdxType:"Tabs"},(0,i.kt)(u,{value:"python",label:"Python",mdxType:"TabItem"},(0,i.kt)(m,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def is_palindrome(self, s, l, r):\n        # palidrome function, start at both ends, checking\n        # the characters are equal to each other. O(n) where\n        # n is the length of the string.\n        while l < r:\n            if s[l] != s[r]:\n                return False\n            l += 1\n            r -= 1\n        return True\n\n    def partition(self, s: str) -> List[List[str]]:\n        # initialize empty list to store all partitions of input string.\n        palindromes = []\n        # initialize our stack for backtracking purposes.\n        # The stack will track all partitions of the string.\n        # initialize and index, 0 as a starting point, and empty list\n        # as our partitions.\n        stack = [(0, [])]\n        while stack:\n            # pop off our index in string, s and current partition list.\n            i, partition = stack.pop()\n            # if the index is at the end of the string, we have explored\n            # all possible substrings in the current partition.\n            if i >= len(s):\n                # Add to our palindromes list, and continue.\n                palindromes.append(partition)\n                continue\n            # loop through all possible substrings starting at index i.\n            for j in range(i, len(s)):\n                # if the string, s from i to j is a palindrome:\n                if self.is_palindrome(s, i, j):\n                    # create a copy of current partition and add the \n                    # palindromic string section for i to j+1\n                    part = partition[:] + [s[i:j+1]]\n                    # add the index we are going to leave off of,\n                    # as well as the copy of the partition to the stack.\n                    stack.append((j + 1, part))\n        return palindromes\n\n")))))}k.isMDXComponent=!0}}]);