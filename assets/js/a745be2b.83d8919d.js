"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[75946],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>f});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function m(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},l=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,p=e.parentName,l=m(e,["components","mdxType","originalType","parentName"]),u=s(n),d=o,f=u["".concat(p,".").concat(d)]||u[d]||c[d]||i;return n?r.createElement(f,a(a({ref:t},l),{},{components:n})):r.createElement(f,a({ref:t},l))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=d;var m={};for(var p in t)hasOwnProperty.call(t,p)&&(m[p]=t[p]);m.originalType=e,m[u]="string"==typeof e?e:o,a[1]=m;for(var s=2;s<i;s++)a[s]=n[s];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},11107:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>a,default:()=>f,frontMatter:()=>i,metadata:()=>m,toc:()=>s});var r=n(87462),o=(n(67294),n(3905));const i={description:"Author: @wingkwong | https://leetcode.com/problems/minimum-number-of-operations-to-convert-time/"},a="2224 - Minimum Number of Operations to Convert Time (Easy)",m={unversionedId:"2200-2299/minimum-number-of-operations-to-convert-time-easy",id:"2200-2299/minimum-number-of-operations-to-convert-time-easy",title:"2224 - Minimum Number of Operations to Convert Time (Easy)",description:"Author: @wingkwong | https://leetcode.com/problems/minimum-number-of-operations-to-convert-time/",source:"@site/solutions/2200-2299/2224-minimum-number-of-operations-to-convert-time-easy.md",sourceDirName:"2200-2299",slug:"/2200-2299/minimum-number-of-operations-to-convert-time-easy",permalink:"/solutions/2200-2299/minimum-number-of-operations-to-convert-time-easy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2200-2299/2224-minimum-number-of-operations-to-convert-time-easy.md",tags:[],version:"current",sidebarPosition:2224,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/minimum-number-of-operations-to-convert-time/"},sidebar:"tutorialSidebar",previous:{title:"2223 - Sum of Scores of Built Strings (Hard)",permalink:"/solutions/2200-2299/sum-of-scores-of-built-strings-hard"},next:{title:"2225 - Find Players With Zero or One Losses (Medium)",permalink:"/solutions/2200-2299/find-players-with-zero-or-one-losses-medium"}},p={},s=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Greedy",id:"approach-1-greedy",level:2}],l=(u="SolutionAuthor",function(e){return console.warn("Component "+u+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",e)});var u;const c={toc:s},d="wrapper";function f(e){let{components:t,...n}=e;return(0,o.kt)(d,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"2224---minimum-number-of-operations-to-convert-time-easy"},"2224 - Minimum Number of Operations to Convert Time (Easy)"),(0,o.kt)("h2",{id:"problem-link"},"Problem Link"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/minimum-number-of-operations-to-convert-time/"},"https://leetcode.com/problems/minimum-number-of-operations-to-convert-time/")),(0,o.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,o.kt)("p",null,"You are given two strings ",(0,o.kt)("inlineCode",{parentName:"p"},"current")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"correct")," representing two ",(0,o.kt)("strong",{parentName:"p"},"24-hour times"),"."),(0,o.kt)("p",null,"24-hour times are formatted as ",(0,o.kt)("inlineCode",{parentName:"p"},'"HH:MM"'),", where ",(0,o.kt)("inlineCode",{parentName:"p"},"HH")," is between ",(0,o.kt)("inlineCode",{parentName:"p"},"00")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"23"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"MM")," is between ",(0,o.kt)("inlineCode",{parentName:"p"},"00")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"59"),". The earliest 24-hour time is ",(0,o.kt)("inlineCode",{parentName:"p"},"00:00"),", and the latest is ",(0,o.kt)("inlineCode",{parentName:"p"},"23:59"),"."),(0,o.kt)("p",null,"In one operation you can increase the time ",(0,o.kt)("inlineCode",{parentName:"p"},"current")," by ",(0,o.kt)("inlineCode",{parentName:"p"},"1"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"5"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"15"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"60")," minutes. You can perform this operation ",(0,o.kt)("strong",{parentName:"p"},"any")," number of times."),(0,o.kt)("p",null,"Return ",(0,o.kt)("em",{parentName:"p"},"the ",(0,o.kt)("strong",{parentName:"em"},"minimum number of operations")," needed to convert")," ",(0,o.kt)("inlineCode",{parentName:"p"},"current")," ",(0,o.kt)("em",{parentName:"p"},"to")," ",(0,o.kt)("inlineCode",{parentName:"p"},"correct"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 1:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'Input: current = "02:30", correct = "04:35"\nOutput: 3\nExplanation:\nWe can convert current to correct in 3 operations as follows:\n- Add 60 minutes to current. current becomes "03:30".\n- Add 60 minutes to current. current becomes "04:30".\n- Add 5 minutes to current. current becomes "04:35".\nIt can be proven that it is not possible to convert current to correct in fewer than 3 operations.\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 2:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'Input: current = "11:00", correct = "11:01"\nOutput: 1\nExplanation: We only have to add one minute to current, so the minimum number of operations needed is 1.\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Constraints:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"current")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"correct")," are in the format ",(0,o.kt)("inlineCode",{parentName:"li"},'"HH:MM"')),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"current <= correct"))),(0,o.kt)("h2",{id:"approach-1-greedy"},"Approach 1: Greedy"),(0,o.kt)("p",null,"Choosing $$60$$ 1 time is better than choosing $$15$$ 4 times. We choose from the largest number as many times as we could, then choose the second largest and etc. Since the operation is on minute, we need to convert the input to minute format first. Then we calculate the difference and try each operation to see how many times we could apply and update the difference after each operation."),(0,o.kt)(l,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int getMinutes(string t) {\n        int res = 0;\n        // handle HH\n        res += (t[0] - '0') * 10;\n        res += (t[1] - '0');\n        res *= 60;\n        // handle MM\n        res += (t[3] - '0') * 10;\n        res += (t[4] - '0');\n        return res;\n    }\n    \n    int convertTime(string current, string correct) {\n        // convert inputs to minute format\n        int from = getMinutes(current), to = getMinutes(correct);\n        // init ans & calculate the difference\n        int ans = 0, d = to - from;\n        // available operators - use largest one first\n        vector<int> ops{ 60, 15, 5, 1 };\n        // try each operation - take as many as possible\n        // and update the difference\n        for (auto x : ops) ans += d / x, d %= x;\n        return ans;\n    }\n};\n")))}f.isMDXComponent=!0}}]);