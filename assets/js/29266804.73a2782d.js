"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[84195],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>d});var o=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=o.createContext({}),u=function(e){var n=o.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},p=function(e){var n=u(e.components);return o.createElement(s.Provider,{value:n},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},h=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),m=u(t),h=a,d=m["".concat(s,".").concat(h)]||m[h]||c[h]||r;return t?o.createElement(d,l(l({ref:n},p),{},{components:t})):o.createElement(d,l({ref:n},p))}));function d(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,l=new Array(r);l[0]=h;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i[m]="string"==typeof e?e:a,l[1]=i;for(var u=2;u<r;u++)l[u]=t[u];return o.createElement.apply(null,l)}return o.createElement.apply(null,t)}h.displayName="MDXCreateElement"},56142:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>$,frontMatter:()=>r,metadata:()=>i,toc:()=>u});var o=t(87462),a=(t(67294),t(3905));const r={description:"Author: @ColeB2 | https://leetcode.com/problems/burst-balloons/",tags:["Array","Dynamic Programming"]},l="0312 - Burst Balloons (Hard)",i={unversionedId:"0300-0399/burst-balloons-hard",id:"0300-0399/burst-balloons-hard",title:"0312 - Burst Balloons (Hard)",description:"Author: @ColeB2 | https://leetcode.com/problems/burst-balloons/",source:"@site/solutions/0300-0399/0312-burst-balloons-hard.md",sourceDirName:"0300-0399",slug:"/0300-0399/burst-balloons-hard",permalink:"/solutions/0300-0399/burst-balloons-hard",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0300-0399/0312-burst-balloons-hard.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Dynamic Programming",permalink:"/solutions/tags/dynamic-programming"}],version:"current",sidebarPosition:312,frontMatter:{description:"Author: @ColeB2 | https://leetcode.com/problems/burst-balloons/",tags:["Array","Dynamic Programming"]},sidebar:"tutorialSidebar",previous:{title:"0309 - Best Time to Buy and Sell Stock with Cooldown (Medium)",permalink:"/solutions/0300-0399/best-time-to-buy-and-sell-stock-with-cooldown-medium"},next:{title:"0322 - Coin Change (Medium)",permalink:"/solutions/0300-0399/coin-change-medium"}},s={},u=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Dynamic Programming - Memoization",id:"approach-1-dynamic-programming---memoization",level:2}],p=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",n)},m=p("Tabs"),c=p("TabItem"),h=p("SolutionAuthor"),d={toc:u},b="wrapper";function $(e){let{components:n,...t}=e;return(0,a.kt)(b,(0,o.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"0312---burst-balloons-hard"},"0312 - Burst Balloons (Hard)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/burst-balloons/"},"https://leetcode.com/problems/burst-balloons/")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"You are given ",(0,a.kt)("inlineCode",{parentName:"p"},"n")," balloons, indexed from ",(0,a.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"n - 1"),". Each balloon is painted with a number on it represented by an array ",(0,a.kt)("inlineCode",{parentName:"p"},"nums"),". You are asked to burst all the balloons."),(0,a.kt)("p",null,"If you burst the ",(0,a.kt)("inlineCode",{parentName:"p"},"ith")," balloon, you will get ",(0,a.kt)("inlineCode",{parentName:"p"},"nums[i - 1] * nums[i] * nums[i + 1]")," coins. If ",(0,a.kt)("inlineCode",{parentName:"p"},"i - 1")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"i + 1")," goes out of bounds of the array, then treat it as if there is a balloon with a ",(0,a.kt)("inlineCode",{parentName:"p"},"1")," painted on it."),(0,a.kt)("p",null,"Return ",(0,a.kt)("em",{parentName:"p"},"the maximum coins you can collect by bursting the balloons wisely"),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: nums = [3,1,5,8]\nOutput: 167\nExplanation:\nnums = [3,1,5,8] --\x3e [3,5,8] --\x3e [3,8] --\x3e [8] --\x3e []\ncoins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: nums = [1,5]\nOutput: 10\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"n == nums.length")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= n <= 300")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"0 <= nums[i] <= 100"))),(0,a.kt)("h2",{id:"approach-1-dynamic-programming---memoization"},"Approach 1: Dynamic Programming - Memoization"),(0,a.kt)("p",null,"If we solve this problem recursively we must think of our base case. When all balloons are already popped we can only get 0 coins. Then building up from then, we know, if we have 1 balloon, we will get the coins only from that balloon."),(0,a.kt)("p",null,"From our base case, we can then build on it. Our goal being that for each $$kth$$ balloon we select as the last balloon we pop, we can calculate the subproblems around that $$kth$$ balloon. That being the subproblem from $$","[i : k - 1]","$$ and the sub-problem $$","[k + 1 : j]","$$. Meaning for each $$i$$ and $$j$$ we can select all $$k$$ values to test first, and continue to check the sub problems."),(0,a.kt)("p",null,"If we preprocess our $$nums$$ array with $$1$$ values on each side to handle the case where we pop and end balloon that need to be multiplied by one, then we can initialize our $$i$$ and $$j$$ values as $$1$$ and $$nums.length - 2$$ which will be the start and end points of our old $$nums$$ array inside our new processed $$nums$$ array."),(0,a.kt)("p",null,"The memoization comes from storing the max coins we get for each $$k$$ we try at each $$i$$ and $$j$$ value. By checking the amount of coins we can get for each $$k$$ from $$i$$ to $$j$$ and caching the max coin value out of all the $$k$$'s we test we can reuse the work of that $$i,j$$ pair for future sub problems."),(0,a.kt)("p",null,"Time Complexity: $$O(n^3)$$ where n in the length of $$nums$$. We are going to have $$n^3$$ sub problems where we check each $$i$$, $$j$$, and $$k$$ value."),(0,a.kt)("p",null,"Space Complexity: $$O(n^2)$$. Since we are only storing the $$i,j$$ values in our cache, we will only end up with $$n^2$$ values inside our cache."),(0,a.kt)(m,{mdxType:"Tabs"},(0,a.kt)(c,{value:"python",label:"Python",mdxType:"TabItem"},(0,a.kt)(h,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        # Pre process nums with 1s on each end to handle the edge\n        # ballons where when we pop them the coins are multiplied by 1.   \n        nums = [1] + nums + [1]\n        # initialize our cache with key: (i, j) where i, j are the\n        # start and end points of our array and the value: max_coins\n        # being the max number of coins we can get from that subproblem\n        # with those (i, j) end points.\n        cache = {}\n        # recursive function. Parameter i, j are our start and endpoints\n        # in the array.\n        def helper(i, j):\n            # base case: \n            #i > j it means we have 0 values inside our array.\n            if i > j:\n                # return 0, as we can't get any coins from empty array.\n                return 0\n            # memoization: If we calculated this sub problem before:\n            if (i, j) in cache:\n                # get the value from the sub problem.\n                return cache[(i, j)]\n            # initialize max coins to -infinity.\n            max_c = float('-inf')\n            # loop through all the balloons from i to j. We use j + 1\n            # as we want j to be an inclusive balloon that we can pop.\n            # k will represent the last balloon we pop in the sub array.\n            for k in range(i, j + 1):\n                # initialize coins as k, being the last balloon we pop.\n                coins = nums[k]\n                # multiply that kth balloon by the end points, which\n                # will be the balloons next to k when we pop all the\n                # other balloons between the end points. Those endpoints\n                # will be i - 1, and j + 1 which on the first iteration\n                # will be the 1's that we preprocessed nums with.\n                coins *= nums[i - 1]\n                coins *= nums[j + 1]\n                # We solved the base case for k being the last balloon\n                # popped, now we need to add that to the sub problems\n                # where we select ballons between i, k - 1 and k + 1, j.\n                # This skips k, as that is the last balloon.\n                coins += (helper(i, k - 1) + helper(k + 1, j))\n                # update our max coin counter.\n                max_c = max(max_c, coins)\n                # update our cache so we don't have to redo this work\n                # on future iterations.\n                cache[(i,j)] = max_c\n            # return the value we calculated above.\n            return cache[(i, j)]\n        # initialize our algorithm with the endpoints of the array.\n        # example 1: 3,1,5,8. We preprocess it with 1's giving us:\n        # 1,3,1,5,8,1 meaning the first number 3, will be indexed at\n        # index 1, and the last number will be indexed at nums.length - 2.\n        return helper(1, len(nums) - 2)\n")))))}$.isMDXComponent=!0}}]);