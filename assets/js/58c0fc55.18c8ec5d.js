"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[37452],{3905:(e,n,t)=>{t.d(n,{Zo:()=>m,kt:()=>h});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},m=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=p(t),d=r,h=c["".concat(s,".").concat(d)]||c[d]||u[d]||i;return t?a.createElement(h,l(l({ref:n},m),{},{components:t})):a.createElement(h,l({ref:n},m))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,l=new Array(i);l[0]=d;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[c]="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},97135:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>b,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=t(87462),r=(t(67294),t(3905));const i={description:"Author: @ColeB2 | https://leetcode.com/problems/valid-parenthesis-string/",tags:["String","Dynamic Programming","Stack","Greedy"]},l="0678 - Valid Parenthesis String (Medium)",o={unversionedId:"0600-0699/valid-parenthesis-string-medium",id:"0600-0699/valid-parenthesis-string-medium",title:"0678 - Valid Parenthesis String (Medium)",description:"Author: @ColeB2 | https://leetcode.com/problems/valid-parenthesis-string/",source:"@site/solutions/0600-0699/0678-valid-parenthesis-string-medium.md",sourceDirName:"0600-0699",slug:"/0600-0699/valid-parenthesis-string-medium",permalink:"/solutions/0600-0699/valid-parenthesis-string-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0600-0699/0678-valid-parenthesis-string-medium.md",tags:[{label:"String",permalink:"/solutions/tags/string"},{label:"Dynamic Programming",permalink:"/solutions/tags/dynamic-programming"},{label:"Stack",permalink:"/solutions/tags/stack"},{label:"Greedy",permalink:"/solutions/tags/greedy"}],version:"current",sidebarPosition:678,frontMatter:{description:"Author: @ColeB2 | https://leetcode.com/problems/valid-parenthesis-string/",tags:["String","Dynamic Programming","Stack","Greedy"]},sidebar:"tutorialSidebar",previous:{title:"0662 - Maximum Width of Binary Tree (Medium)",permalink:"/solutions/0600-0699/maximum-width-of-binary-tree-medium"},next:{title:"0680 - Valid Palindrome II (Easy)",permalink:"/solutions/0600-0699/valid-palindrome-ii-easy"}},s={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Greedy",id:"approach-1-greedy",level:2}],m=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",n)},c=m("Tabs"),u=m("TabItem"),d=m("SolutionAuthor"),h={toc:p},g="wrapper";function b(e){let{components:n,...t}=e;return(0,r.kt)(g,(0,a.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"0678---valid-parenthesis-string-medium"},"0678 - Valid Parenthesis String (Medium)"),(0,r.kt)("h2",{id:"problem-link"},"Problem Link"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/valid-parenthesis-string/"},"https://leetcode.com/problems/valid-parenthesis-string/")),(0,r.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.kt)("p",null,"Given a string ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," containing only three types of characters: ",(0,r.kt)("inlineCode",{parentName:"p"},"'('"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"')'")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"'*'"),", return ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," ",(0,r.kt)("em",{parentName:"p"},"if")," ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," ",(0,r.kt)("em",{parentName:"p"},"is ",(0,r.kt)("strong",{parentName:"em"},"valid")),"."),(0,r.kt)("p",null,"The following rules define a valid string:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Any left parenthesis ",(0,r.kt)("inlineCode",{parentName:"li"},"'('")," must have a corresponding right parenthesis ",(0,r.kt)("inlineCode",{parentName:"li"},"')'"),"."),(0,r.kt)("li",{parentName:"ul"},"Any right parenthesis ",(0,r.kt)("inlineCode",{parentName:"li"},"')'")," must have a corresponding left parenthesis ",(0,r.kt)("inlineCode",{parentName:"li"},"'('"),"."),(0,r.kt)("li",{parentName:"ul"},"Left parenthesis ",(0,r.kt)("inlineCode",{parentName:"li"},"'('")," must go before the corresponding right parenthesis ",(0,r.kt)("inlineCode",{parentName:"li"},"')'"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"'*'")," could be treated as a single right parenthesis ",(0,r.kt)("inlineCode",{parentName:"li"},"')'")," or a single left parenthesis ",(0,r.kt)("inlineCode",{parentName:"li"},"'('")," or an empty string ",(0,r.kt)("inlineCode",{parentName:"li"},'""'),".")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Input: s = "()"\nOutput: true\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Input: s = "(*)"\nOutput: true\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 3:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Input: s = "(*))"\nOutput: true\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Constraints:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"1 <= s.length <= 100")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"s[i]")," is ",(0,r.kt)("inlineCode",{parentName:"li"},"'('"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"')'")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"'*'"),".")),(0,r.kt)("h2",{id:"approach-1-greedy"},"Approach 1: Greedy"),(0,r.kt)("p",null,"If there were no $$'*'$$ characters, we could easily do this, using an integer, and just tracking $$'('$$ chars as a $$+1$$ and $$')'$$ as a $$-1$$. Returning False, if the result ever goes negative, and True if the final result is $$0$$."),(0,r.kt)("p",null,"The $$'",(0,r.kt)("em",{parentName:"p"},"'$$ throws a little wrench, so instead we can track two integers. Both a min balance and a max balance. That is for the min balance we can do the same thing and treat all $$'"),"'$$ characters as $$')'$$ but reset to zero if the result ever goes negative. This would be us converting a $$'*'$$ to something else."),(0,r.kt)("p",null,"Then for the max balance, we can do the same, but treat all $$'",(0,r.kt)("em",{parentName:"p"},"'$$ as $$'('$$. Then we know if the max balance ever reaches negative, that we absolutely can't create a valid string, as we don't have enough $$'"),"'$$, and as long as our max balance is positive, we can reset our min balance to 0 to convert our $$'*'$$ into something else."),(0,r.kt)("p",null,"If in the end, our min balance is 0, then we can create a balanced string."),(0,r.kt)("p",null,"Time Complexity: $$O(n)$$, we just need to iterate through each character once."),(0,r.kt)("p",null,"Space Complexity: $$O(1)$$, we can do this in constant time just tracking our max and min balances."),(0,r.kt)(c,{mdxType:"Tabs"},(0,r.kt)(u,{value:"python",label:"Python",mdxType:"TabItem"},(0,r.kt)(d,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    # track 2 values, min_balance and max_balance which represent\n    # the balance of parenthesis. Positive means, we have more '('\n    # negative means we have more ')'.\n    # The min_balance value will represent the lowest balance of\n    # parenthesis. This means we always convert a '*' to a ')',\n    # without going negative. This means we can reconvert a '*' \n    # if the value ever does go negative.\n    # The max_balance value will represent the highest balance of\n    # parenthesis. Meaning we will always convert a '*' into a '('\n    # If the max_balance ever hits negative, it means we have way\n    # too many ')' to create a balanced parenthesis string.\n    # So as long as max_balance is positive, we can always reset\n    # min_balance to 0, as we can convert a '*' into something else.\n    def checkValidString(self, s: str) -> bool:\n        # initialize min and max balances\n        min_balance, max_balance = 0, 0\n        # iterate through each character in the string\n        for ch in s:\n            if ch == '(':\n                # Open parenthesis always adjust our balance positive\n                min_balance += 1\n                max_balance += 1\n            elif ch == ')':\n                # close parenthesis lowers both balances, but if\n                # If the min reaches negative, reset it to 0.\n                min_balance = max(0, min_balance - 1)\n                max_balance -= 1\n            elif ch == '*':\n                # For min balance consider the '*' a ')', if we\n                # reach negative, convert it to something else.\n                min_balance = max(0, min_balance - 1)\n                # add it as open '(' parenthesis.\n                max_balance += 1\n            # max ever reaches 0, since we are always converting '*'\n            # into '(', it means we have way too many ')'.\n            if max_balance < 0:\n                return False\n        # if our min_balance reached 0, it means we have an even number\n        # of parenthesis, so then it returns True. If not, then it will\n        # return False.\n        return min_balance == 0\n")))))}b.isMDXComponent=!0}}]);