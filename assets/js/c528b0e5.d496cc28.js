"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[28740],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>y});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=l(n),h=a,y=m["".concat(c,".").concat(h)]||m[h]||p[h]||o;return n?r.createElement(y,i(i({ref:t},u),{},{components:n})):r.createElement(y,i({ref:t},u))}));function y(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[m]="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},84053:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>f,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var r=n(87462),a=(n(67294),n(3905));const o={description:"Author: @hiverkiya | https://leetcode.com/problems/check-if-an-array-is-consecutive/",tags:["Array"]},i="2229 - Check if an Array is Consecutive (Easy)",s={unversionedId:"2200-2299/check-if-an-array-is-consecutive-easy",id:"2200-2299/check-if-an-array-is-consecutive-easy",title:"2229 - Check if an Array is Consecutive (Easy)",description:"Author: @hiverkiya | https://leetcode.com/problems/check-if-an-array-is-consecutive/",source:"@site/solutions/2200-2299/2229-check-if-an-array-is-consecutive-easy.md",sourceDirName:"2200-2299",slug:"/2200-2299/check-if-an-array-is-consecutive-easy",permalink:"/solutions/2200-2299/check-if-an-array-is-consecutive-easy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2200-2299/2229-check-if-an-array-is-consecutive-easy.md",tags:[{label:"Array",permalink:"/solutions/tags/array"}],version:"current",sidebarPosition:2229,frontMatter:{description:"Author: @hiverkiya | https://leetcode.com/problems/check-if-an-array-is-consecutive/",tags:["Array"]},sidebar:"tutorialSidebar",previous:{title:"2227 - Encrypt and Decrypt Strings (Hard)",permalink:"/solutions/2200-2299/encrypt-and-decrypt-strings-hard"},next:{title:"2231 -  Largest Number After Digit Swaps by Parity (Easy)",permalink:"/solutions/2200-2299/largest-number-after-digit-swaps-by-parity-easy"}},c={},l=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Sort and Compare",id:"approach-1-sort-and-compare",level:2}],u=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",t)},m=u("Tabs"),p=u("TabItem"),h=u("SolutionAuthor"),y={toc:l},d="wrapper";function f(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,r.Z)({},y,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"2229---check-if-an-array-is-consecutive-easy"},"2229 - Check if an Array is Consecutive (Easy)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/check-if-an-array-is-consecutive/"},"https://leetcode.com/problems/check-if-an-array-is-consecutive/")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"Given an integer array $nums$, return $true$ ",(0,a.kt)("em",{parentName:"p"},"if")," $nums$ ",(0,a.kt)("em",{parentName:"p"},"is")," ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("em",{parentName:"strong"},"consecutive"))," ",(0,a.kt)("em",{parentName:"p"},", otherwise return")," $false$."),(0,a.kt)("p",null,"An array is ",(0,a.kt)("strong",{parentName:"p"},"consecutive")," if it contains every number in the range $","[x, x + n - 1]","$ ",(0,a.kt)("strong",{parentName:"p"},"(inclusive)"),", where $x$ is the minimum number in the array and $n$ is the length of the array."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: nums = [1, 3, 4, 2]\nOutput: true\nExplanation:\nThe minimum value is 1 and the length of nums is 4.\nAll of the values in the range [x, x + n - 1] = [1, 1 + 4 - 1] = [1, 4] = (1, 2, 3, 4) occur in nums.\nTherefore, nums is consecutive.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: nums = [1, 3]\nOutput: false\nExplanation:\nThe minimum value is 1 and the length of nums is 2.\nThe value 2 in the range [x, x + n - 1] = [1, 1 + 2 - 1], = [1, 2] = (1, 2) does not occur in nums.\nTherefore, nums is not consecutive.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 3:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: nums = [3, 5, 4]\nOutput: true\nExplanation:\nThe minimum value is 3 and the length of nums is 3.\nAll of the values in the range [x, x + n - 1] = [3, 3 + 3 - 1] = [3, 5] = (3, 4, 5) occur in nums.\nTherefore, nums is consecutive.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"$1 <= nums.length <= 10^5$"),(0,a.kt)("li",{parentName:"ul"},"$0 <= nums","[i]"," <= 10^5$")),(0,a.kt)("h2",{id:"approach-1-sort-and-compare"},"Approach 1: Sort and Compare"),(0,a.kt)("p",null,"The problem statements require you to check for consecutive elements in a range, which means the element next to the current element should be one number higher. For example, $","[1 , 2 , 3]","$ are consecutive elements while $","[1, 3, 4]","$ or $","[1, 2, 2, 3, 4]","$ are not. That means the ",(0,a.kt)("strong",{parentName:"p"},"current element + 1 = next element"),"."),(0,a.kt)("p",null,"The elements are given in random order, and it's mentioned that the elements are in a range $","[x , x + n - 1]","$ with $x$ as the minimum element. To find the minimum element, you can sort the array in ascending order, and the first element will be the minimum element."),(0,a.kt)("p",null,"However, we simply have to check the consecutive elements, and even if they are repeating like $","[1, 1, 2, 3, 4]","$, they are not consecutive as they don't satisfy the condition $nums","[i]"," + 1 == nums","[i + 1]","$. The primary focus is on the first statement, as the other one may confuse you to think of ambiguous corner cases. You can easily check for consecutive elements after sorting the array."),(0,a.kt)("p",null,"Time Complexity: $O(n*log(n))$. The Time complexity of the default sort function in C++"),(0,a.kt)("p",null,"Space Complexity: $O(1)$. No extra space is used"),(0,a.kt)(m,{mdxType:"Tabs"},(0,a.kt)(p,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(h,{name:"@hiverkiya",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    bool isConsecutive(vector<int>& nums) {\n        // using sort from C++ STL to order the elements in ascending order \n        sort(nums.begin(), nums.end());\n        // run a loop to check elements till size-1 to avoid overflow\n        for(int i = 0; i < nums.size() - 1; i++) {\n            // check if current element + 1 equals to the next element\n            if(nums[i] + 1 != nums[i + 1]) return false;\n        }\n        return true;\n    }\n};\n")))))}f.isMDXComponent=!0}}]);