"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[52016],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,p=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=s(n),c=i,h=m["".concat(p,".").concat(c)]||m[c]||d[c]||o;return n?r.createElement(h,a(a({ref:t},u),{},{components:n})):r.createElement(h,a({ref:t},u))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=c;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l[m]="string"==typeof e?e:i,a[1]=l;for(var s=2;s<o;s++)a[s]=n[s];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},84090:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var r=n(87462),i=(n(67294),n(3905));const o={description:"Author: @wingkwong | https://leetcode.com/problems/count-good-triplets-in-an-array/"},a="2179 - Count Good Triplets in an Array (Hard)",l={unversionedId:"2100-2199/count-good-triplets-in-an-array-hard",id:"2100-2199/count-good-triplets-in-an-array-hard",title:"2179 - Count Good Triplets in an Array (Hard)",description:"Author: @wingkwong | https://leetcode.com/problems/count-good-triplets-in-an-array/",source:"@site/solutions/2100-2199/2179-count-good-triplets-in-an-array-hard.md",sourceDirName:"2100-2199",slug:"/2100-2199/count-good-triplets-in-an-array-hard",permalink:"/solutions/2100-2199/count-good-triplets-in-an-array-hard",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2100-2199/2179-count-good-triplets-in-an-array-hard.md",tags:[],version:"current",sidebarPosition:2179,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/count-good-triplets-in-an-array/"},sidebar:"tutorialSidebar",previous:{title:"2178 - Maximum Split of Positive Even Integers (Medium)",permalink:"/solutions/2100-2199/maximum-split-of-positive-even-integers-medium"},next:{title:"2180 - Count Integers With Even Digit Sum (Easy)",permalink:"/solutions/2100-2199/count-integers-with-even-digit-sum-easy"}},p={},s=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: BIT",id:"approach-1-bit",level:2}],u=(m="SolutionAuthor",function(e){return console.warn("Component "+m+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",e)});var m;const d={toc:s},c="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(c,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"2179---count-good-triplets-in-an-array-hard"},"2179 - Count Good Triplets in an Array (Hard)"),(0,i.kt)("h2",{id:"problem-link"},"Problem Link"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/count-good-triplets-in-an-array/"},"https://leetcode.com/problems/count-good-triplets-in-an-array/")),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"You are given two ",(0,i.kt)("strong",{parentName:"p"},"0-indexed")," arrays ",(0,i.kt)("inlineCode",{parentName:"p"},"nums1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"nums2")," of length ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),", both of which are ",(0,i.kt)("strong",{parentName:"p"},"permutations")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"[0, 1, ..., n - 1]"),"."),(0,i.kt)("p",null,"A ",(0,i.kt)("strong",{parentName:"p"},"good triplet")," is a set of ",(0,i.kt)("inlineCode",{parentName:"p"},"3")," ",(0,i.kt)("strong",{parentName:"p"},"distinct")," values which are present in ",(0,i.kt)("strong",{parentName:"p"},"increasing order")," by position both in ",(0,i.kt)("inlineCode",{parentName:"p"},"nums1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"nums2"),". In other words, if we consider ",(0,i.kt)("inlineCode",{parentName:"p"},"pos1v")," as the index of the value ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"nums1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"pos2v")," as the index of the value ",(0,i.kt)("inlineCode",{parentName:"p"},"v")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"nums2"),", then a good triplet will be a set ",(0,i.kt)("inlineCode",{parentName:"p"},"(x, y, z)")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"0 <= x, y, z <= n - 1"),", such that ",(0,i.kt)("inlineCode",{parentName:"p"},"pos1x < pos1y < pos1z")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"pos2x < pos2y < pos2z"),"."),(0,i.kt)("p",null,"Return ",(0,i.kt)("em",{parentName:"p"},"the ",(0,i.kt)("strong",{parentName:"em"},"total number")," of good triplets"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: nums1 = [2,0,1,3], nums2 = [0,1,2,3]\nOutput: 1\nExplanation: \nThere are 4 triplets (x,y,z) such that pos1x < pos1y < pos1z. They are (2,0,1), (2,0,3), (2,1,3), and (0,1,3). \nOut of those triplets, only the triplet (0,1,3) satisfies pos2x < pos2y < pos2z. Hence, there is only 1 good triplet.\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3]\nOutput: 4\nExplanation: The 4 good triplets are (4,0,3), (4,0,2), (4,1,3), and (4,1,2).\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"n == nums1.length == nums2.length")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"3 <= n <= 10^5")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0 <= nums1[i], nums2[i] <= n - 1")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nums1")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"nums2")," are permutations of ",(0,i.kt)("inlineCode",{parentName:"li"},"[0, 1, ..., n - 1]"),".")),(0,i.kt)("h2",{id:"approach-1-bit"},"Approach 1: BIT"),(0,i.kt)("p",null,"BIT aka fenwick tree is a data structure that can efficiently update elements and calculate prefix sums in a table of numbers. You can check out more details ",(0,i.kt)("a",{parentName:"p",href:"https://cp-algorithms.com/data_structures/fenwick.html"},"here"),"."),(0,i.kt)("p",null,"In this problem, we use two BITs to store the number of elements $$l$$ smaller than $$nums","[i]","$$ and the number of elements $$r$$ greater than $$nums","[i]","$$. In other word, we fix the middle point and calculate the number of triplets by $$l * r$$ at that point. The answer is the sum of them."),(0,i.kt)("p",null,"First, we need to know that what is the position of $$nums1","[i]","$$ in $$nums2","[i]","$$. Then we iterate the array to get the position in $$nums2$$ for $$nums1","[i]","$$. We call $$query$$ to get the number of elements smaller than it. It's also the prefix sum or the range query from $$0$$ to it. Then we update the tree for this position. Similarly, we do the same thing for the second BIT in reversed order. This time we are looking for the suffix sum with the range from the target position till the end. At the end, we sum all $$l","[i]"," * r","[i]","$$."),(0,i.kt)(u,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"template <class T>\nstruct BIT {\n  int n; vector<T> t;\n  BIT() {}\n  BIT(int _n) {\n    n = _n; t.assign(n + 1, 0);\n  }\n  T query(int i) {\n    T ans = 0;\n    for (; i >= 1; i -= (i & -i)) ans += t[i];\n    return ans;\n  }\n  void upd(int i, T val) {\n    if (i <= 0) return;\n    for (; i <= n; i += (i & -i)) t[i] += val;\n  }\n  void upd(int l, int r, T val) {\n    upd(l, val);\n    upd(r + 1, -val);\n  }\n  T query(int l, int r) {\n    return query(r) - query(l - 1);\n  }\n};\n\nclass Solution {\npublic:\n    long long goodTriplets(vector<int>& nums1, vector<int>& nums2) {\n        long long ans = 0;\n        int n = nums1.size();\n        vector<int> id(n);\n        BIT<int> lb(n), rb(n);\n        vector<int> l(n), r(n);\n        // create an array for position mapping\n        for (int i = 0; i < n; i++) id[nums2[i]] = i + 1;\n        // building 1st BIT - counting smaller elements\n        for (int i = 0; i < n; i++) {\n            // target position in nums2 for nums1[i]\n            int x = id[nums1[i]];\n            // get the prefix sum\n            l[i] = lb.query(x);\n            // update the tree\n            lb.upd(x, 1);\n        }\n        // buildign 2nd BIT - counting greater elements\n        for (int i = n - 1; i >= 0; i--) {\n            // target position in nums2 for nums1[i]\n            int x = id[nums1[i]];\n            // get the suffix sum\n            r[i] = rb.query(x, n);\n            // update the tree\n            rb.upd(x, 1);\n        }\n        // calculate the total triplets\n        for (int i = 0; i < n; i++) {\n            ans += 1LL * l[i] * r[i];\n        }\n        return ans;\n    }\n};\n")))}h.isMDXComponent=!0}}]);