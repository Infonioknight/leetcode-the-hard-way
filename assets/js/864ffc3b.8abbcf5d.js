"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[44788],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>m});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),h=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},d=function(e){var n=h(e.components);return a.createElement(s.Provider,{value:n},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=h(t),c=i,m=p["".concat(s,".").concat(c)]||p[c]||u[c]||r;return t?a.createElement(m,l(l({ref:n},d),{},{components:t})):a.createElement(m,l({ref:n},d))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=c;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[p]="string"==typeof e?e:i,l[1]=o;for(var h=2;h<r;h++)l[h]=t[h];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},42056:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>y,frontMatter:()=>r,metadata:()=>o,toc:()=>h});var a=t(87462),i=(t(67294),t(3905));const r={description:"Author: @vigneshshiv | https://leetcode.com/problems/design-hashmap/"},l="0706 - Design HashMap (Medium)",o={unversionedId:"0700-0799/design-hashmap-medium",id:"0700-0799/design-hashmap-medium",title:"0706 - Design HashMap (Medium)",description:"Author: @vigneshshiv | https://leetcode.com/problems/design-hashmap/",source:"@site/solutions/0700-0799/0706-design-hashmap-medium.md",sourceDirName:"0700-0799",slug:"/0700-0799/design-hashmap-medium",permalink:"/solutions/0700-0799/design-hashmap-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0700-0799/0706-design-hashmap-medium.md",tags:[],version:"current",sidebarPosition:706,frontMatter:{description:"Author: @vigneshshiv | https://leetcode.com/problems/design-hashmap/"},sidebar:"tutorialSidebar",previous:{title:"0704 - Binary Search (Easy)",permalink:"/solutions/0700-0799/binary-search-easy"},next:{title:"0718 - Maximum Length of Repeated Subarray (Medium)",permalink:"/solutions/0700-0799/maximum-length-of-repeated-subarray-medium"}},s={},h=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: With Array and LinkedList",id:"approach-1-with-array-and-linkedlist",level:2}],d=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",n)},p=d("Tabs"),u=d("TabItem"),c=d("SolutionAuthor"),m={toc:h},k="wrapper";function y(e){let{components:n,...t}=e;return(0,i.kt)(k,(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"0706---design-hashmap-medium"},"0706 - Design HashMap (Medium)"),(0,i.kt)("h2",{id:"problem-link"},"Problem Link"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/design-hashmap/"},"https://leetcode.com/problems/design-hashmap/")),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"Design a HashMap without using any built-in hash table libraries."),(0,i.kt)("p",null,"Implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"MyHashMap")," class:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"MyHashMap()")," initializes the object with an empty map."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"void put(int key, int value)")," inserts a ",(0,i.kt)("inlineCode",{parentName:"li"},"(key, value)")," pair into the HashMap. If the ",(0,i.kt)("inlineCode",{parentName:"li"},"key")," already exists in the map, update the corresponding ",(0,i.kt)("inlineCode",{parentName:"li"},"value"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"int get(int key)")," returns the ",(0,i.kt)("inlineCode",{parentName:"li"},"value")," to which the specified ",(0,i.kt)("inlineCode",{parentName:"li"},"key")," is mapped, or ",(0,i.kt)("inlineCode",{parentName:"li"},"-1")," if this map contains no mapping for the ",(0,i.kt)("inlineCode",{parentName:"li"},"key"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"void remove(key)")," removes the ",(0,i.kt)("inlineCode",{parentName:"li"},"key")," and its corresponding ",(0,i.kt)("inlineCode",{parentName:"li"},"value")," if the map contains the mapping for the ",(0,i.kt)("inlineCode",{parentName:"li"},"key"),".")),(0,i.kt)("br",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input\n["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]\n[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]\nOutput\n[null, null, null, 1, -1, null, 1, null, -1]\n\nExplanation\nMyHashMap myHashMap = new MyHashMap();\nmyHashMap.put(1, 1); // The map is now [[1,1]]\nmyHashMap.put(2, 2); // The map is now [[1,1], [2,2]]\nmyHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]\nmyHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]\nmyHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)\nmyHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]\nmyHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]\nmyHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0 <= key, value <= 10^6")),(0,i.kt)("li",{parentName:"ul"},"At most ",(0,i.kt)("inlineCode",{parentName:"li"},"10^4")," calls will be made to ",(0,i.kt)("inlineCode",{parentName:"li"},"put"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"get"),", and ",(0,i.kt)("inlineCode",{parentName:"li"},"remove"),".")),(0,i.kt)("br",null),(0,i.kt)("h2",{id:"approach-1-with-array-and-linkedlist"},"Approach 1: With Array and LinkedList"),(0,i.kt)("admonition",{title:"Prerequisite",type:"info"},(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"../../tutorials/basic-topics/hash-map"},"HashMap")))),(0,i.kt)("p",null,"As a problem stated, Design HashMap, but what is HashMap or HashTable ?"),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"A hash tables is a data structure that maps keys to values")," for highly efficient lookup (constant $O(1)$ time)."),(0,i.kt)("p",null,"In this simple implementation, we use an array of linked lists and a hash code function to store the values."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"To Insert a key"),","),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"First, compute the key\u2019s hash code, which will usually be an ",(0,i.kt)("inlineCode",{parentName:"li"},"int")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"long"),"."),(0,i.kt)("li",{parentName:"ul"},"Then, map the hash code to an index in the array. Eg: ",(0,i.kt)("inlineCode",{parentName:"li"},"hash(key) % array_length"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("em",{parentName:"li"},"Store the key and value in this index"),", we must use linked list because of collisions.")),(0,i.kt)("p",null,"How can we design the HashMap which is similar to used in programming languages?"),(0,i.kt)("p",null,"Few points to consider while designing the HashMap, "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"How to handle the collisions? Collision is if the same key is mapped to more than value. "),(0,i.kt)("li",{parentName:"ul"},"HashMap should be efficient and should automatically grow and shrink in size. ")),(0,i.kt)("p",null,"We will look at first, How to handle collisions. There are multiple ways of handling HashTable (HashMap) collision, here I have used Chaining with Linked Lists."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Chaining with Linked Lists")),(0,i.kt)("p",null,"The hash table\u2019s array maps to a linked list of items. We just add the items to this linked list. As long as the number of collisions is fairly small, this will be quite efficient."),(0,i.kt)("p",null,"In the worst case, lookup is $O(n)$, where the $n$ is the number of elements in the Linked List."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Automatically increase and decrease in size")),(0,i.kt)("p",null,"Since internally, all ",(0,i.kt)("inlineCode",{parentName:"p"},"HashMap")," implementation uses ",(0,i.kt)("em",{parentName:"p"},"array to store the values"),". "),(0,i.kt)("p",null,"As we know array's can't be increase or decrease in size automatically, because once we initialize the array with a fixed size, the array is default to the size, until we re-assign the values with new array or re-initialize the array with the new size when program needs. "),(0,i.kt)("p",null,"But HashMap stores and operates thousands and millions of elements seamlessly with constant $O(1)$ time. As technically it's ",(0,i.kt)("inlineCode",{parentName:"p"},"amortized")," constant $O(1)$ time. "),(0,i.kt)("p",null,"What is amortized time?"),(0,i.kt)("p",null,"When the array in it has reached its capacity and need to re-create itself with the doubled size. The array has hit the capacity and we have no slots available. Then we need to create a brand new array with the doubled size. And then copy the items in the old one to the new one, which takes $O(n)$ where $n$ is the capacity of the old array and the worst case."),(0,i.kt)("p",null,"The implementation of HashMap increase / decrease in size happens in the below cases."),(0,i.kt)("p",null,"Initialize ListNode[] array with $16$, it's a default configuration used in languages. We can take other numbers as well, but it's a standard practise to initialize array capacity with $16$. "),(0,i.kt)("p",null,"The main reason for that, if the capacity is too low (less than $16$), we have to increase the size (grow our hashmap) immediately after few elements added to HashMap, this is not the best implementation. "),(0,i.kt)("p",null,"Here another important considerations is when to grow the table or double it's capacity? Since we cannot do that for every insert new element, so we it's better to keep some ranges like if the table reaches $50$% of capacity, or $75$% capacity or $90$%. As per language implementation is $75$%, so we follow the same here. "),(0,i.kt)("p",null,"The same goes for reduce or decrease HashMap when we remove elements. When the element size is reach $N/4$ capacity i.e, $25$%, we will reduce the capacity to half of the size. "),(0,i.kt)("p",null,"So HashMap Initial Capacity is set to $16$ and ",(0,i.kt)("inlineCode",{parentName:"p"},"Load Factor")," is set to $75$%, As soon as the size reaches $75$%, Hashmap does table doubling and shrink automatically to $50$% when it reaches elements of size $25$%."),(0,i.kt)("p",null,"Let's consider, $m$ is the actual size of the elements in the ListNode array, and $n$ is the threshold range for the bucket capacity, when $m > n$, HashMap allocating the memory for $2*N$ elements and ",(0,i.kt)("strong",{parentName:"p"},"rehasing the entire array for the newly allocated slots"),"."),(0,i.kt)("p",null,"If $n / 4$ size reached while removing elements, then Hashmap shrink it to $n / 2$ size."),(0,i.kt)("p",null,"The detailed explanation found in MIT 6006 lecture - ",(0,i.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=BRO7mVIFt08"},"https://www.youtube.com/watch?v=BRO7mVIFt08")),(0,i.kt)("br",null),(0,i.kt)(p,{mdxType:"Tabs"},(0,i.kt)(u,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)(c,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"class MyHashMap {\n    \n    // Initial capacity is set to 16\n    private static final int INITIAL_CAPACITY = 1 << 4;\n\n    // Maximum capcity is set to 65536\n    private static final int MAXIMUM_CAPACITY = 1 << 16;\n\n    // Load factor range is 75% for increase capacity\n    private static final float LOAD_FACTOR = 0.75f;\n\n    private ListNode[] arr;\n\n    private int capacity = INITIAL_CAPACITY;\n    \n    // Threshold range for initial capacity (16) is set to 12. \n    // When the Hashmap is reaches size of 12, it doubles it size and rehashes the elements\n    private int threshold = (int) (INITIAL_CAPACITY * LOAD_FACTOR); // Default\n    \n    // Shrink threshold for initial is set to 0, it will change when the capacity is increased.\n    private int shrink_threshold = 0;\n    \n    // Size of the linked list\n    private int size = 0;\n\n    public MyHashMap() {\n        arr = new ListNode[INITIAL_CAPACITY];\n    }\n\n    /* Value will always be non-negative */\n    public void put(int key, int value) {\n        // Get hashcode for the key and operate on the array\n        int _key = hash(key);\n        ListNode node = arr[_key];\n        // If the hashcode is already found in the array\n        // Then add the current element in the linked list chain\n        if (node != null) {\n            node.add(key, value);\n        } else {\n            node = new ListNode(key, value);\n            arr[_key] = node;\n        }\n        // Threshold Range for Table doubling\n        if (++size > threshold) {\n            grow();\n        }\n    }\n\n    /* Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */\n    public int get(int key) {\n        int _key = hash(key);\n        ListNode node = arr[_key];\n        // Based on the hashcode for the given key, check the elements in the linked list chain\n        Node item;\n        if (node == null || (item = node.find(key)) == null) {\n            return -1;\n        }\n        return item.val;\n    }\n\n    /* Remove the mapping of the specified value of key */\n    public void remove(int key) {\n        int _key = hash(key);\n        ListNode node = arr[_key];\n        if (node == null) return;\n        // Remove key from the linked list chain\n        node.remove(key);\n        // If head is null, then remove that item from array\n        if (node.head == null) {\n            arr[_key] = null;\n        }\n        // Shrink Threshold Range for Table half reducing\n        if (--size < shrink_threshold) {\n            shrink();\n        }\n    }\n\n    /* Stored elements size */\n    public int size() {\n        return size;\n    }\n\n    /* Simple HashCode function */\n    private int hash(int key) {\n        return key % capacity;\n    }\n\n    /* Table doubling or Hashmap increase it's capacity function */\n    private void grow() {\n        // Bit shifting << 1, since it's all capacity is power of 2, shifting 1 to left, doubled it's size.\n        if ((capacity <<= 1) >= MAXIMUM_CAPACITY) {\n            capacity = MAXIMUM_CAPACITY;\n        }\n        ListNode[] oldArr = arr;\n        // Initialized new array capacity with doubled it size\n        ListNode[] newArr = new ListNode[capacity];\n        int count = 0;\n        for (int i = 0; i < oldArr.length; i++) {\n            ListNode node = oldArr[i];\n            /**\n             * Only check if the element is Not null,\n             *  few of remove operation causes remove the element from the array, if the HEAD is null\n             */\n            if (node != null) {\n                // Elements formed in Linked list so using HEAD we can traverse through the elements. \n                Node current = node.head;\n                while (current != null) {\n                    // Re-hashes the existing key for the allocated size\n                    int _key = hash(current.key);\n                    node = newArr[_key]; // New Key check\n                    if (node != null) {\n                        node.add(current.key, current.val);\n                    } else {\n                        node = new ListNode(current.key, current.val);\n                        newArr[_key] = node;\n                    }\n                    current = current.next;\n                }\n                count += 1;\n            }\n        }\n        // Update next threshold\n        threshold = (int) (capacity * LOAD_FACTOR);\n        arr = newArr;\n        size = count; // Actual size\n    }\n\n    /* Table reducing to half, is same as table grow function */\n    private void shrink() {\n        // Bit shifting to right >> 1, reduce half the size for the current capacity\n        if ((capacity >>= 1) <= INITIAL_CAPACITY) {\n            capacity = INITIAL_CAPACITY;\n        }\n        ListNode[] oldArr = arr;\n        ListNode[] newArr = new ListNode[capacity];\n        int count = 0;\n        for (int i = 0; i < oldArr.length; i++) {\n            ListNode node = oldArr[i];\n            if (node != null) {\n                Node current = node.head;\n                while (current != null) {\n                    int _key = hash(current.key);\n                    node = newArr[_key]; // New Key check\n                    if (node != null) {\n                        node.add(current.key, current.val);\n                    } else {\n                        node = new ListNode(current.key, current.val);\n                        newArr[_key] = node;\n                    }\n                    current = current.next;\n                }\n                count += 1;\n            }\n        }\n        // Update next shrink threshold\n        if (capacity == INITIAL_CAPACITY) {\n            shrink_threshold = 0;\n        } else {\n            shrink_threshold = (int) ((capacity >> 1) * LOAD_FACTOR);\n        }\n        arr = newArr;\n        size = count;\n    }\n\n    /* Simple Node class to store the key and value, pointer to the next node */\n    private class Node {\n        int key, val;\n        Node next;\n\n        public Node(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public Node(int key, int val, Node next) {\n            this(key, val);\n            this.next = next;\n        }\n    }\n\n    /**\n     * Linked List Head and Tail node reference for faster adds and remove elements.\n     * \n     * Head and Tail becomes easy to handle operations for add, remove elements\n     */\n    private class ListNode {\n        private Node head;\n        private Node tail;\n\n        private int size = 0;\n\n        private ListNode(int key, int val) {\n            head = new Node(key, val);\n            tail = head;\n            size += 1;\n        }\n\n        /**\n         * Standard linked list operations for Add and update\n         */\n        private void add(int key, int val) {\n            boolean updateNode = update(key, val);\n            if (!updateNode) {\n                Node node = new Node(key, val);\n                if (head == tail) {\n                    head.next = node; // 2nd Node\n                } else {\n                    tail.next = node;\n                }\n                tail = node;\n            }\n            size += updateNode ? 0 : 1;\n        }\n\n        private boolean update(int key, int val) {\n            Node node = find(key);\n            if (node != null) {\n                node.val = val;\n                return true;\n            }\n            return false;\n        }\n\n        private Node find(int key) {\n            if (head == null) return null;\n            Node current = head;\n            while (current != null && current.key != key) {\n                current = current.next;\n            }\n            return current;\n        }\n\n        /* Changing the linked list node pointers when removing the element */\n        private void remove(int key) {\n            if (head == null) return;\n            if (head.key == key) {\n                if (head == tail) {\n                    head = null; tail = null;\n                } else {\n                    head = head.next;\n                }\n            } else {\n                Node current = head, prev = null;\n                while (current != null && current.key != key) {\n                    prev = current;\n                    current = current.next;\n                }\n                if (prev.next == null) return;\n                prev.next = prev.next.next;\n                // Last Node\n                if (prev.next == null) {\n                    if (tail.key == key) {\n                        tail = prev;\n                    } else {\n                        tail = head;\n                    }\n                }\n            }\n            size -= 1;\n        }\n    }\n}\n\n")))))}y.isMDXComponent=!0}}]);