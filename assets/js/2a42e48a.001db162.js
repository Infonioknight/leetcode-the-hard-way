"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[99366],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>m});var o=r(67294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,o)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,o,n=function(e,t){if(null==e)return{};var r,o,n={},a=Object.keys(e);for(o=0;o<a.length;o++)r=a[o],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)r=a[o],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var s=o.createContext({}),d=function(e){var t=o.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},c=function(e){var t=d(e.components);return o.createElement(s.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},p=o.forwardRef((function(e,t){var r=e.components,n=e.mdxType,a=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=d(r),p=n,m=u["".concat(s,".").concat(p)]||u[p]||h[p]||a;return r?o.createElement(m,i(i({ref:t},c),{},{components:r})):o.createElement(m,i({ref:t},c))}));function m(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var a=r.length,i=new Array(a);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:n,i[1]=l;for(var d=2;d<a;d++)i[d]=r[d];return o.createElement.apply(null,i)}return o.createElement.apply(null,r)}p.displayName="MDXCreateElement"},46765:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>f,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var o=r(87462),n=(r(67294),r(3905));const a={description:"Author: @ColeB2 | https://leetcode.com/problems/word-search-ii/",tags:["Array","String","Backtracking","Trie","Matrix"]},i="0212 - Word Search II (Hard)",l={unversionedId:"0200-0299/word-search-ii-hard",id:"0200-0299/word-search-ii-hard",title:"0212 - Word Search II (Hard)",description:"Author: @ColeB2 | https://leetcode.com/problems/word-search-ii/",source:"@site/solutions/0200-0299/0212-word-search-ii-hard.md",sourceDirName:"0200-0299",slug:"/0200-0299/word-search-ii-hard",permalink:"/solutions/0200-0299/word-search-ii-hard",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0200-0299/0212-word-search-ii-hard.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"String",permalink:"/solutions/tags/string"},{label:"Backtracking",permalink:"/solutions/tags/backtracking"},{label:"Trie",permalink:"/solutions/tags/trie"},{label:"Matrix",permalink:"/solutions/tags/matrix"}],version:"current",sidebarPosition:212,frontMatter:{description:"Author: @ColeB2 | https://leetcode.com/problems/word-search-ii/",tags:["Array","String","Backtracking","Trie","Matrix"]},sidebar:"tutorialSidebar",previous:{title:"0211 - Design Add and Search Words Data Structure (Medium)",permalink:"/solutions/0200-0299/design-add-and-search-words-data-structure-medium"},next:{title:"0213 - House Robber II (Medium)",permalink:"/solutions/0200-0299/house-robber-ii-medium"}},s={},d=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Iterative DFS using a Trie",id:"approach-1-iterative-dfs-using-a-trie",level:2}],c=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,n.kt)("div",t)},u=c("Tabs"),h=c("TabItem"),p=c("SolutionAuthor"),m={toc:d},w="wrapper";function f(e){let{components:t,...r}=e;return(0,n.kt)(w,(0,o.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"0212---word-search-ii-hard"},"0212 - Word Search II (Hard)"),(0,n.kt)("h2",{id:"problem-link"},"Problem Link"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/word-search-ii/"},"https://leetcode.com/problems/word-search-ii/")),(0,n.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,n.kt)("p",null,"Given an ",(0,n.kt)("inlineCode",{parentName:"p"},"m x n")," ",(0,n.kt)("inlineCode",{parentName:"p"},"board")," of characters and a list of strings ",(0,n.kt)("inlineCode",{parentName:"p"},"words"),", return ",(0,n.kt)("em",{parentName:"p"},"all words on the board"),"."),(0,n.kt)("p",null,"Each word must be constructed from letters of sequentially adjacent cells, where ",(0,n.kt)("strong",{parentName:"p"},"adjacent cells")," are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Example 1:")),(0,n.kt)("p",null,(0,n.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2020/11/07/search1.jpg",alt:null})),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},'Input: board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]\nOutput: ["eat","oath"]\n')),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Example 2:")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},'Input: board = [["a","b"],["c","d"]], words = ["abcb"]\nOutput: []\n')),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"Constraints:")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"m == board.length")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"n == board[i].length")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"1 <= m, n <= 12")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"board[i][j]")," is a lowercase English letter."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"1 <= words.length <= 3 * 10^4")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"1 <= words[i].length <= 10")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"words[i]")," consists of lowercase English letters."),(0,n.kt)("li",{parentName:"ul"},"All the strings of ",(0,n.kt)("inlineCode",{parentName:"li"},"words")," are unique.")),(0,n.kt)("h2",{id:"approach-1-iterative-dfs-using-a-trie"},"Approach 1: Iterative DFS using a Trie"),(0,n.kt)("p",null,"If you solved Word Search I, you know we can run a DFS on each cell of the matrix, checking that the cell location is inbounds, the cell letter matches the letter in the word we are looking at, and that we haven't already visited the cell in the current DFS. "),(0,n.kt)("p",null,"Repeating the above, but for each word, would be way too costly though, so we can use a Trie instead of a list of words. A Trie would give us access to the first letter of all the words so for each cell in the matrix we can check if it is worthwhile to run DFS in $$O(1)$$ time. Then if the letter is in our Trie, we can run our DFS. Still costly, but using a trie prevents us from having to run our algorithm for each word."),(0,n.kt)("p",null,"This also will be costly, as you can imagine if we find our word, every time we run across the first letter of that word, we are going to run our DFS again even if we don't need to. So we can add a counter of characters to our Trie, and a remove word method, so that we can decrement the number of times a character appears in our Trie, and then during the check to see if we should run DFS, check that our counter hasn't reached 0."),(0,n.kt)("p",null,"Note we use a counter instead of removing the letters, as if we had to words, $$bat$$ and $$ball$$, removing one of them, would remove the b, and therefore the whole word from our trie."),(0,n.kt)("p",null,"Time Complexity: $$m",(0,n.kt)("em",{parentName:"p"},"n"),"4^L$$. Where $$m$$ is the number of rows, $$n$$ is the number of columns, and $$L$$ is the max length of the longest word. We have to loop through each cell in the matrix ($$mn$$), and then when we match the first letter of one of our words, we have to run our DFS, which can take 4 directions at each turn, and can run as long as the longest word in our Trie."),(0,n.kt)("p",null,"Space Complexity: $$N+mn+L$$. Where $$N$$ is the size of our Trie, $$mn$$ is length of our stack to hold each cell since we are doing it iteratively, our stack will contain each node in it at the start, and $$L$$ is the length of our current DFS route, which can run as long as the longest word in our Trie."),(0,n.kt)(u,{mdxType:"Tabs"},(0,n.kt)(h,{value:"python",label:"Python",mdxType:"TabItem"},(0,n.kt)(p,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-py"},"class TrieNode:\n    # Create our trie,\n    # nodes to track the next level of nodes in our trie\n    # is_word denotes whether the at the current node, we created a word\n    # num is the counter for number of time the current node has been\n    # use in our trie. Ex: bat, ball -> b node will have num count of 2.\n    def __init__(self):\n        self.nodes = {}\n        self.is_word = False\n        self.num = 0\n\n    def addWord(self, word):\n        # Time: O(L) L is length of word.\n        # current node, starts as self.\n        node = self\n        # increase the count of the node.\n        node.num += 1\n        # loop throuhg characters in word\n        for ch in word:\n            if ch not in node.nodes:\n                # create the node and set key to be character.\n                node.nodes[ch] = TrieNode()\n            # move our current node pointer\n            node = node.nodes[ch]\n            # increment the counter on the node we moved to.\n            node.num += 1\n        # reached end, update is_word boolean.\n        node.is_word = True\n\n    def removeWord(self, word):\n        # Time: O(l) L is the length of the word\n        # remove word, decrements the node counters.\n        # don't remove nodes, as nodes may be shared by multiple words\n        # We could remove nodes if the .num counter every reached 0.\n        # current node pointer, starts as self.\n        # Both options could remove the mn from our space complexity.\n        node = self\n        # decrement count of the node\n        node.num -= 1\n        # loop through all the letters in word we are removing\n        for ch in word:\n            # make sure it is in our Trie\n            if ch in node.nodes:\n                # update our node to the node of character we\n                # are looking at\n                node = node.nodes[ch]\n                # decrement the nodes count.\n                node.num -= 1\n\nclass Solution:\n    # Some Potential Improvements\n    # Recursive DFS --\x3e Call stack wouldn't initialize with all\n    # values of our matrix inside our stack to start.\n    # Iterative DFS with DFS function: We wouldn't have to initialize\n    # a stack with all cells of the matrix, we could just call the\n    # DFS and save a bit of space.\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        # track our Trie root.\n        root = TrieNode()\n        # loop through all our words\n        for word in words:\n            # add the words to our Trie\n            root.addWord(word)\n        # get length of our rows and columns\n        ROWS, COLS = len(board), len(board[0])\n        # create a list of words. Note since we are removing words\n        # from our Trie, we don't need a set to prevent repeats.\n        words_made = []\n        # stack to perform iterative DFS\n        stack = []\n        # loop through the matrix, O(mn) to loop through each cell.\n        for r in range(ROWS):\n            for c in range(COLS):\n                # add the cells to the stack\n                # r,c to denote position in matrix\n                # pass root as our current node position in Trie\n                # \"\" empty string value to track word we at creating\n                # empty set to denote if we have visited the cell or not.\n                stack.append((r,c,root,\"\", set()))\n        # while our stack has values\n        while stack:\n            # pop row, col position\n            # node to denote current node\n            # word we are creating\n            # set to track if we have visited a node before\n            row, col, node, word, visit = stack.pop()\n            # Check if we are out of  bounds\n            # board[row][col] -> ch is NOT in our Trie\n            # Count of that Character is < 1 -> Word removed previously\n            if (row < 0 or col < 0\n                or row == ROWS or col == COLS\n                or board[row][col] not in node.nodes\n                or node.nodes[board[row][col]].num < 1\n                or (row,col) in visit):\n                # if any of above is True, no need to run DFS, continue\n                continue\n            # Passed above condition, we can run DFS on node.\n            # add to our set that we visited the cell\n            visit.add((row,col))\n            # move our current node to proper node in True.\n            node = node.nodes[board[row][col]]\n            # add the character of cell to the word.\n            word += board[row][col]\n            # If current node is_word, we found a word!\n            if node.is_word:\n                # Remove word from Trie\n                node.is_word = False\n                root.removeWord(word)\n                # add word to our return list\n                words_made.append(word)\n                \n            # Check 4 adjacent directions to add those cells to our\n            # stack for iterative DFS.\n            for x,y in ((1,0), (0,1), (-1,0), (0,-1)):\n                # Note we need a copy of visit for iterative DFS\n                # as if we just passed visit, it would be a reference\n                # and would be updated by all 4 directions during the\n                # DFS, so each direction needs it's own copy.\n                stack.append((row + x, col + y, node, word, visit.copy()))\n        # return list of words we found during our search\n        return words_made\n")))))}f.isMDXComponent=!0}}]);