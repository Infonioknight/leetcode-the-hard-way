"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[88074],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>c});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var m=r.createContext({}),s=function(e){var t=r.useContext(m),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},d=function(e){var t=s(e.components);return r.createElement(m.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,m=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=s(n),h=i,c=p["".concat(m,".").concat(h)]||p[h]||u[h]||o;return n?r.createElement(c,a(a({ref:t},d),{},{components:n})):r.createElement(c,a({ref:t},d))}));function c(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=h;var l={};for(var m in t)hasOwnProperty.call(t,m)&&(l[m]=t[m]);l.originalType=e,l[p]="string"==typeof e?e:i,a[1]=l;for(var s=2;s<o;s++)a[s]=n[s];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},77224:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>a,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var r=n(87462),i=(n(67294),n(3905));const o={description:"Author: @wingkwong | https://leetcode.com/problems/maximum-width-of-binary-tree/"},a="0662 - Maximum Width of Binary Tree (Medium)",l={unversionedId:"0600-0699/maximum-width-of-binary-tree-medium",id:"0600-0699/maximum-width-of-binary-tree-medium",title:"0662 - Maximum Width of Binary Tree (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/maximum-width-of-binary-tree/",source:"@site/solutions/0600-0699/0662-maximum-width-of-binary-tree-medium.md",sourceDirName:"0600-0699",slug:"/0600-0699/maximum-width-of-binary-tree-medium",permalink:"/solutions/0600-0699/maximum-width-of-binary-tree-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0600-0699/0662-maximum-width-of-binary-tree-medium.md",tags:[],version:"current",sidebarPosition:662,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/maximum-width-of-binary-tree/"},sidebar:"tutorialSidebar",previous:{title:"0653 - Two Sum IV - Input is a BST (Easy)",permalink:"/solutions/0600-0699/two-sum-IV-input-is-a-BST-easy"},next:{title:"0678 - Valid Parenthesis String (Medium)",permalink:"/solutions/0600-0699/valid-parenthesis-string-medium"}},m={},s=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: BFS",id:"approach-1-bfs",level:2}],d=(p="SolutionAuthor",function(e){return console.warn("Component "+p+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",e)});var p;const u={toc:s},h="wrapper";function c(e){let{components:t,...n}=e;return(0,i.kt)(h,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"0662---maximum-width-of-binary-tree-medium"},"0662 - Maximum Width of Binary Tree (Medium)"),(0,i.kt)("h2",{id:"problem-link"},"Problem Link"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/maximum-width-of-binary-tree/"},"https://leetcode.com/problems/maximum-width-of-binary-tree/")),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"Given the ",(0,i.kt)("inlineCode",{parentName:"p"},"root")," of a binary tree, return ",(0,i.kt)("em",{parentName:"p"},"the ",(0,i.kt)("strong",{parentName:"em"},"maximum width")," of the given tree"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("strong",{parentName:"p"},"maximum width")," of a tree is the maximum ",(0,i.kt)("strong",{parentName:"p"},"width")," among all levels."),(0,i.kt)("p",null,"The ",(0,i.kt)("strong",{parentName:"p"},"width")," of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes are also counted into the length calculation."),(0,i.kt)("p",null,"It is ",(0,i.kt)("strong",{parentName:"p"},"guaranteed")," that the answer will in the range of ",(0,i.kt)("strong",{parentName:"p"},"32-bit")," signed integer."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2021/05/03/width1-tree.jpg",alt:null})),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: root = [1,3,2,5,3,null,9]\nOutput: 4\nExplanation: The maximum width existing in the third level with the length 4 (5,3,null,9).\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2021/05/03/width2-tree.jpg",alt:null})),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: root = [1,3,null,5,3]\nOutput: 2\nExplanation: The maximum width existing in the third level with the length 2 (5,3).\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 3:")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://assets.leetcode.com/uploads/2021/05/03/width3-tree.jpg",alt:null})),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: root = [1,3,2,5]\nOutput: 2\nExplanation: The maximum width existing in the second level with the length 2 (3,2).\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The number of nodes in the tree is in the range ",(0,i.kt)("inlineCode",{parentName:"li"},"[1, 3000]"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-100 <= Node.val <= 100"))),(0,i.kt)("h2",{id:"approach-1-bfs"},"Approach 1: BFS"),(0,i.kt)("p",null,"We want to traverse each node level by level to calculate the width between the leftmost and the rightmost non-null nodes on the same level. We can use queue to perform BFS."),(0,i.kt)("p",null,"First we initialise a queue with a pair of tuple $$(node, idx)$$. Then we append the root with idx $$0$$ at the beginning. How do we assign $$idx$$ for other nodes? Given a full binary tree, we can easily see a pattern here. If a node with idx $$i$$ has the left node, the its idx would be $$2 ",(0,i.kt)("em",{parentName:"p"}," i$$. If a node with idx $$i$$ has the right node, the its idx would be $$2 ")," i + 1$$. "),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://leetcode.com/problems/maximum-width-of-binary-tree/Figures/662/662_bfs_traversal.png",alt:"BFS traversal"})),(0,i.kt)("p",null,"For each level, we calculate the width between the leftmost and rightmost nodes, which are the first element $$l$$ in the queue and the last element $$r$$ in the queue respectively, and check if it could be maximum value. The width between those two nodes is simply $$r",(0,i.kt)("em",{parentName:"p"},"{idx} - l"),"{idx} + 1$$. For example, on the last level, the width between the leftmost node and the rightmost node would be $$7 - 4 + 1 = 4$$."),(0,i.kt)("p",null,"For each element in the queue, we check if it has the left node or the right node. If so, we add it to the queue for further processing. We return the answer after we process all the nodes."),(0,i.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    using ll = long long;\n    int widthOfBinaryTree(TreeNode* root) {\n        int ans = 0;\n        queue<pair<TreeNode*, int>> d; // <node, idx>\n        // push the first element with idx = 0\n        d.push({root, 0});\n        // BFS\n        while (!d.empty()) {\n            // l_idx is the idx of the leftmost node\n            // r_idx is the idx of the rightmost node\n            ll l_idx = d.front().second, r_idx = d.back().second;\n            // define n here outside as d.size() may be changed\n            int n = (int) d.size();\n            // iterate each tuple\n            for (int i = 0; i < n; i++) {\n                // get one tuple and pop it\n                auto x = d.front(); d.pop();\n                // get the idx of the current node\n                auto idx = x.second ;\n                // if it has the left node, push it for the next level\n                // with idx = 2 * cur_idx\n                if (x.first->left)  d.push({x.first->left, (ll) 2 * idx});\n                // if it has the right node, push it for the next level\n                // with idx = 2 * cur_idx + 1\n                if (x.first->right) d.push({x.first->right, (ll) 2 * idx + 1});\n            }\n            // check if the current level got the max width\n            ans = max(ans, int(r_idx - l_idx + 1));\n        }\n        return ans;\n    }\n};\n")))}c.isMDXComponent=!0}}]);