"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[4748],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),p=u(n),d=r,h=p["".concat(s,".").concat(d)]||p[d]||c[d]||o;return n?a.createElement(h,i(i({ref:t},m),{},{components:n})):a.createElement(h,i({ref:t},m))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:r,i[1]=l;for(var u=2;u<o;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},29358:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>f,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var a=n(87462),r=(n(67294),n(3905));const o={description:"Author: @ColeB2 | https://leetcode.com/problems/partition-equal-subset-sum/",tags:["Array","Dynamic Programming"]},i="0416 - Partition Equal Subset Sum (Medium)",l={unversionedId:"0400-0499/partition-equal-subset-sum-medium",id:"0400-0499/partition-equal-subset-sum-medium",title:"0416 - Partition Equal Subset Sum (Medium)",description:"Author: @ColeB2 | https://leetcode.com/problems/partition-equal-subset-sum/",source:"@site/solutions/0400-0499/0416-partition-equal-subset-sum-medium.md",sourceDirName:"0400-0499",slug:"/0400-0499/partition-equal-subset-sum-medium",permalink:"/solutions/0400-0499/partition-equal-subset-sum-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0400-0499/0416-partition-equal-subset-sum-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Dynamic Programming",permalink:"/solutions/tags/dynamic-programming"}],version:"current",sidebarPosition:416,frontMatter:{description:"Author: @ColeB2 | https://leetcode.com/problems/partition-equal-subset-sum/",tags:["Array","Dynamic Programming"]},sidebar:"tutorialSidebar",previous:{title:"0413 - Arithmetic Slices (Medium)",permalink:"/solutions/0400-0499/arithmetic-slices-medium"},next:{title:"0417 - Pacific Atlantic Water Flow (Medium)",permalink:"/solutions/0400-0499/pacific-atlantic-water-flow-medium"}},s={},u=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Dynamic Programming",id:"approach-1-dynamic-programming",level:2}],m=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",t)},p=m("Tabs"),c=m("TabItem"),d=m("SolutionAuthor"),h={toc:u},b="wrapper";function f(e){let{components:t,...n}=e;return(0,r.kt)(b,(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"0416---partition-equal-subset-sum-medium"},"0416 - Partition Equal Subset Sum (Medium)"),(0,r.kt)("h2",{id:"problem-link"},"Problem Link"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/partition-equal-subset-sum/"},"https://leetcode.com/problems/partition-equal-subset-sum/")),(0,r.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.kt)("p",null,"Given an integer array ",(0,r.kt)("inlineCode",{parentName:"p"},"nums"),", return ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," ",(0,r.kt)("em",{parentName:"p"},"if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or")," ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," ",(0,r.kt)("em",{parentName:"p"},"otherwise"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: nums = [1,5,11,5]\nOutput: true\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: nums = [1,2,3,5]\nOutput: false\nExplanation: The array cannot be partitioned into equal sum subsets.\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Constraints:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"1 <= nums.length <= 200")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"1 <= nums[i] <= 100"))),(0,r.kt)("h2",{id:"approach-1-dynamic-programming"},"Approach 1: Dynamic Programming"),(0,r.kt)("p",null,"We can use dynamic programming and a hash set to solve this problem. Our hash set would represent all the totals we can make using the numbers in $$nums$$, and our base case would be $$0$$. We also only have to reach a total of the $$sum(nums) // 2$$ as if one half is half the sum, then the other will be too. This also means we can terminate early if the sum of all numbers isn't even."),(0,r.kt)("p",null,"Then we can iterate through each number in $$nums$$, and for each iteration, iterate through our hash set of totals. If the current $$total$$ + the current $$number$$ is equal to our target we can return true, otherwise, we will have to add our $$total + num$$ to our hash set.\nNote we can loop through our hash set and add numbers to it, so we will need an intermediate hash set to add our $$total + num$$ and $$total$$ to, as well as reassign later."),(0,r.kt)("p",null,"If we don't find our target total, we can return False."),(0,r.kt)("p",null,"Time Complexity: $$O(n * S)$$ where $$n$$ is the length of $$nums$$ array and $$S$$ is the sum of all elements in the array."),(0,r.kt)("p",null,"Space Complexity: $$O(S)$$ where $$S$$ is the sum of all elements in the array as we only need to store up to $$S$$ numbers in our hash set."),(0,r.kt)(p,{mdxType:"Tabs"},(0,r.kt)(c,{value:"python",label:"Python",mdxType:"TabItem"},(0,r.kt)(d,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        # calcuate target k\n        k = sum(nums)\n        # k isn't even, we can't partition the array\n        if k % 2:\n            return False\n        # update our target to be half of k, as if we find half\n        # the total then the remaining would be the other half.\n        k //= 2\n        # initialize our set with a starting total of 0.\n        dp = set()\n        dp.add(0)\n        # loop through each number in nums\n        for num in nums:\n            # initialize intermediate set, so we can loop through original.\n            new_dp = set()\n            # loop through all the totals in the original dp set.\n            for total in dp:\n                # if any total + number == k, we found our answer.\n                if (total + num) == k:\n                    return True\n                # add total + num, as well as original total to\n                # the intermediate set.\n                new_dp.add(total + num)\n                new_dp.add(total)\n            # reassign our set\n            dp = new_dp\n        # make it through and didn't find an answer return False.\n        return False\n")))))}f.isMDXComponent=!0}}]);