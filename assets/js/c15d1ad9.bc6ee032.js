"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[6514],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),s=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=s(e.components);return r.createElement(l.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=d(e,["components","mdxType","originalType","parentName"]),h=s(n),p=a,m=h["".concat(l,".").concat(p)]||h[p]||u[p]||o;return n?r.createElement(m,i(i({ref:t},c),{},{components:n})):r.createElement(m,i({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=p;var d={};for(var l in t)hasOwnProperty.call(t,l)&&(d[l]=t[l]);d.originalType=e,d[h]="string"==typeof e?e:a,i[1]=d;for(var s=2;s<o;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},58524:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>f,frontMatter:()=>o,metadata:()=>d,toc:()=>s});var r=n(87462),a=(n(67294),n(3905));const o={description:"Author: @ColeB2 | https://leetcode.com/problems/design-add-and-search-words-data-structure/",tags:["String","Depth-First Search","Design","Trie"]},i="0211 - Design Add and Search Words Data Structure (Medium)",d={unversionedId:"0200-0299/design-add-and-search-words-data-structure-medium",id:"0200-0299/design-add-and-search-words-data-structure-medium",title:"0211 - Design Add and Search Words Data Structure (Medium)",description:"Author: @ColeB2 | https://leetcode.com/problems/design-add-and-search-words-data-structure/",source:"@site/solutions/0200-0299/0211-design-add-and-search-words-data-structure-medium.md",sourceDirName:"0200-0299",slug:"/0200-0299/design-add-and-search-words-data-structure-medium",permalink:"/solutions/0200-0299/design-add-and-search-words-data-structure-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0200-0299/0211-design-add-and-search-words-data-structure-medium.md",tags:[{label:"String",permalink:"/solutions/tags/string"},{label:"Depth-First Search",permalink:"/solutions/tags/depth-first-search"},{label:"Design",permalink:"/solutions/tags/design"},{label:"Trie",permalink:"/solutions/tags/trie"}],version:"current",sidebarPosition:211,frontMatter:{description:"Author: @ColeB2 | https://leetcode.com/problems/design-add-and-search-words-data-structure/",tags:["String","Depth-First Search","Design","Trie"]},sidebar:"tutorialSidebar",previous:{title:"0210 - Course Schedule II (Medium)",permalink:"/solutions/0200-0299/course-schedule-ii-medium"},next:{title:"0212 - Word Search II (Hard)",permalink:"/solutions/0200-0299/word-search-ii-hard"}},l={},s=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Trie - Depth-First Search",id:"approach-1-trie---depth-first-search",level:2}],c=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",t)},h=c("Tabs"),u=c("TabItem"),p=c("SolutionAuthor"),m={toc:s},w="wrapper";function f(e){let{components:t,...n}=e;return(0,a.kt)(w,(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"0211---design-add-and-search-words-data-structure-medium"},"0211 - Design Add and Search Words Data Structure (Medium)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/design-add-and-search-words-data-structure/"},"https://leetcode.com/problems/design-add-and-search-words-data-structure/")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"Design a data structure that supports adding new words and finding if a string matches any previously added string."),(0,a.kt)("p",null,"Implement the ",(0,a.kt)("inlineCode",{parentName:"p"},"WordDictionary")," class:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"WordDictionary()")," Initializes the object."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"void addWord(word)")," Adds ",(0,a.kt)("inlineCode",{parentName:"li"},"word")," to the data structure, it can be matched later."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"bool search(word)")," Returns ",(0,a.kt)("inlineCode",{parentName:"li"},"true")," if there is any string in the data structure that matches ",(0,a.kt)("inlineCode",{parentName:"li"},"word")," or ",(0,a.kt)("inlineCode",{parentName:"li"},"false")," otherwise. ",(0,a.kt)("inlineCode",{parentName:"li"},"word")," may contain dots ",(0,a.kt)("inlineCode",{parentName:"li"},"'.'")," where dots can be matched with any letter.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Input\n["WordDictionary","addWord","addWord","addWord","search","search","search","search"]\n[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]\nOutput\n[null,null,null,null,false,true,true,true]\n\nExplanation\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord("bad");\nwordDictionary.addWord("dad");\nwordDictionary.addWord("mad");\nwordDictionary.search("pad"); // return False\nwordDictionary.search("bad"); // return True\nwordDictionary.search(".ad"); // return True\nwordDictionary.search("b.."); // return True\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= word.length <= 25")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"word")," in ",(0,a.kt)("inlineCode",{parentName:"li"},"addWord")," consists of lowercase English letters."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"word")," in ",(0,a.kt)("inlineCode",{parentName:"li"},"search")," consist of ",(0,a.kt)("inlineCode",{parentName:"li"},"'.'")," or lowercase English letters."),(0,a.kt)("li",{parentName:"ul"},"There will be at most ",(0,a.kt)("inlineCode",{parentName:"li"},"3")," dots in ",(0,a.kt)("inlineCode",{parentName:"li"},"word")," for ",(0,a.kt)("inlineCode",{parentName:"li"},"search")," queries."),(0,a.kt)("li",{parentName:"ul"},"At most ",(0,a.kt)("inlineCode",{parentName:"li"},"10^4")," calls will be made to ",(0,a.kt)("inlineCode",{parentName:"li"},"addWord")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"search"),".")),(0,a.kt)("h2",{id:"approach-1-trie---depth-first-search"},"Approach 1: Trie - Depth-First Search"),(0,a.kt)("p",null,"If you haven't heard of a ",(0,a.kt)("a",{parentName:"p",href:"https://leetcodethehardway.com/solutions/0200-0299/implement-trie-medium"},"trie"),", then this question will be extremely hard. But basically, a trie is a linked tree structure, which will have some way to denote which character you are currently looking at, and for each character in the trie, it will link to the next characters if they exist. So you can imagine a tree, but instead of numbers, we use letters, and each path from the root to the leaf will form a word."),(0,a.kt)("p",null,"The only adjustment we have to make is to the search method. Since we are introducing a wild card character, ",(0,a.kt)("inlineCode",{parentName:"p"},"'.'"),", it means instead of just following a singular path down the tree, at that level we will have to search every path, as the answer can be down any one of the paths."),(0,a.kt)("p",null,"This is where we can use depth-first search, meaning we will follow from the leaf, all the way down to the node, and if we found our word, we can return, otherwise, we must backtrack, using our stack/call stack, and continue on from the next character in the level."),(0,a.kt)("p",null,"Time Complexity: $$O(w * 26^n)$$, where $$w$$ is the length of the $$word$$ we are searching for, $$26$$ is the max number of characters for each level as we are using only lowercase English characters, and $$n$$ being the number of dots in the $$word$$."),(0,a.kt)("p",null,"You can imagine, if we have a full trie, with all levels having all 26 characters, and we search for a word of all dots, that in the worst case, we to process through each node in the trie, and each node can have 26 other nodes to follow."),(0,a.kt)("p",null,"Space Complexity $$O(26^n)$$ where $$n$$ is the number of dot characters. You can imagine how we will have the current level we are at inside our stack and the whole of the current path We know that the current path, each node can also have up to $$26$$ children nodes as well."),(0,a.kt)(h,{mdxType:"Tabs"},(0,a.kt)(u,{value:"python",label:"Python",mdxType:"TabItem"},(0,a.kt)(p,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"class TrieNode:\n    # Utilize a linked list DS --\x3e One where the next\n    # nodes can be reached via a hash map\n    # Contains a char as an optional parameter\n    # Also utilizes attributes of is_word to denote\n    # whether it is a word. \n    # Ex: If we have the word apple in our trie. a->p->p->l->e\n    # 'e' node will have is_word = True, to denote that\n    # apple is a word in our map. Letters, a,p,p,l,e won't be True\n    # as they are not complete words in our Trie.\n    def __init__(self, char=None) -> None:\n        # Char is the character the trie has. Default to None above,\n        # as the root node won't have a character associated with it.\n        self.char = char\n        # hash map of children nodes\n        self.nodes = {}\n        # boolean to denote whether the node we are at is the end of a word.\n        self.is_word = False\n\n\nclass WordDictionary:\n\n    def __init__(self):\n        # initialize our root node as a TrieNode with char = None\n        self.root = TrieNode()\n        # max_length variable to speed searching.\n        self.max_length = 0\n        \n\n    def addWord(self, word: str) -> None:\n        # Time: O(l) where l is the length of the word.\n        # a current node pointer to trace our linked list\n        node = self.root\n        # iterate through every character in the word, word.\n        for ch in word:\n            # current character is not in current TrieNode's\n            # hashmap of nodes -> create that node and add\n            # it to the hash map.\n            if ch not in node.nodes:\n                node.nodes[ch] = TrieNode(ch)\n            # move our current node pointer to the character\n            # we are looking at's node.\n            node = node.nodes[ch]\n        # When we reached the end set the is_word boolean to True.\n        node.is_word = True\n        # update max length to simplify searching.\n        self.max_length = max(self.max_length, len(word))\n        \n\n    def search(self, word: str) -> bool:\n        # Time WC: O(w * 26^n) where w is length of word, 26 being\n        # the max number of chararacters at each level in our trie, and\n        # n being the number of '.' characters in word.\n        # Space WC: O(26^n) for our DFS stack.\n        # Base Case: if word we search for > length of largest word,\n        # we know it doesn't exist, so we have no need to run our large\n        # algorithm\n        if len(word) > self.max_length:\n            return False\n        # initialize stack,\n        # tuple of values, 0 being the index of the first letter of 'word'\n        # root being the root node of our trie.\n        stack = [(0, self.root)]\n        # while we have values inside our stack\n        while stack:\n            # get the index of character we are looking at\n            # and get the node of current level we are on.\n            i, node = stack.pop()\n            # if i is > then length of word, we reach end.\n            if i >= len(word):\n                # if node we are looking at is a word return True\n                if node.is_word:\n                    return True\n                # else, node is not a word, continue our algorithm.\n                continue\n            # character we are looking at.\n            ch = word[i]\n            if ch == '.':\n                # loop through all nodes in current level\n                for key, val in node.nodes.items():\n                    # add them to the stack, increment the index\n                    # note items() return k,v pairs. key = character\n                    # and the value = TrieNode\n                    stack.append((i+1, val))\n            # ch isn't in current level. continue our algorithm\n            elif ch not in node.nodes:\n                continue\n            # We found character in node.nodes\n            else:\n                # add it to our stack: (i+1, TrieNode)\n                stack.append((i+1, node.nodes[ch]))\n        # Search our Trie and didn't find the word -> return False\n        return False\n")))))}f.isMDXComponent=!0}}]);