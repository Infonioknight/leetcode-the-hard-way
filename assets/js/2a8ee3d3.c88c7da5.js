"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[66156],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var o=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var m=o.createContext({}),p=function(e){var n=o.useContext(m),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=p(e.components);return o.createElement(m.Provider,{value:n},e.children)},c="mdxType",s={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,m=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(t),d=a,h=c["".concat(m,".").concat(d)]||c[d]||s[d]||r;return t?o.createElement(h,i(i({ref:n},u),{},{components:t})):o.createElement(h,i({ref:n},u))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,i=new Array(r);i[0]=d;var l={};for(var m in n)hasOwnProperty.call(n,m)&&(l[m]=n[m]);l.originalType=e,l[c]="string"==typeof e?e:a,i[1]=l;for(var p=2;p<r;p++)i[p]=t[p];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},4817:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>i,default:()=>f,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var o=t(87462),a=(t(67294),t(3905));const r={description:"Author: @wingkwong, @ColeB2, @radojicic23 | https://leetcode.com/problems/coin-change-2",tags:["Array","Dynamic Programming"]},i="0518 - Coin Change 2 (Medium)",l={unversionedId:"0500-0599/coin-change-2-medium",id:"0500-0599/coin-change-2-medium",title:"0518 - Coin Change 2 (Medium)",description:"Author: @wingkwong, @ColeB2, @radojicic23 | https://leetcode.com/problems/coin-change-2",source:"@site/solutions/0500-0599/0518-coin-change-2-medium.md",sourceDirName:"0500-0599",slug:"/0500-0599/coin-change-2-medium",permalink:"/solutions/0500-0599/coin-change-2-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0500-0599/0518-coin-change-2-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Dynamic Programming",permalink:"/solutions/tags/dynamic-programming"}],version:"current",sidebarPosition:518,frontMatter:{description:"Author: @wingkwong, @ColeB2, @radojicic23 | https://leetcode.com/problems/coin-change-2",tags:["Array","Dynamic Programming"]},sidebar:"tutorialSidebar",previous:{title:"0508 - Most Frequent Subtree Sum (Medium)",permalink:"/solutions/0500-0599/most-frequent-subtree-sum-medium"},next:{title:"0520 - Detect Capital (Easy)",permalink:"/solutions/0500-0599/detect-capital-easy"}},m={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Dynamic Programming",id:"approach-1-dynamic-programming",level:2}],u=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",n)},c=u("Tabs"),s=u("TabItem"),d=u("SolutionAuthor"),h={toc:p},g="wrapper";function f(e){let{components:n,...t}=e;return(0,a.kt)(g,(0,o.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"0518---coin-change-2-medium"},"0518 - Coin Change 2 (Medium)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/coin-change-2"},"https://leetcode.com/problems/coin-change-2")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"You are given an integer array ",(0,a.kt)("inlineCode",{parentName:"p"},"coins")," representing coins of different denominations and an integer ",(0,a.kt)("inlineCode",{parentName:"p"},"amount")," representing a total amount of money."),(0,a.kt)("p",null,"Return ",(0,a.kt)("em",{parentName:"p"},"the number of combinations that make up that amount"),". If that amount of money cannot be made up by any combination of the coins, return ",(0,a.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,a.kt)("p",null,"You may assume that you have an infinite number of each kind of coin."),(0,a.kt)("p",null,"The answer is ",(0,a.kt)("strong",{parentName:"p"},"guaranteed")," to fit into a signed ",(0,a.kt)("strong",{parentName:"p"},"32-bit")," integer."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 3:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: amount = 10, coins = [10]\nOutput: 1\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= coins.length <= 300")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= coins[i] <= 5000")),(0,a.kt)("li",{parentName:"ul"},"All the values of ",(0,a.kt)("inlineCode",{parentName:"li"},"coins")," are ",(0,a.kt)("strong",{parentName:"li"},"unique"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"0 <= amount <= 5000"))),(0,a.kt)("h2",{id:"approach-1-dynamic-programming"},"Approach 1: Dynamic Programming"),(0,a.kt)("p",null,"This problem is very similar to ",(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/combination-sum-iv/"},"0377 - Combination Sum IV (Medium)"),". The only difference is the order of loops. The reason is that ",(0,a.kt)("inlineCode",{parentName:"p"},"(1, 1, 2)")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"(2, 1, 1)")," are considered different in that problem."),(0,a.kt)("p",null,"We can derive the following transition if $target$ is greater or equal to $nums","[i]","$ where $dp","[i]","$ represents the number of combinations that sum up to the $target$."),(0,a.kt)("p",null,"$$\ndp(amount)=\\sum_{i=0}^n dp(amount - coins","[i]",")\n$$"),(0,a.kt)("p",null,"Time Complexity: $$O(amount * coins.length)$$. For each coin, we are going to loop through all the values from $$0$$ to $$amount$$."),(0,a.kt)("p",null,"Space Complexity: $$O(amount)$$. We are going to create an array of size $$amount$$."),(0,a.kt)(c,{mdxType:"Tabs"},(0,a.kt)(s,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        // let dp[i] be the number of combinations that make up to i\n        vector<uint> dp(amount + 1);\n        // base case\n        dp[0] = 1;\n        for(auto c : coins) {\n            for(int i = 1; i <= amount; i++) {\n                // since we need dp[i - c],\n                // we need to make sure i - c is greater or equal to 0\n                if(i >= c) {\n                    // add the previous result\n                    dp[i] += dp[i - c];\n                }\n            }\n        }\n        return dp.back();\n    }\n};\n"))),(0,a.kt)(s,{value:"python",label:"Python",mdxType:"TabItem"},(0,a.kt)(d,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        # initialize dp for all amounts from 0 to amount.\n        dp = [0] * (amount + 1)\n        # initialize base case for amount 0.\n        dp[0] = 1\n        # loop through all the coins\n        for coin in coins:\n            # loop through all the amounts, starting at coin. This\n            # prevents us from having to check if i >= coin.\n            for i in range(coin, amount + 1):\n                # the number of ways we can make each amount is based\n                # of the number of ways we can make the amount at each\n                # amount-coin\n                dp[i] += dp[i - coin]\n        # return final value, dp[-1] would also work.\n        return dp[amount]\n"))),(0,a.kt)(s,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,a.kt)(d,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"/**\n * @param {number} amount\n * @param {number[]} coins\n * @return {number}\n */\nvar change = function (amount, coins) {\n  let dp = new Array(amount + 1).fill(0);\n  dp[0] = 1;\n  for (let coin of coins) {\n    for (let i = coin; i < amount + 1; i++) {\n      dp[i] += dp[i - coin];\n    }\n  }\n  return dp[dp.length - 1];\n};\n")))))}f.isMDXComponent=!0}}]);