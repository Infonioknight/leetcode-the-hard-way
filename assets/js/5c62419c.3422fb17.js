"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[16604],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>h});var a=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),p=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(l.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(t),m=i,h=u["".concat(l,".").concat(m)]||u[m]||d[m]||r;return t?a.createElement(h,o(o({ref:n},c),{},{components:t})):a.createElement(h,o({ref:n},c))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[u]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},24673:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>k,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=t(87462),i=(t(67294),t(3905));const r={description:"Author: @wingkwong, @vigneshshiv | https://leetcode.com/problems/is-subsequence/"},o="0392 - Is Subsequence (Easy)",s={unversionedId:"0300-0399/is-subsequence-easy",id:"0300-0399/is-subsequence-easy",title:"0392 - Is Subsequence (Easy)",description:"Author: @wingkwong, @vigneshshiv | https://leetcode.com/problems/is-subsequence/",source:"@site/solutions/0300-0399/0392-is-subsequence-easy.md",sourceDirName:"0300-0399",slug:"/0300-0399/is-subsequence-easy",permalink:"/solutions/0300-0399/is-subsequence-easy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0300-0399/0392-is-subsequence-easy.md",tags:[],version:"current",sidebarPosition:392,frontMatter:{description:"Author: @wingkwong, @vigneshshiv | https://leetcode.com/problems/is-subsequence/"},sidebar:"tutorialSidebar",previous:{title:"0389 - Find the Difference (Easy)",permalink:"/solutions/0300-0399/find-the-difference-easy"},next:{title:"0393 - UTF-8 Validation (Medium)",permalink:"/solutions/0300-0399/utf-8-validation-medium"}},l={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Two Pointers",id:"approach-1-two-pointers",level:2},{value:"Approach 2: Edit Distance",id:"approach-2-edit-distance",level:2},{value:"Approach 3: Lower Bound of Indices",id:"approach-3-lower-bound-of-indices",level:2},{value:"Approach 4: LCS",id:"approach-4-lcs",level:2},{value:"Approach 5: Dynamic Programming with Memoization",id:"approach-5-dynamic-programming-with-memoization",level:2},{value:"Approach 6: Stack",id:"approach-6-stack",level:2},{value:"Approach 7: STL (indexOf)",id:"approach-7-stl-indexof",level:2}],c=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",n)},u=c("Tabs"),d=c("TabItem"),m=c("SolutionAuthor"),h={toc:p},b="wrapper";function k(e){let{components:n,...t}=e;return(0,i.kt)(b,(0,a.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"0392---is-subsequence-easy"},"0392 - Is Subsequence (Easy)"),(0,i.kt)("h2",{id:"problem-link"},"Problem Link"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/is-subsequence/"},"https://leetcode.com/problems/is-subsequence/")),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"Given two strings ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"t"),", return ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," ",(0,i.kt)("em",{parentName:"p"},"if")," ",(0,i.kt)("inlineCode",{parentName:"p"},"s")," ",(0,i.kt)("em",{parentName:"p"},"is a ",(0,i.kt)("strong",{parentName:"em"},"subsequence")," of")," ",(0,i.kt)("inlineCode",{parentName:"p"},"t"),(0,i.kt)("em",{parentName:"p"},", or")," ",(0,i.kt)("inlineCode",{parentName:"p"},"false")," ",(0,i.kt)("em",{parentName:"p"},"otherwise"),"."),(0,i.kt)("p",null,"A ",(0,i.kt)("strong",{parentName:"p"},"subsequence")," of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., ",(0,i.kt)("inlineCode",{parentName:"p"},'"ace"')," is a subsequence of ",(0,i.kt)("inlineCode",{parentName:"p"},'"abcde"')," while ",(0,i.kt)("inlineCode",{parentName:"p"},'"aec"')," is not)."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input: s = "abc", t = "ahbgdc"\nOutput: true\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input: s = "axc", t = "ahbgdc"\nOutput: false \n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0 <= s.length <= 100")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0 <= t.length <= 10^4")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"s")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"t")," consist only of lowercase English letters.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Follow up:")," Suppose there are lots of incoming ",(0,i.kt)("inlineCode",{parentName:"p"},"s"),", say ",(0,i.kt)("inlineCode",{parentName:"p"},"s1, s2, ..., sk")," where ",(0,i.kt)("inlineCode",{parentName:"p"},"k >= 10^9"),", and you want to check one by one to see if ",(0,i.kt)("inlineCode",{parentName:"p"},"t")," has its subsequence. In this scenario, how would you change your code?"),(0,i.kt)("h2",{id:"approach-1-two-pointers"},"Approach 1: Two Pointers"),(0,i.kt)("p",null,"We use two pointers $$i$$ and $$j$$ to track the index in $$s$$ and $$t$$ respectively. If $$s","[i]"," == t","[j]","$$, then we set $$i := i + 1$$ and $$j := j + 1$$ and then check the next character in both string. If they are not same, we move $$j$$ to the next character in $$t$$ while keeping $$i$$ in $$s$$. At the end, pointer $$i$$ would be $$n$$ if $$s$$ is a subsequence of $$t$$."),(0,i.kt)(u,{mdxType:"Tabs"},(0,i.kt)(d,{value:"c++",label:"C++",mdxType:"TabItem"},(0,i.kt)(m,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    bool isSubsequence(string s, string t) {\n        int n = s.size(), m = t.size(), i = 0, j = 0;\n        while (i < n && j < m) {\n            // moving pointer i only if they are same\n            if (s[i] == t[j]) i++;\n            // move j for both case\n            j++;\n        }\n        // s is a subsequence of t if i == n\n        return i == n;\n    }\n};\n"))),(0,i.kt)(d,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)(m,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public boolean isSubsequence(String s, String t) {\n        int i = 0, j = 0, m = s.length(), n = t.length();\n        while (i < m && j < n) {\n            if (s.charAt(i) == t.charAt(j)) {\n                i += 1;\n            }\n            j += 1;\n        }\n        return i == m;\n    }\n}\n")))),(0,i.kt)("h2",{id:"approach-2-edit-distance"},"Approach 2: Edit Distance"),(0,i.kt)("p",null,"We can directly use ",(0,i.kt)("a",{parentName:"p",href:"../0000-0099/edit-distance-hard"},"0072 - Edit Distance (Hard)")," solution to solve this easy problem since the constraints are not large. Edit distance here means the minimum number of operations required to covert $$s$$ to $$t$$. We just need to check if it is equal to $$m - n$$."),(0,i.kt)(u,{mdxType:"Tabs"},(0,i.kt)(d,{value:"c++",label:"C++",mdxType:"TabItem"},(0,i.kt)(m,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    // Check out 0072 - Edit Distance for detailed explanation\n    int minDistance(string word1, string word2) {\n        int m = (int) word1.size();\n        int n = (int) word2.size();\n        int dp[m + 1][n + 1];\n        memset(dp, 0, sizeof(dp));\n        for (int i = 1; i <= m; i++) dp[i][0] = i;\n        for (int j = 1; j <= n; j++) dp[0][j] = j;\n        for (int i = 1; i <= m; i++){\n            for(int j = 1; j <= n; j++){\n                if(word1[i - 1] == word2[j - 1]) { // a = b\n                    dp[i][j] = dp[i - 1][j - 1]; \n                } else {\n                    // find out the min cost for all three actions\n                    dp[i][j] = 1 + min({\n                        dp[i - 1][j - 1], // replace a with b\n                        dp[i - 1][j],     // delete a\n                        dp[i][j - 1]      // insert b after a\n                    });\n                }\n            }\n        }\n        return dp[m][n];\n    }\n    \n    bool isSubsequence(string s, string t) {\n        int n = s.size(), m = t.size();\n        return minDistance(s, t) == m - n;\n    }\n}\n")))),(0,i.kt)("h2",{id:"approach-3-lower-bound-of-indices"},"Approach 3: Lower Bound of Indices"),(0,i.kt)("p",null,"This approach is for follow-up. We can store the indices $$idx$$ of each character in $$t$$. For example, if $$t$$ is $$aaaabbcde$$, then we have the following $$idx$$."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Character (Key)"),(0,i.kt)("th",{parentName:"tr",align:null},"Indice (Value)"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"a"),(0,i.kt)("td",{parentName:"tr",align:null},"[","0, 1, 2, 3]")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"b"),(0,i.kt)("td",{parentName:"tr",align:null},"[","4, 5]")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"c"),(0,i.kt)("td",{parentName:"tr",align:null},"[","6]")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"d"),(0,i.kt)("td",{parentName:"tr",align:null},"[","7]")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"e"),(0,i.kt)("td",{parentName:"tr",align:null},"[","8]")))),(0,i.kt)("p",null,"Then we initialise $$bound$$ which is the starting index. For each character in $$s$$, we want to find the index $$j$$ which starts from $$bound$$. If it reaches the end, then return false. Else we can update $$bound := j + 1$$ because the next character cannot appear before the previous character and continue until we process all characters."),(0,i.kt)("p",null,"For example, let's say $$s = abc$$ and $$t = aaaabbcde$$. The first character is $$a$$ and we got $$bound = 0$$ and $$j = 0$$. Then we update the bound to $$j + 1$$. Then for the second character $$b$$, we got $$bound = 1$$ and $$j = 4$$. Similarly, we got $$bound = 5$$ and $$j = 6$$ for the last character."),(0,i.kt)(u,{mdxType:"Tabs"},(0,i.kt)(d,{value:"c++",label:"C++",mdxType:"TabItem"},(0,i.kt)(m,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    bool isSubsequence(string s, string t) {\n        int n = s.size(), m = t.size();\n        unordered_map<char, vector<int>> idx;\n        // put each char as key, the value is the indice of that char\n        for (int i = 0; i < m; i++) idx[t[i]].push_back(i);\n        int bound = 0;\n        for (auto x : s) {\n            // find the index which starts from bound\n            auto j = lower_bound(idx[x].begin(), idx[x].end(), bound);\n            // cannot find the index -> false\n            if (j == idx[x].end()) return false;\n            // update bound and try next character\n            bound = *j + 1;\n        }\n        return true;\n    }\n};\n"))),(0,i.kt)(d,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)(m,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    \n    /**\n     * Eg-1. s=\"abc\", t=\"bahbgdca\"\n     *  idx=[a={1,7}, b={0,3}, c={6}]\n     *  i=0 ('a'): prev=1\n     *  i=1 ('b'): prev=3\n     *  i=2 ('c'): prev=6 (return true)\n     *\n     * Eg-2. s=\"abc\", t=\"bahgdcb\"\n     *  idx=[a={1}, b={0,6}, c={5}]\n     *  i=0 ('a'): prev=1\n     *  i=1 ('b'): prev=6\n     *  i=2 ('c'): prev=-1 (return false)\n     */\n    public boolean isSubsequence(String s, String t) {\n        List<Integer>[] idx = new List[256];\n        // Pre-process of t\n        int i = 0;\n        for (char c : t.toCharArray()) {\n            if (idx[c] == null) {\n                idx[c] = new ArrayList<>();\n            }\n            idx[c].add(i++);\n        }\n        int prev = -1;\n        for (char c : s.toCharArray()) {\n            if (idx[c] == null) return false;\n            prev = binarySearch(idx[c], prev);\n            if (prev == -1) return false;\n        }\n        return true;\n    }\n    \n    private int binarySearch(List<Integer> list, int index) {\n        int start = 0, mid = 0, end = list.size() - 1;\n        while (start <= end) {\n            mid = start + (end - start) / 2;\n            if (index < list.get(mid)) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n        return start == list.size() ? -1 : list.get(start);\n    }\n}\n")))),(0,i.kt)("h2",{id:"approach-4-lcs"},"Approach 4: LCS"),(0,i.kt)("p",null,"If $$s$$ is a subsequence of $$t$$, then it means the Longest Common Subsequence (LCS) would be $$n$$. We can directly use ",(0,i.kt)("a",{parentName:"p",href:"../1100-1199/longest-common-subsequence-medium"},"1143 - Longest Common Subsequence (Medium)")," solution."),(0,i.kt)(u,{mdxType:"Tabs"},(0,i.kt)(d,{value:"c++",label:"C++",mdxType:"TabItem"},(0,i.kt)(m,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    // 1143 - Longest Common Subsequence (Medium)\n    int longestCommonSubsequence(string text1, string text2) {\n        int n = text1.size(), m = text2.size();\n        vector<vector<int>> dp(n + 1, vector<int>(m + 1));\n        for(int i = 1; i <= n; i++) {\n            for(int j = 1; j <= m; j++) {\n                if(text1[i - 1] == text2[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[n][m];\n    }\n    \n    bool isSubsequence(string s, string t) {\n        int n = s.size();\n        return longestCommonSubsequence(s, t) == n;\n    }\n};\n"))),(0,i.kt)(d,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)(m,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public boolean isSubsequence(String s, String t) {\n        int m = s.length(), n = t.length();\n        int[][] dp = new int[m][n];\n        Arrays.setAll(dp, r -> {\n            Arrays.fill(dp[r], -1);\n            return dp[r];\n        });\n        int length = lcs(s, t, m - 1, n - 1, dp);\n        return length == m;\n    }\n    \n    private int lcs(String s, String t, int i, int j, int[][] dp) {\n        if (i < 0 || j < 0) return 0;\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n        if (s.charAt(i) == t.charAt(j)) {\n            return dp[i][j] = 1 + lcs(s, t, i - 1, j - 1, dp);\n        }\n        return dp[i][j] = Math.max(lcs(s, t, i - 1, j, dp), lcs(s, t, i, j - 1, dp));\n    }\n}\n")))),(0,i.kt)("h2",{id:"approach-5-dynamic-programming-with-memoization"},"Approach 5: Dynamic Programming with Memoization"),(0,i.kt)("p",null,"We can apply the same recurrance relation which is used in DP Bottom-up with DP Recursive with memoization. "),(0,i.kt)(u,{mdxType:"Tabs"},(0,i.kt)(d,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)(m,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public boolean isSubsequence(String s, String t) {\n        int m = s.length(), n = t.length();\n        int[][] memo = new int[m][n];\n        int length = lcs(s, t, m - 1, n - 1, memo);\n        return length == m;\n    }\n    \n    private int lcs(String s, String t, int i, int j, int[][] memo) {\n        int result = 0;\n        if (i < 0 || j < 0) return result;\n        if (memo[i][j] > 0) return memo[i][j];\n        if (s.charAt(i) == t.charAt(j)) {\n            result = 1 + lcs(s, t, i - 1, j - 1, memo);\n        } else {\n            result = Math.max(lcs(s, t, i - 1, j, memo), lcs(s, t, i, j - 1, memo));\n        }\n        memo[i][j] = result;\n        return result;\n    }\n}\n")))),(0,i.kt)("h2",{id:"approach-6-stack"},"Approach 6: Stack"),(0,i.kt)("p",null,"Just a build a stack with S string in reversing order, and iterate over T string and pops out stack if Stack top and T characters are matching, once Stack becomes empty then we find the answer as true. "),(0,i.kt)(u,{mdxType:"Tabs"},(0,i.kt)(d,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)(m,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public boolean isSubsequence(String s, String t) {\n        Stack<Character> stack = new Stack<>();\n        for (int i = s.length() - 1; i >= 0; i--) {\n            stack.push(s.charAt(i));\n        }\n        for (char c : t.toCharArray()) {\n            if (stack.isEmpty()) return true;\n            if (c == stack.peek()) {\n                stack.pop();\n            }\n        }\n        return stack.isEmpty();\n    }\n}\n")))),(0,i.kt)("h2",{id:"approach-7-stl-indexof"},"Approach 7: STL (indexOf)"),(0,i.kt)("p",null,"String class provides, built-in method called ",(0,i.kt)("inlineCode",{parentName:"p"},"indexOf"),", just pass ",(0,i.kt)("strong",{parentName:"p"},"fromIndex")," argument to define the search space, and it keeps searching for a character from that position. This solution is optimal and efficient for smaller strings. "),(0,i.kt)(u,{mdxType:"Tabs"},(0,i.kt)(d,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)(m,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    public boolean isSubsequence(String s, String t) {\n        int idx = -1;\n        for (char c : s.toCharArray()) {\n            idx = t.indexOf(c, idx + 1);\n            if (idx == -1) return false;\n        }\n        return true;\n    }\n}\n")))))}k.isMDXComponent=!0}}]);