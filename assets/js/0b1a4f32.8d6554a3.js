"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[80329],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),p=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(n),m=a,h=u["".concat(s,".").concat(m)]||u[m]||c[m]||o;return n?r.createElement(h,i(i({ref:t},d),{},{components:n})):r.createElement(h,i({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},50353:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>k,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var r=n(87462),a=(n(67294),n(3905));const o={description:"Author: @ColeB2 | https://leetcode.com/problems/word-break/",tags:["Array","Hash Table","String","Dynamic Programming","Trie","Memoization"]},i="0139 - Word Break (Medium)",l={unversionedId:"0100-0199/word-break-medium",id:"0100-0199/word-break-medium",title:"0139 - Word Break (Medium)",description:"Author: @ColeB2 | https://leetcode.com/problems/word-break/",source:"@site/solutions/0100-0199/0139-word-break-medium.md",sourceDirName:"0100-0199",slug:"/0100-0199/word-break-medium",permalink:"/solutions/0100-0199/word-break-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0100-0199/0139-word-break-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Hash Table",permalink:"/solutions/tags/hash-table"},{label:"String",permalink:"/solutions/tags/string"},{label:"Dynamic Programming",permalink:"/solutions/tags/dynamic-programming"},{label:"Trie",permalink:"/solutions/tags/trie"},{label:"Memoization",permalink:"/solutions/tags/memoization"}],version:"current",sidebarPosition:139,frontMatter:{description:"Author: @ColeB2 | https://leetcode.com/problems/word-break/",tags:["Array","Hash Table","String","Dynamic Programming","Trie","Memoization"]},sidebar:"tutorialSidebar",previous:{title:"0138 - Copy List with Random Pointer (Medium)",permalink:"/solutions/0100-0199/copy-list-with-random-pointer-medium"},next:{title:"0141 - Linked List Cycle (Easy)",permalink:"/solutions/0100-0199/linked-list-cycle"}},s={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Dynamic Programming",id:"approach-1-dynamic-programming",level:2}],d=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",t)},u=d("Tabs"),c=d("TabItem"),m=d("SolutionAuthor"),h={toc:p},g="wrapper";function k(e){let{components:t,...n}=e;return(0,a.kt)(g,(0,r.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"0139---word-break-medium"},"0139 - Word Break (Medium)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/word-break/"},"https://leetcode.com/problems/word-break/")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"Given a string ",(0,a.kt)("inlineCode",{parentName:"p"},"s")," and a dictionary of strings ",(0,a.kt)("inlineCode",{parentName:"p"},"wordDict"),", return ",(0,a.kt)("inlineCode",{parentName:"p"},"true")," if ",(0,a.kt)("inlineCode",{parentName:"p"},"s")," can be segmented into a space-separated sequence of one or more dictionary words."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Note")," that the same word in the dictionary may be reused multiple times in the segmentation."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Input: s = "leetcode", wordDict = ["leet","code"]\nOutput: true\nExplanation: Return true because "leetcode" can be segmented as "leet code".\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Input: s = "applepenapple", wordDict = ["apple","pen"]\nOutput: true\nExplanation: Return true because "applepenapple" can be segmented as "apple pen apple".\nNote that you are allowed to reuse a dictionary word.\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 3:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'Input: s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]\nOutput: false\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= s.length <= 300")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= wordDict.length <= 1000")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= wordDict[i].length <= 20")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"s")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"wordDict[i]")," consist of only lowercase English letters."),(0,a.kt)("li",{parentName:"ul"},"All the strings of ",(0,a.kt)("inlineCode",{parentName:"li"},"wordDict")," are unique.")),(0,a.kt)("h2",{id:"approach-1-dynamic-programming"},"Approach 1: Dynamic Programming"),(0,a.kt)("p",null,"We can use a bottom-up dp approach. We can initialize a dp array of $$s.length + 1$$ of all false values except the first one as true. Then we can iterate through all $$end$$ positions of the string, and inside that loop, iterate through $$start$$ positions moving back towards the start. If the dp array at the $$start$$ position is set to true, we can check if the word from $$start$$ to $$end + 1$$ is in the dictionary, and if it is, we can update the dp array at $$end + 1$$ to be true."),(0,a.kt)("p",null,"This process allows us to look for words in the dictionary only if we need to find them. For example 1 for instance, if $$wordDict$$ only contained the word $$code$$, we would never actually have to search for the word $$code$$ as its corresponding starting position in the dp array would be false, saving us time on searching for words we don't need."),(0,a.kt)("p",null,"Time Complexity: $$O(n^2)$$, we must iterate over all possible end and start positions of the string, where n is the length of the string."),(0,a.kt)("p",null,"Space Complexity: $$O(n)$$, we must keep track of how far into the string we can get using true and false values in our dp array of size n, where n is the length of the string."),(0,a.kt)(u,{mdxType:"Tabs"},(0,a.kt)(c,{value:"python",label:"Python",mdxType:"TabItem"},(0,a.kt)(m,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        # convert wordDict to set for O(1) word access\n        word_set = set(wordDict)\n        # initialize dp array of all Falses\n        dp = [False] * (len(s) + 1)\n        # set first value True.\n        dp[0] = True\n        # loop through all possible end positions in the string, s\n        for end in range(len(s)):\n            # from the end position, look through all possible start\n            # positions for which we can make a word in the string.\n            for start in range(end, -1, -1):\n                # if dp[start] is True, meaning we found a word that\n                # reached that point in the string before, and the\n                # word we can create is in our wordDict above.\n                # Note python won't create the string s[start:end + 1]\n                # unless dp[start] is true.\n                if dp[start] and s[start: end + 1] in word_set:\n                    # set the value at end+1 to true, and break as we\n                    # know we found a word to cover this end point.\n                    dp[end + 1] = True\n                    break\n        # return the last value in the dp array.\n        return dp[-1]\n")))))}k.isMDXComponent=!0}}]);