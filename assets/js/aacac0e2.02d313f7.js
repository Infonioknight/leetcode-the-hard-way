"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[84715],{3905:function(e,n,t){t.d(n,{Zo:function(){return m},kt:function(){return d}});var r=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var p=r.createContext({}),l=function(e){var n=r.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},m=function(e){var n=l(e.components);return r.createElement(p.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},c=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,p=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=l(t),d=i,f=c["".concat(p,".").concat(d)]||c[d]||u[d]||o;return t?r.createElement(f,a(a({ref:n},m),{},{components:t})):r.createElement(f,a({ref:n},m))}));function d(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,a=new Array(o);a[0]=c;var s={};for(var p in n)hasOwnProperty.call(n,p)&&(s[p]=n[p]);s.originalType=e,s.mdxType="string"==typeof e?e:i,a[1]=s;for(var l=2;l<o;l++)a[l]=t[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},9615:function(e,n,t){t.r(n),t.d(n,{assets:function(){return m},contentTitle:function(){return p},default:function(){return h},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return u}});var r=t(87462),i=t(63366),o=(t(67294),t(3905)),a=["components"],s={description:"Author: @wingkwong | https://leetcode.com/problems/closest-prime-numbers-in-range/"},p="2523 - Closest Prime Numbers in Range (Medium)",l={unversionedId:"2500-2599/closest-prime-numbers-in-range-medium",id:"2500-2599/closest-prime-numbers-in-range-medium",title:"2523 - Closest Prime Numbers in Range (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/closest-prime-numbers-in-range/",source:"@site/solutions/2500-2599/2523-closest-prime-numbers-in-range-medium.md",sourceDirName:"2500-2599",slug:"/2500-2599/closest-prime-numbers-in-range-medium",permalink:"/solutions/2500-2599/closest-prime-numbers-in-range-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2500-2599/2523-closest-prime-numbers-in-range-medium.md",tags:[],version:"current",sidebarPosition:2523,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/closest-prime-numbers-in-range/"},sidebar:"tutorialSidebar",previous:{title:"2521 - Distinct Prime Factors of Product of Array (Medium)",permalink:"/solutions/2500-2599/distinct-prime-factors-of-product-of-array-medium"},next:{title:"2529 - Maximum Count of Positive Integer and Negative Integer (Easy)",permalink:"/solutions/2500-2599/maximum-count-of-positive-integer-and-negative-integer-easy"}},m={},u=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Prime Sieve",id:"approach-1-prime-sieve",level:2}],c=function(e){return function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",n)}},d=c("Tabs"),f=c("TabItem"),b=c("SolutionAuthor"),g={toc:u};function h(e){var n=e.components,t=(0,i.Z)(e,a);return(0,o.kt)("wrapper",(0,r.Z)({},g,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"2523---closest-prime-numbers-in-range-medium"},"2523 - Closest Prime Numbers in Range (Medium)"),(0,o.kt)("h2",{id:"problem-link"},"Problem Link"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/closest-prime-numbers-in-range/"},"https://leetcode.com/problems/closest-prime-numbers-in-range/")),(0,o.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,o.kt)("p",null,"Given two positive integers ",(0,o.kt)("inlineCode",{parentName:"p"},"left")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"right"),", find the two integers ",(0,o.kt)("inlineCode",{parentName:"p"},"num1")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"num2")," such that:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"left <= nums1 < nums2 <= right"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"nums1")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"nums2")," are both ",(0,o.kt)("strong",{parentName:"li"},"prime")," numbers."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"nums2 - nums1")," is the ",(0,o.kt)("strong",{parentName:"li"},"minimum")," amongst all other pairs satisfying the above conditions.")),(0,o.kt)("p",null,"Return ",(0,o.kt)("em",{parentName:"p"},"the positive integer array")," ",(0,o.kt)("inlineCode",{parentName:"p"},"ans = [nums1, nums2]"),". ",(0,o.kt)("em",{parentName:"p"},"If there are multiple pairs satisfying these conditions, return the one with the minimum")," ",(0,o.kt)("inlineCode",{parentName:"p"},"nums1")," ",(0,o.kt)("em",{parentName:"p"},"value or")," ",(0,o.kt)("inlineCode",{parentName:"p"},"[-1, -1]")," ",(0,o.kt)("em",{parentName:"p"},"if such numbers do not exist.")),(0,o.kt)("p",null,"A number greater than ",(0,o.kt)("inlineCode",{parentName:"p"},"1")," is called ",(0,o.kt)("strong",{parentName:"p"},"prime")," if it is only divisible by ",(0,o.kt)("inlineCode",{parentName:"p"},"1")," and itself."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 1:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: left = 10, right = 19\nOutput: [11,13]\nExplanation: The prime numbers between 10 and 19 are 11, 13, 17, and 19.\nThe closest gap between any pair is 2, which can be achieved by [11,13] or [17,19].\nSince 11 is smaller than 17, we return the first pair.\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 2:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: left = 4, right = 6\nOutput: [-1,-1]\nExplanation: There exists only one prime number in the given range, so the conditions cannot be satisfied.\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Constraints:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"1 <= left <= right <= 10^6"))),(0,o.kt)("p",null,".spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0;\xa0\n}\n.spoiler {overflow:hidden;}\n.spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;}\n.spoilerbutton",'[value="Show Message"]'," + .spoiler > div {margin-top:-500%;}\n.spoilerbutton",'[value="Hide Message"]'," + .spoiler {padding:5px;}"),(0,o.kt)("h2",{id:"approach-1-prime-sieve"},"Approach 1: Prime Sieve"),(0,o.kt)(d,{mdxType:"Tabs"},(0,o.kt)(f,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,o.kt)(b,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    vector<int> primes;\n    vector<bool> is_prime;\n    void prime_sieve(int n) {\n        is_prime.assign(n + 1, 1);\n        is_prime[0] = is_prime[1] = 0;\n        for (int i = 4; i <= n; i += 2) is_prime[i] = 0;\n        for (int i = 3; i * i <= n; i += 2) {\n          if (is_prime[i]) {\n            for (int j = i * i; j <= n; j += i * 2) {\n              is_prime[j] = 0;\n            }\n          }   \n        } \n        primes.push_back(2);\n        for (int i = 3; i <= n; i += 2) {\n            if (is_prime[i]) {\n              primes.push_back(i);\n            }\n        }\n    }\n    \n    vector<int> closestPrimes(int left, int right) {\n        // generate prime numbers\n        prime_sieve(right);\n        int l = -1, r = -1, mi = INT_MAX;\n        // for each prime number\n        for (int i = 1; i < primes.size(); i++) {\n            // if it is within the target range\n            if (left <= primes[i - 1] && primes[i] <= right) {\n                // we calculate the difference\n                int d = primes[i] - primes[i - 1];\n                // if it is less than the min one\n                if (d < mi) {\n                    // update min\n                    mi = d;\n                    // set l and r\n                    l = primes[i - 1];\n                    r = primes[i];\n                }   \n            }\n        }\n        // if both l and r are set, then return {l, r}\n        // else return {-1, -1}\n        return l != -1 && r != 1 ? vector<int>{l, r} : vector<int>{-1, -1};\n    }\n};\n")))))}h.isMDXComponent=!0}}]);