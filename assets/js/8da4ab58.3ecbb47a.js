"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[64149],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var m=r.createContext({}),s=function(e){var t=r.useContext(m),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=s(e.components);return r.createElement(m.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,m=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=s(n),p=i,h=c["".concat(m,".").concat(p)]||c[p]||u[p]||a;return n?r.createElement(h,o(o({ref:t},d),{},{components:n})):r.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=p;var l={};for(var m in t)hasOwnProperty.call(t,m)&&(l[m]=t[m]);l.originalType=e,l[c]="string"==typeof e?e:i,o[1]=l;for(var s=2;s<a;s++)o[s]=n[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},23768:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>o,default:()=>b,frontMatter:()=>a,metadata:()=>l,toc:()=>s});var r=n(87462),i=(n(67294),n(3905));const a={title:"MOD (1e9 + 7)",description:"Mod 1e9+7",hide_table_of_contents:!1,keywords:["leetcode","tutorial","MOD"]},o=void 0,l={unversionedId:"basic-topics/mod",id:"basic-topics/mod",title:"MOD (1e9 + 7)",description:"Mod 1e9+7",source:"@site/tutorials/basic-topics/mod.md",sourceDirName:"basic-topics",slug:"/basic-topics/mod",permalink:"/tutorials/basic-topics/mod",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/basic-topics/mod.md",tags:[],version:"current",frontMatter:{title:"MOD (1e9 + 7)",description:"Mod 1e9+7",hide_table_of_contents:!1,keywords:["leetcode","tutorial","MOD"]},sidebar:"tutorialSidebar",previous:{title:"Linked List",permalink:"/tutorials/basic-topics/linked-list"},next:{title:"Prefix Sum",permalink:"/tutorials/basic-topics/prefix-sum"}},m={},s=[{value:"Overview",id:"overview",level:2},{value:"Modular Arithmetic",id:"modular-arithmetic",level:2},{value:"Addition",id:"addition",level:3},{value:"Subtraction",id:"subtraction",level:3},{value:"Multiplication",id:"multiplication",level:3},{value:"Division",id:"division",level:3},{value:"Example",id:"example",level:2},{value:"Why 1e9 + 7?",id:"why-1e9--7",level:2},{value:"References",id:"references",level:2}],d=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",t)},c=d("TutorialAuthors"),u=d("Tabs"),p=d("TabItem"),h={toc:s},f="wrapper";function b(e){let{components:t,...n}=e;return(0,i.kt)(f,(0,r.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)(c,{names:"@tannudaral",mdxType:"TutorialAuthors"}),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,'When the answer to a problem is a very large number, problem setters expect you to output it "modulo $m$", that is, the remainder after dividing the answer by $m$ (for example, "modulo $1e9 + 7$"). So if the actual answer is very large, with the use of modulo $m$, it would be sufficient to use the data types int and long long. Since many languages do not support large-integer arithmetic, this method avoids integer overflow.'),(0,i.kt)("p",null,"The task of modulo operator $\\%$, also know as the remainder operator, is to give the remainder. We denote it by $x\\,mod\\,m$, the remainder when $x$ is divided by $m$. For example, $17$ $mod$ $5$ $=$ $2$ because $17$ $=$ $3*5 + 2$."),(0,i.kt)("h2",{id:"modular-arithmetic"},"Modular Arithmetic"),(0,i.kt)("p",null,"An important property of the modulo is that in addition, subtraction and multiplication, the remainder can be taken before the operation:  "),(0,i.kt)("h3",{id:"addition"},"Addition"),(0,i.kt)("p",null,"$(a + b)\\,mod\\,m$ $=$ $(a\\,mod\\,m + b\\,mod\\,m)\\,mod\\,m$"),(0,i.kt)("h3",{id:"subtraction"},"Subtraction"),(0,i.kt)("p",null,"The remainder should usually fall between $0....m\u22121$. However, in C++ and other languages, a negative number's remainder is either zero or negative. An easy way to make sure there are no negative remainders is to add m to the result. It is only needed when there are subtractions in the code and the remainder may become negative."),(0,i.kt)("p",null,"$(a\\,\u2212\\,b)\\,mod\\,m$ $=$ $(a\\,mod\\,m\\, \u2212 \\,b\\,mod\\,m\\,+\\,m)\\,mod\\,m$"),(0,i.kt)("h3",{id:"multiplication"},"Multiplication"),(0,i.kt)("p",null,"$(a ",(0,i.kt)("em",{parentName:"p"}," b)\\,mod\\,m$ $=$ $(a\\,mod\\,m ")," b\\,mod\\,m)\\,mod\\,m$"),(0,i.kt)("h3",{id:"division"},"Division"),(0,i.kt)("p",null,'The modular division is completely different from modular addition, subtraction and multiplication. It also does not always exist. It requires a concept called the "Modular Multiplicative Inverse". The modular multiplicative inverse of a number $a$ is the number $a^{\u22121}$ such that $a \u22c5 a^{\u22121} \\,mod\\, m = 1$. You may notice that this is similar to the concept of a reciprocal of a number, but here we don\'t want a fraction; we want an integer, specifically an integer between $0$ and $m\u22121$ inclusive.  '),(0,i.kt)("p",null,"There are ",(0,i.kt)("strong",{parentName:"p"},"two")," faster ways to calculate the inverse: "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Extended GCD algorithm "),(0,i.kt)("li",{parentName:"ul"},"Fermat's little theorem")),(0,i.kt)("p",null,"The extended GCD algorithm may be more versatile and sometimes faster, but Fermat's little theorem method is more popular, since it's almost free once you implement exponentiation, which we will cover here. "),(0,i.kt)("p",null,"Fermat's little theorem says that provided the modulus m is a prime number ($10^9+7$ is prime) then $a^{m}\\,mod\\,m=a\\,mod\\,m$. Working backwards, $a^{m\u22121}\\,mod\\,m = 1 = a \u22c5 a^{m\u22122}\\, mod\\, m$, therefore the number we need is $a^{m\u22122}\\, mod\\, m$."),(0,i.kt)("p",null,"Hence, we can calculate the modular multiplicative inverse $a^{\u22121}$ using $a^{\u22121} = a^{m\u22122}\\, mod\\, m$ when $m$ is prime. We can now define the division operator as:"),(0,i.kt)("p",null,"$$\n(a\\, /\\, b) \\,mod\\, m = (a\\, mod\\, m\\, * b^{-1} \\,mod \\,m)\\, mod\\, m\n$$"),(0,i.kt)("h2",{id:"example"},"Example"),(0,i.kt)("p",null,"Let's understand this with the factorial of a number program. The following code calculates $n!$, the factorial of $n$, modulo $m$:"),(0,i.kt)(u,{mdxType:"Tabs"},(0,i.kt)(p,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"int factorial(int n) {\n    int M = 1e9 + 7;\n    long long fact = 1;\n    for (int i = 2; i <= n; i++) {\n        // WRONG APPROACH\n        // Here, fact may exceed 2 ^ 64 - 1\n        fact = fact * i;                 \n    }           \n    return fact % M;\n}\n")))),(0,i.kt)("p",null,"Thus, we can take the remainder after every operation and the numbers will never become too large."),(0,i.kt)(u,{mdxType:"Tabs"},(0,i.kt)(p,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"int factorial(int n) {\n    int M = 1e9 + 7;\n    long long fact = 1;\n    for (int i = 2; i <= n; i++) {\n        // Here, fact never exceeds 10 ^ 9 + 7\n        fact = (fact * i) % M;\n    }\n \n    return fact;\n}\n")))),(0,i.kt)("h2",{id:"why-1e9--7"},"Why 1e9 + 7?"),(0,i.kt)("p",null,"The number $1e9 + 7$ fits nicely into a signed 32-bit integer. It is also the first 10-digit prime number. In some problems we need to compute the Modular Multiplicative Inverse and it helps very much that this number is prime. "),(0,i.kt)("p",null,"In fact any prime number less then $2^{30}$ will be fine in order to prevent possible overflows. But this one can be easily written as $1e9 + 7$. This reasoning almost uniquely determined this number."),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"https://cses.fi/book/book.pdf"},"Competitive Programmer's Handbook")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Fermat%27s_little_theorem"},"Fermat's Little Theorem"))))}b.isMDXComponent=!0}}]);