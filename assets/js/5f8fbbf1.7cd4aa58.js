"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[72974],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),l=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(i.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},k=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,i=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),m=l(n),k=r,d=m["".concat(i,".").concat(k)]||m[k]||u[k]||s;return n?a.createElement(d,o(o({ref:t},c),{},{components:n})):a.createElement(d,o({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,o=new Array(s);o[0]=k;var p={};for(var i in t)hasOwnProperty.call(t,i)&&(p[i]=t[i]);p.originalType=e,p[m]="string"==typeof e?e:r,o[1]=p;for(var l=2;l<s;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}k.displayName="MDXCreateElement"},73467:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>o,default:()=>b,frontMatter:()=>s,metadata:()=>p,toc:()=>l});var a=n(87462),r=(n(67294),n(3905));const s={description:"Author: @wingkwong, @radojicic23 | https://leetcode.com/problems/backspace-string-compare/"},o="0844 - Backspace String Compare (Easy)",p={unversionedId:"0800-0899/backspace-string-compare-easy",id:"0800-0899/backspace-string-compare-easy",title:"0844 - Backspace String Compare (Easy)",description:"Author: @wingkwong, @radojicic23 | https://leetcode.com/problems/backspace-string-compare/",source:"@site/solutions/0800-0899/0844-backspace-string-compare-easy.md",sourceDirName:"0800-0899",slug:"/0800-0899/backspace-string-compare-easy",permalink:"/solutions/0800-0899/backspace-string-compare-easy",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0800-0899/0844-backspace-string-compare-easy.md",tags:[],version:"current",sidebarPosition:844,frontMatter:{description:"Author: @wingkwong, @radojicic23 | https://leetcode.com/problems/backspace-string-compare/"},sidebar:"tutorialSidebar",previous:{title:"0841 - Keys and Rooms (Medium)",permalink:"/solutions/0800-0899/keys-and-rooms-medium"},next:{title:"0847 - Shortest Path Visiting All Nodes (Hard)",permalink:"/solutions/0800-0899/shortest-path-visiting-all-nodes-hard"}},i={},l=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Simulation",id:"approach-1-simulation",level:2}],c=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",t)},m=c("Tabs"),u=c("TabItem"),k=c("SolutionAuthor"),d={toc:l},h="wrapper";function b(e){let{components:t,...n}=e;return(0,r.kt)(h,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"0844---backspace-string-compare-easy"},"0844 - Backspace String Compare (Easy)"),(0,r.kt)("h2",{id:"problem-link"},"Problem Link"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/backspace-string-compare/"},"https://leetcode.com/problems/backspace-string-compare/")),(0,r.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.kt)("p",null,"Given two strings ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"t"),", return ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," ",(0,r.kt)("em",{parentName:"p"},"if they are equal when both are typed into empty text editors"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"'#'")," means a backspace character."),(0,r.kt)("p",null,"Note that after backspacing an empty text, the text will continue empty."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Input: s = "ab#c", t = "ad#c"\nOutput: true\nExplanation: Both s and t become "ac".\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Input: s = "ab##", t = "c#d#"\nOutput: true\nExplanation: Both s and t become "".\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 3:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Input: s = "a#c", t = "b"\nOutput: false\nExplanation: s becomes "c" while t becomes "b".\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Constraints:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"1 <= s.length, t.length <= 200")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"s")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"t")," only contain lowercase letters and ",(0,r.kt)("inlineCode",{parentName:"li"},"'#'")," characters.")),(0,r.kt)("h2",{id:"approach-1-simulation"},"Approach 1: Simulation"),(0,r.kt)("p",null,"We build the final string for ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"s")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"s")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"s")))))," and ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},(0,r.kt)("span",{parentName:"span",className:"katex"},(0,r.kt)("span",{parentName:"span",className:"katex-mathml"},(0,r.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,r.kt)("semantics",{parentName:"math"},(0,r.kt)("mrow",{parentName:"semantics"},(0,r.kt)("mi",{parentName:"mrow"},"t")),(0,r.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"t")))),(0,r.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,r.kt)("span",{parentName:"span",className:"base"},(0,r.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6151em"}}),(0,r.kt)("span",{parentName:"span",className:"mord mathnormal"},"t"))))),". If we see #, then we can only backspace if the final string is not empty. Otherwise, we add the character to the final string. Since we need to do the same thing on both string, it's better to write a function to build the string."),(0,r.kt)(m,{mdxType:"Tabs"},(0,r.kt)(u,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)(k,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    string process(string s) {\n        string res;\n        for (auto x : s) {\n            // include this character to final string\n            if (x != '#') res.push_back(x);\n            // pop the previous character if possible\n            else if (res.size()) res.pop_back();\n        }\n        return res;\n    }\n    bool backspaceCompare(string s, string t) {\n        // check if both are same after processed\n        return process(s) == process(t);\n    }\n};\n"))),(0,r.kt)(u,{value:"python",label:"Python",mdxType:"TabItem"},(0,r.kt)(k,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'class Solution:\n    def backspaceCompare(self, s: str, t: str) -> bool:\n        \n        def get_result(st):\n            new_st = []\n            for c in st:\n                if c == "#":\n                    if new_st:\n                        new_st.pop()\n                else:\n                    new_st.append(c)\n            return "".join(new_st)\n        return get_result(s) == get_result(t)\n'))),(0,r.kt)(u,{value:"javascript",label:"JavaScript",mdxType:"TabItem"},(0,r.kt)(k,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'/**\n * @param {string} s\n * @param {string} t\n * @return {boolean}\n */\nvar backspaceCompare = function(s, t) {\n    function get_result(st) {\n        let new_st = [];\n        for (c of st) {\n            if (c == "#") {\n                if (new_st != null) new_st.pop();\n            } else new_st.push(c);\n        }\n        return new_st.join("");\n    }\n    return get_result(s) == get_result(t);\n};\n')))))}b.isMDXComponent=!0}}]);