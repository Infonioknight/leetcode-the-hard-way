"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[98270],{3905:(e,n,t)=>{t.d(n,{Zo:()=>s,kt:()=>f});var i=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function m(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var p=i.createContext({}),l=function(e){var n=i.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):m(m({},n),e)),t},s=function(e){var n=l(e.components);return i.createElement(p.Provider,{value:n},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},d=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,p=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),u=l(t),d=r,f=u["".concat(p,".").concat(d)]||u[d]||c[d]||a;return t?i.createElement(f,m(m({ref:n},s),{},{components:t})):i.createElement(f,m({ref:n},s))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,m=new Array(a);m[0]=d;var o={};for(var p in n)hasOwnProperty.call(n,p)&&(o[p]=n[p]);o.originalType=e,o[u]="string"==typeof e?e:r,m[1]=o;for(var l=2;l<a;l++)m[l]=t[l];return i.createElement.apply(null,m)}return i.createElement.apply(null,t)}d.displayName="MDXCreateElement"},21506:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>m,default:()=>k,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var i=t(87462),r=(t(67294),t(3905));const a={description:"Author: @wingkwong | https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/"},m="2616 - Minimize the Maximum Difference of Pairs (Medium)",o={unversionedId:"2600-2699/minimize-the-maximum-difference-of-pairs-medium",id:"2600-2699/minimize-the-maximum-difference-of-pairs-medium",title:"2616 - Minimize the Maximum Difference of Pairs (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/",source:"@site/solutions/2600-2699/2616-minimize-the-maximum-difference-of-pairs-medium.md",sourceDirName:"2600-2699",slug:"/2600-2699/minimize-the-maximum-difference-of-pairs-medium",permalink:"/solutions/2600-2699/minimize-the-maximum-difference-of-pairs-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/2600-2699/2616-minimize-the-maximum-difference-of-pairs-medium.md",tags:[],version:"current",sidebarPosition:2616,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/"},sidebar:"tutorialSidebar",previous:{title:"2615 - Sum of Distances (Medium)",permalink:"/solutions/2600-2699/sum-of-distances-medium"},next:{title:"2639 - Find the Width of Columns of a Grid (Easy)",permalink:"/solutions/2600-2699/find-the-width-of-columns-of-a-grid-easy"}},p={},l=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Binary Search",id:"approach-1-binary-search",level:2}],s=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",n)},u=s("Tabs"),c=s("TabItem"),d=s("SolutionAuthor"),f={toc:l},h="wrapper";function k(e){let{components:n,...t}=e;return(0,r.kt)(h,(0,i.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"2616---minimize-the-maximum-difference-of-pairs-medium"},"2616 - Minimize the Maximum Difference of Pairs (Medium)"),(0,r.kt)("h2",{id:"problem-link"},"Problem Link"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/"},"https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/")),(0,r.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.kt)("p",null,"You are given a ",(0,r.kt)("strong",{parentName:"p"},"0-indexed")," integer array ",(0,r.kt)("inlineCode",{parentName:"p"},"nums")," and an integer ",(0,r.kt)("inlineCode",{parentName:"p"},"p"),". Find ",(0,r.kt)("inlineCode",{parentName:"p"},"p")," pairs of indices of ",(0,r.kt)("inlineCode",{parentName:"p"},"nums")," such that the ",(0,r.kt)("strong",{parentName:"p"},"maximum")," difference amongst all the pairs is ",(0,r.kt)("strong",{parentName:"p"},"minimized"),". Also, ensure no index appears more than once amongst the ",(0,r.kt)("inlineCode",{parentName:"p"},"p")," pairs."),(0,r.kt)("p",null,"Note that for a pair of elements at the index ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"j"),", the difference of this pair is ",(0,r.kt)("inlineCode",{parentName:"p"},"|nums[i] - nums[j]|"),", where ",(0,r.kt)("inlineCode",{parentName:"p"},"|x|")," represents the ",(0,r.kt)("strong",{parentName:"p"},"absolute")," ",(0,r.kt)("strong",{parentName:"p"},"value")," of ",(0,r.kt)("inlineCode",{parentName:"p"},"x"),"."),(0,r.kt)("p",null,"Return ",(0,r.kt)("em",{parentName:"p"},"the ",(0,r.kt)("strong",{parentName:"em"},"minimum")," ",(0,r.kt)("strong",{parentName:"em"},"maximum")," difference among all"),(0,r.kt)("inlineCode",{parentName:"p"},"p")," ",(0,r.kt)("em",{parentName:"p"},"pairs.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: nums = [10,1,2,7,1,3], p = 2\nOutput: 1\nExplanation: The first pair is formed from the indices 1 and 4, and the second pair is formed from the indices 2 and 5. \nThe maximum difference is max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1. Therefore, we return 1.\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: nums = [4,2,1,2], p = 1\nOutput: 0\nExplanation: Let the indices 1 and 3 form a pair. The difference of that pair is |2 - 2| = 0, which is the minimum we can attain.\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Constraints:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"1 <= nums.length <= 10^5")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"0 <= nums[i] <= 10^9")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"0 <= p <= (nums.length)/2"))),(0,r.kt)("h2",{id:"approach-1-binary-search"},"Approach 1: Binary Search"),(0,r.kt)(u,{mdxType:"Tabs"},(0,r.kt)(c,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    // min max -> think of binary search\n    int minimizeMax(vector<int>& nums, int p) {\n        // sort the input first\n        sort(nums.begin(), nums.end());\n        // the possible difference ranges from 0 to the largest value - the smallest value\n        int n = nums.size(), l = 0 , r = nums.back() - nums.front();\n        // binary search the min max diff\n        while (l < r) {\n            int m = l + (r - l) / 2, cnt = 0;\n            for (int i = 1; i < n; i++) {\n                // we can make a pair\n                if (nums[i] - nums[i - 1] <= m) {\n                    // increase the number of pairs\n                    cnt += 1;\n                    // increase i by 1\n                    // since it is included in the pair already\n                    i += 1;\n                }\n            }\n            // not enough pairs, move l pointer excluding m\n            if (cnt < p) l = m + 1;\n            // too many pairs, move r to m\n            else r = m;\n        }\n        return l;\n    }\n};\n")))))}k.isMDXComponent=!0}}]);