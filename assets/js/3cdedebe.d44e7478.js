"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[48318],{3905:(e,n,o)=>{o.d(n,{Zo:()=>p,kt:()=>d});var t=o(67294);function r(e,n,o){return n in e?Object.defineProperty(e,n,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[n]=o,e}function a(e,n){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),o.push.apply(o,t)}return o}function i(e){for(var n=1;n<arguments.length;n++){var o=null!=arguments[n]?arguments[n]:{};n%2?a(Object(o),!0).forEach((function(n){r(e,n,o[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):a(Object(o)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(o,n))}))}return e}function l(e,n){if(null==e)return{};var o,t,r=function(e,n){if(null==e)return{};var o,t,r={},a=Object.keys(e);for(t=0;t<a.length;t++)o=a[t],n.indexOf(o)>=0||(r[o]=e[o]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)o=a[t],n.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var s=t.createContext({}),c=function(e){var n=t.useContext(s),o=n;return e&&(o="function"==typeof e?e(n):i(i({},n),e)),o},p=function(e){var n=c(e.components);return t.createElement(s.Provider,{value:n},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},h=t.forwardRef((function(e,n){var o=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(o),h=r,d=m["".concat(s,".").concat(h)]||m[h]||u[h]||a;return o?t.createElement(d,i(i({ref:n},p),{},{components:o})):t.createElement(d,i({ref:n},p))}));function d(e,n){var o=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=o.length,i=new Array(a);i[0]=h;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l[m]="string"==typeof e?e:r,i[1]=l;for(var c=2;c<a;c++)i[c]=o[c];return t.createElement.apply(null,i)}return t.createElement.apply(null,o)}h.displayName="MDXCreateElement"},8857:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>s,contentTitle:()=>i,default:()=>f,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var t=o(87462),r=(o(67294),o(3905));const a={description:"Author: @BlackPanther112358 | https://leetcode.com/problems/count-ways-to-build-rooms-in-an-ant-colony/",tags:["Math","Dynamic Programming","Tree","Graph","Topological Sort","Combinatorics"]},i="1916 - Count Ways to Build Rooms in an Ant Colony (Hard)",l={unversionedId:"1900-1999/count-ways-to-build-rooms-in-an-ant-colony",id:"1900-1999/count-ways-to-build-rooms-in-an-ant-colony",title:"1916 - Count Ways to Build Rooms in an Ant Colony (Hard)",description:"Author: @BlackPanther112358 | https://leetcode.com/problems/count-ways-to-build-rooms-in-an-ant-colony/",source:"@site/solutions/1900-1999/1916-count-ways-to-build-rooms-in-an-ant-colony.md",sourceDirName:"1900-1999",slug:"/1900-1999/count-ways-to-build-rooms-in-an-ant-colony",permalink:"/solutions/1900-1999/count-ways-to-build-rooms-in-an-ant-colony",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1900-1999/1916-count-ways-to-build-rooms-in-an-ant-colony.md",tags:[{label:"Math",permalink:"/solutions/tags/math"},{label:"Dynamic Programming",permalink:"/solutions/tags/dynamic-programming"},{label:"Tree",permalink:"/solutions/tags/tree"},{label:"Graph",permalink:"/solutions/tags/graph"},{label:"Topological Sort",permalink:"/solutions/tags/topological-sort"},{label:"Combinatorics",permalink:"/solutions/tags/combinatorics"}],version:"current",sidebarPosition:1916,frontMatter:{description:"Author: @BlackPanther112358 | https://leetcode.com/problems/count-ways-to-build-rooms-in-an-ant-colony/",tags:["Math","Dynamic Programming","Tree","Graph","Topological Sort","Combinatorics"]},sidebar:"tutorialSidebar",previous:{title:"1900 - 1999",permalink:"/solutions/category/1900---1999"},next:{title:"1926 - Nearest Exit from Entrance in Maze (Medium)",permalink:"/solutions/1900-1999/nearest-exit-from-entrance-in-maze-medium"}},s={},c=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Combinatorics and Graph Traversal",id:"approach-1-combinatorics-and-graph-traversal",level:2}],p=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",n)},m=p("Tabs"),u=p("TabItem"),h=p("SolutionAuthor"),d={toc:c},b="wrapper";function f(e){let{components:n,...o}=e;return(0,r.kt)(b,(0,t.Z)({},d,o,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"1916---count-ways-to-build-rooms-in-an-ant-colony-hard"},"1916 - Count Ways to Build Rooms in an Ant Colony (Hard)"),(0,r.kt)("h2",{id:"problem-link"},"Problem Link"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/count-ways-to-build-rooms-in-an-ant-colony/"},"https://leetcode.com/problems/count-ways-to-build-rooms-in-an-ant-colony/")),(0,r.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.kt)("p",null,"You are an ant tasked with adding ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," new rooms numbered ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"n-1")," to your colony. You are given the expansion plan as a 0-indexed integer array of length ",(0,r.kt)("inlineCode",{parentName:"p"},"n"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"prevRoom"),", where ",(0,r.kt)("inlineCode",{parentName:"p"},"prevRoom[i]")," indicates that you must build room ",(0,r.kt)("inlineCode",{parentName:"p"},"prevRoom[i]")," before building room ",(0,r.kt)("inlineCode",{parentName:"p"},"i"),", and these two rooms must be connected directly. Room ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," is already built, so ",(0,r.kt)("inlineCode",{parentName:"p"},"prevRoom[0] = -1"),". The expansion plan is given such that once all the rooms are built, every room will be reachable from room ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,r.kt)("p",null,"You can only build one room at a time, and you can travel freely between rooms you have already built only if they are connected. You can choose to build any room as long as its previous room is already built."),(0,r.kt)("p",null,"Return the number of different orders you can build all the rooms in. Since the answer may be large, return it modulo ",(0,r.kt)("inlineCode",{parentName:"p"},"10^9 + 7"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: prevRoom = [-1,0,1]\nOutput: 1\nExplanation: There is only one way to build the additional rooms: 0 \u2192 1 \u2192 2\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: prevRoom = [-1,0,0,1,2]\nOutput: 6\nExplanation: \nThe 6 ways are:\n0 \u2192 1 \u2192 3 \u2192 2 \u2192 4\n0 \u2192 2 \u2192 4 \u2192 1 \u2192 3\n0 \u2192 1 \u2192 2 \u2192 3 \u2192 4\n0 \u2192 1 \u2192 2 \u2192 4 \u2192 3\n0 \u2192 2 \u2192 1 \u2192 3 \u2192 4\n0 \u2192 2 \u2192 1 \u2192 4 \u2192 3\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Constraints:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"n == prevRoom.length")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"2 <= n <= 10^5")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"prevRoom[0] == -1")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"0 <= prevRoom[i] <= n")," for all ",(0,r.kt)("inlineCode",{parentName:"li"},"1 <= i < n"))),(0,r.kt)("h2",{id:"approach-1-combinatorics-and-graph-traversal"},"Approach 1: Combinatorics and Graph Traversal"),(0,r.kt)("p",null,"Once we obtain the graph from the structure of the ant colony, this problem can be simplified to finding the number of valid ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Topological_sorting"},"Topological sorts")," for the given directed tree. "),(0,r.kt)("p",null,"We can observe that when there is no branching, i.e., when there is a single chain, there is only $1$ way possible. Now, we consider nodes where we have more than $1$ children node. Then we have to find the number of ways to organize the particular subtree with such node as root. We can then update the value in a global variable $ans$. "),(0,r.kt)("p",null,"Thus, our task simplifies as follows, for every node, we take the number of nodes of each branch possible from that node. Then, we find the number of ways to rearrange the components such that any particular value is in order relative to other components belonging to the same branch. For example, if a branch has $2$ components :- $a$ and $b$, while another branch also has $2$ components :- $c$ and $d$, the $6$ possible arrangements are:$","\\","$\n$a,b,c,d","\\","$\n$a,c,b,d","\\","$\n$a,c,d,b","\\","$\n$c,d,a,b","\\","$\n$c,a,b,d","\\","$\n$c,a,d,b","\\","$"),(0,r.kt)("p",null,"Let there be $m$ such branches, and the number of nodes in $i^{th}$ branch be $r",(0,r.kt)("em",{parentName:"p"},"i$. Then the total number of nodes, which are children of the chosen node is $t = \\sum"),"{i = 1}^{m} r_i$."),(0,r.kt)("p",null,"Now using some combinatorics, the expression for the above can be found to be:-"),(0,r.kt)("p",null,"$\\Large{\\frac{t!}{\\prod_{i = 1}^{m} r_i!} = \\frac{t!}{r_1! \\cdot r_2! \\cdot ... \\cdot r_m!}}$"),(0,r.kt)("p",null,"To prove the above expression, Let's first choose $r_1$ places out of total $t$ places to arrange the sequence in the first branch. This can be done in $t \\choose r_1$ ways. Similarly, for the sequence from second branch, we will have $t - r_1 \\choose r_2$ ways, and so on."),(0,r.kt)("p",null,"Upon multiplying the number of ways for all the branches and simplifing, we get the required expression. As the order of components in a branch is fixed, there is only $1$ way to fill the chosen places for a single branch."),(0,r.kt)("p",null,"To compute $\\Large{\\frac{1}{r_i!}}$, we will use modular inverse of $r_i!$ and then multiply the value."),(0,r.kt)("p",null,"Thus, we will use DFS (Depth-First Search) to traverse the tree, and find the number of ways to rearrange the subtree for the current node and update the value into a variable ",(0,r.kt)("inlineCode",{parentName:"p"},"ans"),". We will also return the number of nodes found to help with calculating the number of ways for parent nodes."),(0,r.kt)("p",null,"Time Complexity: $O(n)","\\","$\nSpace Complexity: $O(n)$"),(0,r.kt)(m,{mdxType:"Tabs"},(0,r.kt)(u,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)(h,{name:"@BlackPanther112358",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    // Constants\n    int mod = 1e9 + 7;\n\n    // Making arrays to store the factorial and inverse factorial modulo m\n    vector<long long int> factorial;\n    vector<long long int> inverse_factorial;\n\n    // Storing the graph in adjacency list form\n    vector<vector<int>> graph;\n\n    // Variable to store the final answer, the number of ways to write a valid Topological sort\n    long long int ans = 1;\n\n    // Recursive funtion to return the number of nodes below itself in the graph including self,  also updates ans\n    int cntTopSorts(int u){\n        // Store the number of children rooms for the current room\n        int totalRooms = 0;\n        // Store the number of rooms in each branch\n        vector<int> roomsInEachBranch;\n\n        // Perform dfs to find the total number of rooms in each branch\n        for(int v : graph[u]){\n            int rooms = cntTopSorts(v);\n            totalRooms += rooms;\n            roomsInEachBranch.push_back(rooms);\n        }\n\n        // Update the value of ans\n        ans *= factorial[totalRooms];\n        ans %= mod;\n        for(int rooms : roomsInEachBranch){\n            ans *= inverse_factorial[rooms];\n            ans %= mod;\n        }\n\n        // Increment the value of totalRooms to consider the current room and return\n        return ++totalRooms;\n    }\n\n    int waysToBuildRooms(vector<int>& prevRoom) {\n        int n = prevRoom.size();\n\n        // Calculate values for factorial\n        factorial.push_back(1);\n        for (int i = 1 ; i <= n ; i++) factorial.push_back((factorial.back() * i) % mod);\n\n        // Calculate values for inverse factorial\n        vector<long long int> inverse;\n        inverse.push_back(1);\n        inverse.push_back(1);\n        inverse_factorial.push_back(1);\n        inverse_factorial.push_back(1);\n        for (int i = 2 ; i <= n ; i++) {\n            inverse.push_back((mod - ((mod / i) * inverse[mod % i]) % mod) % mod);\n            inverse_factorial.push_back((inverse_factorial[i - 1] * inverse[i]) % mod);\n        }\n\n        // Complete the graph for the ant colony\n        graph.resize(n, vector<int> (0));\n        for (int i = 1 ; i < prevRoom.size() ; i++) graph[prevRoom[i]].push_back(i);\n\n        // Call the helper function for the first room\n        cntTopSorts(0);\n\n        // return the final answer\n        return ans;\n    }\n};\n")))))}f.isMDXComponent=!0}}]);