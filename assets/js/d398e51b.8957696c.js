"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[77753],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>h});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function m(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},s=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,s=m(e,["components","mdxType","originalType","parentName"]),u=p(n),d=i,h=u["".concat(l,".").concat(d)]||u[d]||c[d]||o;return n?r.createElement(h,a(a({ref:t},s),{},{components:n})):r.createElement(h,a({ref:t},s))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=d;var m={};for(var l in t)hasOwnProperty.call(t,l)&&(m[l]=t[l]);m.originalType=e,m[u]="string"==typeof e?e:i,a[1]=m;for(var p=2;p<o;p++)a[p]=n[p];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},95341:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>g,frontMatter:()=>o,metadata:()=>m,toc:()=>p});var r=n(87462),i=(n(67294),n(3905));const o={description:"Author: @wingkwong | https://leetcode.com/problems/maximum-score-from-performing-multiplication-operations"},a="1770 - Maximum Score from Performing Multiplication Operations (Medium)",m={unversionedId:"1700-1799/maximum-score-from-performing-multiplication-operations-medium",id:"1700-1799/maximum-score-from-performing-multiplication-operations-medium",title:"1770 - Maximum Score from Performing Multiplication Operations (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/maximum-score-from-performing-multiplication-operations",source:"@site/solutions/1700-1799/1770-maximum-score-from-performing-multiplication-operations-medium.md",sourceDirName:"1700-1799",slug:"/1700-1799/maximum-score-from-performing-multiplication-operations-medium",permalink:"/solutions/1700-1799/maximum-score-from-performing-multiplication-operations-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1700-1799/1770-maximum-score-from-performing-multiplication-operations-medium.md",tags:[],version:"current",sidebarPosition:1770,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/maximum-score-from-performing-multiplication-operations"},sidebar:"tutorialSidebar",previous:{title:"1768 - Merge Strings Alternately (Easy)",permalink:"/solutions/1700-1799/merge-strings-alternately-easy"},next:{title:"1790 - Check if One String Swap Can Make Strings Equal (Easy)",permalink:"/solutions/1700-1799/check-if-one-string-swap-can-make-strings-equal-easy"}},l={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Dynamic Programming",id:"approach-1-dynamic-programming",level:2}],s=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",t)},u=s("Tabs"),c=s("TabItem"),d=s("SolutionAuthor"),h={toc:p},f="wrapper";function g(e){let{components:t,...n}=e;return(0,i.kt)(f,(0,r.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"1770---maximum-score-from-performing-multiplication-operations-medium"},"1770 - Maximum Score from Performing Multiplication Operations (Medium)"),(0,i.kt)("h2",{id:"problem-link"},"Problem Link"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/maximum-score-from-performing-multiplication-operations"},"https://leetcode.com/problems/maximum-score-from-performing-multiplication-operations")),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"You are given two integer arrays ",(0,i.kt)("inlineCode",{parentName:"p"},"nums")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"multipliers")," *",(0,i.kt)("strong",{parentName:"p"},"* of size ",(0,i.kt)("inlineCode",{parentName:"strong"},"n")," and ",(0,i.kt)("inlineCode",{parentName:"strong"},"m")," respectively, where ",(0,i.kt)("inlineCode",{parentName:"strong"},"n >= m"),". The arrays are "),"1-indexed**."),(0,i.kt)("p",null,"You begin with a score of ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),". You want to perform ",(0,i.kt)("strong",{parentName:"p"},"exactly")," ",(0,i.kt)("inlineCode",{parentName:"p"},"m")," operations. On the ",(0,i.kt)("inlineCode",{parentName:"p"},"ith")," operation ",(0,i.kt)("strong",{parentName:"p"},"(1-indexed)"),", you will:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Choose one integer ",(0,i.kt)("inlineCode",{parentName:"li"},"x")," from ",(0,i.kt)("strong",{parentName:"li"},"either the start or the end")," of the array ",(0,i.kt)("inlineCode",{parentName:"li"},"nums"),"."),(0,i.kt)("li",{parentName:"ul"},"Add ",(0,i.kt)("inlineCode",{parentName:"li"},"multipliers[i] * x")," to your score."),(0,i.kt)("li",{parentName:"ul"},"Remove ",(0,i.kt)("inlineCode",{parentName:"li"},"x")," from the array ",(0,i.kt)("inlineCode",{parentName:"li"},"nums"),".")),(0,i.kt)("p",null,"Return ",(0,i.kt)("em",{parentName:"p"},"the ",(0,i.kt)("strong",{parentName:"em"},"maximum")," score after performing")," ",(0,i.kt)("inlineCode",{parentName:"p"},"m")," ",(0,i.kt)("em",{parentName:"p"},"operations.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: nums = [1,2,3], multipliers = [3,2,1]\nOutput: 14\nExplanation: An optimal solution is as follows:\n- Choose from the end, [1,2,3], adding 3 * 3 = 9 to the score.\n- Choose from the end, [1,2], adding 2 * 2 = 4 to the score.\n- Choose from the end, [1], adding 1 * 1 = 1 to the score.\nThe total score is 9 + 4 + 1 = 14.\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Input: nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6]\nOutput: 102\nExplanation: An optimal solution is as follows:\n- Choose from the start, [-5,-3,-3,-2,7,1], adding -5 * -10 = 50 to the score.\n- Choose from the start, [-3,-3,-2,7,1], adding -3 * -5 = 15 to the score.\n- Choose from the start, [-3,-2,7,1], adding -3 * 3 = -9 to the score.\n- Choose from the end, [-2,7,1], adding 1 * 4 = 4 to the score.\n- Choose from the end, [-2,7], adding 7 * 6 = 42 to the score. \nThe total score is 50 + 15 - 9 + 4 + 42 = 102.\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"n == nums.length")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"m == multipliers.length")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"1 <= m <= 103")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"m <= n <= 105")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"-1000 <= nums[i], multipliers[i] <= 1000"))),(0,i.kt)("h2",{id:"approach-1-dynamic-programming"},"Approach 1: Dynamic Programming"),(0,i.kt)("p",null,"This is a classic DP problem. You choose one operation out of two. The tricky part is to handle three things - the starting point of nums, the ending point of nums, and the current point of multipliers."),(0,i.kt)("p",null,"If we go for a 3D DP solution, it will get TLE given the constraints. Hence we need to reduce it to a 2D solution. We need the pointer at multipliers anyway so we need to think about how to use one pointer to track both starting point and the ending point."),(0,i.kt)("p",null,"Supposing our multipliers pointer is at index $$j$$ (0-based), that means we have multiplied $$j + 1$$elements already. If our starting point is at index $$i$$ (0-based), the ending point would be at index $$n - 1 - j +i$$."),(0,i.kt)("p",null,"Let $$dp","[i][j]","$$ be the maximum score where $$i$$ is the pointer at $$nums$$ and $$j$$ is the pointer at $$mult$$. When $$j$$ reaches the end of $$mult$$, then return $$0$$. If $$dp","[i][j]","$$has been calculated before, return it immediately. Otherwise, we have two options."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"if we pick from the left, we got $$mult","[j]"," * nums","[i]"," + dfs(nums, mult, i + 1, j + 1)$$"),(0,i.kt)("li",{parentName:"ul"},"if we pick from the right, $$mult","[j]"," * nums","[n - 1 - j + i]"," + dfs(nums, mult, i, j + 1)$$")),(0,i.kt)(u,{mdxType:"Tabs"},(0,i.kt)(c,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int m, n;\n    int dfs(vector<int>& nums, vector<int>& mult, vector<vector<int>>& dp, int i, int j) {\n        // i : pointer at nums\n        // j : pointer at mult\n        // if we have performed all operations, then return 0\n        if (j == m) return 0;\n        // memoizated before - return the value here\n        if (dp[i][j] != INT_MIN) return dp[i][j];\n        // we can either choose an integer in `nums` the start or the end of the array\n        // so we try both case and take the maximum value\n        // then memoize it\n        return dp[i][j] = max(\n            // pick from the start\n            mult[j] * nums[i] + dfs(nums, mult, dp, i + 1, j + 1),\n            // pick fromt the end\n            mult[j] * nums[n - 1 - (j - i)] + dfs(nums, mult, dp, i, j + 1)\n        ); \n    }\n    int maximumScore(vector<int>& nums, vector<int>& multipliers) {\n        n = (int) nums.size(), m = (int) multipliers.size();\n        // don't init -1 here. it will cause TLE\n        vector<vector<int>> dp(m, vector<int>(m, INT_MIN));\n        // or u can return dp[0][0] after running dfs\n        return dfs(nums, multipliers, dp, 0, 0);\n    }\n};\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"}," Iterative Approach ")),(0,i.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int maximumScore(vector<int>& nums, vector<int>& multipliers) {\n        int n = (int) nums.size(), m = (int) multipliers.size();\n        vector<int> dp(m + 1);\n        // let's think backwards\n        for (int i = 0; i < m; i++) {\n            // at round m, we  pick the m-th multiplier\n            // at round m - 1, we pick the (m - 1)-th multiplier\n            // at round m - 2, we pick the (m - 2)-th multiplier\n            // and so on ... \n            int mult = multipliers[m - 1 - i];\n            // how many elements we need to process? \n            // at round m, there are m elements\n            // at round m - 1, there are m - 1 elements\n            // at round m - 2, there are m - 2 elements\n            // and so on ...\n            for (int j = 0; j < m - i; j++) {\n                // so we take the max of\n                dp[j] = max(\n                    // the start\n                    mult * nums[j] + dp[j + 1], \n                    // the end\n                    mult * nums[j + (n - (m - i))] + dp[j]\n                );\n            }\n        }\n        return dp[0];\n    }\n};\n")))))}g.isMDXComponent=!0}}]);