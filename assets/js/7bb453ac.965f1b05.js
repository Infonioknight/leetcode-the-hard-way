"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[64142],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>f});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),m=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=m(e.components);return r.createElement(l.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},c=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),p=m(t),c=a,f=p["".concat(l,".").concat(c)]||p[c]||d[c]||i;return t?r.createElement(f,s(s({ref:n},u),{},{components:t})):r.createElement(f,s({ref:n},u))}));function f(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,s=new Array(i);s[0]=c;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o[p]="string"==typeof e?e:a,s[1]=o;for(var m=2;m<i;m++)s[m]=t[m];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},68040:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>m});var r=t(87462),a=(t(67294),t(3905));const i={description:"Author: @darkhope | https://leetcode.com/problems/make-sum-divisible-by-p/",tags:["Array","Hash Table","Prefix Sum"]},s="1590 - Make Sum Divisible by P (Medium)",o={unversionedId:"1500-1599/make_sum_divisible_by_p-medium",id:"1500-1599/make_sum_divisible_by_p-medium",title:"1590 - Make Sum Divisible by P (Medium)",description:"Author: @darkhope | https://leetcode.com/problems/make-sum-divisible-by-p/",source:"@site/solutions/1500-1599/1590-make_sum_divisible_by_p-medium.md",sourceDirName:"1500-1599",slug:"/1500-1599/make_sum_divisible_by_p-medium",permalink:"/solutions/1500-1599/make_sum_divisible_by_p-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1500-1599/1590-make_sum_divisible_by_p-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Hash Table",permalink:"/solutions/tags/hash-table"},{label:"Prefix Sum",permalink:"/solutions/tags/prefix-sum"}],version:"current",sidebarPosition:1590,frontMatter:{description:"Author: @darkhope | https://leetcode.com/problems/make-sum-divisible-by-p/",tags:["Array","Hash Table","Prefix Sum"]},sidebar:"tutorialSidebar",previous:{title:"1588 - Sum Of All Odd Length Subarrays (Easy)",permalink:"/solutions/1500-1599/sum-of-all-odd-length-subarrays-easy"},next:{title:"1600 - 1699",permalink:"/solutions/category/1600---1699"}},l={},m=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Hash Map",id:"approach-1-hash-map",level:2}],u=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,a.kt)("div",n)},p=u("Tabs"),d=u("TabItem"),c=u("SolutionAuthor"),f={toc:m},b="wrapper";function h(e){let{components:n,...t}=e;return(0,a.kt)(b,(0,r.Z)({},f,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"1590---make-sum-divisible-by-p-medium"},"1590 - Make Sum Divisible by P (Medium)"),(0,a.kt)("h2",{id:"problem-link"},"Problem Link"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/make-sum-divisible-by-p/"},"https://leetcode.com/problems/make-sum-divisible-by-p/")),(0,a.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,a.kt)("p",null,"Given an array of positive integers nums, remove the smallest subarray (possibly empty) such that the sum of the remaining elements is divisible by p. It is not allowed to remove the whole array."),(0,a.kt)("p",null,"Return the length of the smallest subarray that you need to remove, or -1 if it's impossible."),(0,a.kt)("p",null,"A subarray is defined as a contiguous block of elements in the array."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 1:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: nums = [3,1,4,2], p = 6\nOutput: 1\nExplanation: The sum of the elements in nums is 10, which is not divisible by 6. We can remove the subarray [4], and the sum of the remaining elements is 6, which is divisible by 6.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 2:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: nums = [6,3,5,2], p = 9\nOutput: 2\nExplanation: We cannot remove a single element to get a sum divisible by 9. The best way is to remove the subarray [5,2], leaving us with [6,3] with sum 9.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example 3:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"Input: nums = [1,2,3], p = 3\nOutput: 0\nExplanation: Here the sum is 6. which is already divisible by 3. Thus we do not need to remove anything.\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Constraints:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= nums.length <= 10^5")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= nums[i] <= 10^9")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"1 <= p <= 10^9"))),(0,a.kt)("h2",{id:"approach-1-hash-map"},"Approach 1: Hash Map"),(0,a.kt)("p",null,"We first compute the sum of array an then take its modulo wtih given interger $p$, if this number is $0$, that's awesome return $0$ else we somehow have to make this number $0$. For this we will remove some subarray and make remainder of sum of array = $0$"),(0,a.kt)("p",null,"Firstly we take a suffix array of sum from $n-1$ to $i$ % $p$, then we will iterate from $0$ to $n$ and make a unordered_map (HashMap) to store (remainder as key and its last index as value), now if we have to remove an subarray that ends at $i$, then our ans for current $i$ will be difference of $i$ and index of complement for $suff","[i + 1]","$ in hashmap i.e $i$ - $index$ $of$ $( p - suff","[i + 1]",") % p$."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Time Complexity: $O(n)$")),(0,a.kt)("p",null,"Calculating and storing suffix array will be done in $O(n)$.\nSince we are using unordered_map so it will give average $O(1)$ for inserting and fetching.  "),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Space Complexity: $O(n)$")),(0,a.kt)("p",null,"The only extra memory we are using is the suffix array and a HashMap."),(0,a.kt)(p,{mdxType:"Tabs"},(0,a.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,a.kt)(c,{name:"@darkhope",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    int minSubarray(vector<int> &nums, int p) {\n        int n = nums.size();\n        // suffix array of modulo\n        vector<int> suff(n);\n        long long sum = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            sum += nums[i];\n            suff[i] = sum % p;\n        }\n        // if array is already divisible by p\n        if (sum % p == 0) return 0;\n        unordered_map<int, int> m;\n        // defualt sum of arrayis 0 as none element is selected.\n        m[0] = -1;\n        sum = 0;\n        // Final answer to be stored in this\n        int ans = INT_MAX;\n        for (int i = 0; i < n; i++) {\n            sum += nums[i];\n            sum %= p;\n            if (i + 1 < n) {\n                // removing a subarray that doesn't involve last element\n                // complement of suff[i + 1]\n                int curr = (p - suff[i + 1]) % p;\n                // if we get complement\n                if (m.find(curr) != m.end()) {\n                    // remove elements from m[curr] + 1 to i\n                    ans = min(ans, i - m[curr]);\n                }\n            }\n            // this case will cover if we have to remove some last part of array.\n            if (sum % p == 0) {\n                ans = min(ans, n - 1 - i);\n            }\n            m[sum] = i;\n        }\n        return ans >= n ? -1 : ans;\n    }\n};\n"))),(0,a.kt)(d,{value:"java",label:"Java",mdxType:"TabItem"},(0,a.kt)(c,{name:"@darkhope",mdxType:"SolutionAuthor"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    int minSubarray(int[] nums, int p) {\n        int n = nums.length;\n        // suffix array of modulo\n        long suff[] = new long[n];\n        long sum = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            sum += nums[i];\n            suff[i] = sum % p;\n        }\n        // case if array is already divisible by p\n        if (sum % p == 0)\n            return 0;\n        Map<Long, Integer> m = new HashMap<>();\n        // defualt sum of array as none element is selected.\n        m.put((long)0, -1);\n        sum = 0;\n        // Final answer to be stored in ans.\n        int ans = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            sum += nums[i];\n            sum %= p;\n            if (i + 1 < n) {\n                // removing a subarray that doesn't involve last element\n                // complement of suff[i+1]\n                long curr = (p - suff[i + 1]) % p;\n                // if we get complement\n                if (m.containsKey(curr)) {\n                    // remove elements from m[curr]+1 to i\n                    ans = Math.min(ans, i - m.get(curr));\n                }\n            }\n            // this case will cover if we have to remove some last part of array.\n            if (sum == 0) {\n                ans = Math.min(ans, n - 1 - i);\n            }\n            m.put(sum, i);\n        }\n        return ans >= n ? -1 : ans;\n    }\n}\n")))))}h.isMDXComponent=!0}}]);