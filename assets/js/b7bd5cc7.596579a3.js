"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[51927],{3905:(t,e,n)=>{n.d(e,{Zo:()=>p,kt:()=>h});var r=n(67294);function i(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function a(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r)}return n}function o(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?a(Object(n),!0).forEach((function(e){i(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function s(t,e){if(null==t)return{};var n,r,i=function(t,e){if(null==t)return{};var n,r,i={},a=Object.keys(t);for(r=0;r<a.length;r++)n=a[r],e.indexOf(n)>=0||(i[n]=t[n]);return i}(t,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);for(r=0;r<a.length;r++)n=a[r],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(i[n]=t[n])}return i}var l=r.createContext({}),c=function(t){var e=r.useContext(l),n=e;return t&&(n="function"==typeof t?t(e):o(o({},e),t)),n},p=function(t){var e=c(t.components);return r.createElement(l.Provider,{value:e},t.children)},u="mdxType",d={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},m=r.forwardRef((function(t,e){var n=t.components,i=t.mdxType,a=t.originalType,l=t.parentName,p=s(t,["components","mdxType","originalType","parentName"]),u=c(n),m=i,h=u["".concat(l,".").concat(m)]||u[m]||d[m]||a;return n?r.createElement(h,o(o({ref:e},p),{},{components:n})):r.createElement(h,o({ref:e},p))}));function h(t,e){var n=arguments,i=e&&e.mdxType;if("string"==typeof t||i){var a=n.length,o=new Array(a);o[0]=m;var s={};for(var l in e)hasOwnProperty.call(e,l)&&(s[l]=e[l]);s.originalType=t,s[u]="string"==typeof t?t:i,o[1]=s;for(var c=2;c<a;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},71245:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>k,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var r=n(87462),i=(n(67294),n(3905));const a={description:"Author: @vigneshshiv, @radojicic23, @ColeB2 | https://leetcode.com/problems/letter-combinations-of-a-phone-number/",tags:["Hash Table","String","Backtracking"]},o="0017 - Letter Combinations of a Phone Number (Hard)",s={unversionedId:"0000-0099/letter-combinations-of-a-phone-number-medium",id:"0000-0099/letter-combinations-of-a-phone-number-medium",title:"0017 - Letter Combinations of a Phone Number (Hard)",description:"Author: @vigneshshiv, @radojicic23, @ColeB2 | https://leetcode.com/problems/letter-combinations-of-a-phone-number/",source:"@site/solutions/0000-0099/0017-letter-combinations-of-a-phone-number-medium.md",sourceDirName:"0000-0099",slug:"/0000-0099/letter-combinations-of-a-phone-number-medium",permalink:"/solutions/0000-0099/letter-combinations-of-a-phone-number-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0000-0099/0017-letter-combinations-of-a-phone-number-medium.md",tags:[{label:"Hash Table",permalink:"/solutions/tags/hash-table"},{label:"String",permalink:"/solutions/tags/string"},{label:"Backtracking",permalink:"/solutions/tags/backtracking"}],version:"current",sidebarPosition:17,frontMatter:{description:"Author: @vigneshshiv, @radojicic23, @ColeB2 | https://leetcode.com/problems/letter-combinations-of-a-phone-number/",tags:["Hash Table","String","Backtracking"]},sidebar:"tutorialSidebar",previous:{title:"0014 - Longest Common Prefix (Easy)",permalink:"/solutions/0000-0099/longest-common-prefix-easy"},next:{title:"0019 - Remove Nth Node From End of List (Easy)",permalink:"/solutions/0000-0099/remove-nth-node-from-end-of-list-medium"}},l={},c=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Recursive Backtracking with Subsets",id:"approach-1-recursive-backtracking-with-subsets",level:2},{value:"Approach 2: Recursive Backtracking with ASCII",id:"approach-2-recursive-backtracking-with-ascii",level:2},{value:"Approach 3: Iterative Backtracking",id:"approach-3-iterative-backtracking",level:2}],p=t=>function(e){return console.warn("Component "+t+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",e)},u=p("Tabs"),d=p("TabItem"),m=p("SolutionAuthor"),h={toc:c},g="wrapper";function k(t){let{components:e,...n}=t;return(0,i.kt)(g,(0,r.Z)({},h,n,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"0017---letter-combinations-of-a-phone-number-hard"},"0017 - Letter Combinations of a Phone Number (Hard)"),(0,i.kt)("h2",{id:"problem-link"},"Problem Link"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/letter-combinations-of-a-phone-number/"},"https://leetcode.com/problems/letter-combinations-of-a-phone-number/")),(0,i.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,i.kt)("p",null,"Given a string containing digits from ",(0,i.kt)("inlineCode",{parentName:"p"},"2-9")," inclusive, return all possible letter combinations that the number could represent. Return the answer in ",(0,i.kt)("strong",{parentName:"p"},"any order"),"."),(0,i.kt)("p",null,"A mapping of digits to letters (just like on the telephone buttons) is given below. Note that $1$ does not map to any letters."),(0,i.kt)("img",{src:"https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png",width:"300",height:"243"}),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 1:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input: digits = "23"\nOutput: ["ad","ae","af","bd","be","bf","cd","ce","cf"]\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 2:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input: digits = ""\nOutput: []\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example 3:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'Input: digits = ""\nOutput: ["a","b","c"]\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Constraints:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"0 <= digits.length <= 4")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"digits[i]")," is a digit in the range ",(0,i.kt)("inlineCode",{parentName:"li"},"['2', '9']"),".")),(0,i.kt)("h2",{id:"approach-1-recursive-backtracking-with-subsets"},"Approach 1: Recursive Backtracking with Subsets"),(0,i.kt)("p",null,"Simple and naive approach to solve this problem by having map of key and values same as Phone key pad. "),(0,i.kt)("p",null,"Iterative over the input digit by digit and for each digit look for the combinations of key characters. Initialize prefix string which holds an key combination in the recursive call stack. "),(0,i.kt)("p",null,"As per example 1, digits is $23$, for the first digit $2$, the program iterates over ",(0,i.kt)("inlineCode",{parentName:"p"},'"abc"')," characters, and for each char, the program is recursively called to get the next digit combination associated with current character ",(0,i.kt)("inlineCode",{parentName:"p"},"'a'"),". "),(0,i.kt)("p",null,"Maximum possibilities for each character is $4$, So each of recursive call, adds the char to the prefix string and add it to the result list, it does $O(n)$ time, and $O(4^n)$ recursive call stack for each character, where $n$ is the length of the string."),(0,i.kt)("p",null,"Time complexity: $O(n ^ n)$ or $O(n * 4^n)$"),(0,i.kt)("p",null,"Space complexity: $O(n^n)$ or $O(4 ^ n)$"),(0,i.kt)(u,{mdxType:"Tabs"},(0,i.kt)(d,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)(m,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'class Solution {\n    \n    private Map<Character, String> digitToChar = Map.of(\n            \'2\', "abc",\n            \'3\', "def",\n            \'4\', "ghi",\n            \'5\', "jkl",\n            \'6\', "mno",\n            \'7\', "pqrs",\n            \'8\', "tuv",\n            \'9\', "wxyz"\n    );\n    \n    public List<String> letterCombinations(String digits) {\n        if (digits.length() == 0) {\n            return new ArrayList<>();\n        }\n        List<String> result = new ArrayList();\n        backtrack(digits, result, "", 0);\n        return result;\n    }\n    \n    public void backtrack(String digits, List<String> result, String prefix, int index) {\n        if (prefix.length() == digits.length()) {\n            result.add(prefix);\n            return;\n        } else if (index >= digits.length()) {\n            return;\n        } else {\n            String digit = digitToChar.get(digits.charAt(index));\n            for (char c : digit.toCharArray()) {\n                backtrack(digits, result, prefix + c, index + 1);\n            }\n        }\n    }\n}\n'))),(0,i.kt)(d,{value:"py",label:"Python",mdxType:"TabItem"},(0,i.kt)(m,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        res = []\n        hashmap = {'2': 'abc', \n                   '3': 'def', \n                   '4': 'ghi', \n                   '5': 'jkl', \n                   '6': 'mno', \n                   '7': 'pqrs', \n                   '8': 'tuv', \n                   '9': 'wxyz'}\n                   \n        def backtrack(i, curr_str):\n            if len(curr_str) == len(digits):\n                res.append(curr_str)\n                return \n            for c in hashmap[digits[i]]:\n                backtrack(i + 1, curr_str + c)\n        if digits:\n            backtrack(0, \"\")\n        return res \n"))),(0,i.kt)(d,{value:"js",label:"JavaScript",mdxType:"TabItem"},(0,i.kt)(m,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"/**\n * @param {string} digits\n * @return {string[]}\n */\nvar letterCombinations = function(digits) {\n    let res = [];\n    const hashmap = {'2': 'abc', \n               '3': 'def', \n               '4': 'ghi', \n               '5': 'jkl', \n               '6': 'mno', \n               '7': 'pqrs', \n               '8': 'tuv', \n               '9': 'wxyz'};\n    \n    function backtrack(i, curr_str) {\n        if (curr_str.length == digits.length) {\n            res.push(curr_str);\n            return;\n        }\n        for (c of hashmap[digits[i]]) {\n            backtrack(i + 1, curr_str + c);\n        }\n    }\n    if (digits) {\n        backtrack(0, \"\");\n    }\n    return res;\n};\n"))),(0,i.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,i.kt)(m,{name:"@radojicic23",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'class Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> ans;\n        string currStr = "";\n        map<char, string> hashMap = {\n                {\'2\', "abc"}, \n                {\'3\', "def"}, \n                {\'4\', "ghi"}, \n                {\'5\', "jkl"}, \n                {\'6\', "mno"}, \n                {\'7\', "pqrs"}, \n                {\'8\', "tuv"}, \n                {\'9\', "wxyz"}\n        };\n        if (digits == "") return ans;\n        backtrack(digits, hashMap, ans, currStr, 0);\n        return ans;\n    }\n    void backtrack(string& digits, map<char, string>& hashMap, vector<string>& ans, string& currStr, int i) {\n        if (digits.size() == currStr.size()) {\n            ans.push_back(currStr);\n            return;\n        }\n        for (char c : hashMap[digits[i]]) {\n            currStr.push_back(c);\n            backtrack(digits, hashMap, ans, currStr, i + 1);\n            currStr.pop_back();\n        }\n    }\n};\n')))),(0,i.kt)("h2",{id:"approach-2-recursive-backtracking-with-ascii"},"Approach 2: Recursive Backtracking with ASCII"),(0,i.kt)("p",null,"Instead of having a map of characters for each digits, try to solve the problem only with numbers. "),(0,i.kt)("p",null,"Try to map every digits to ASCII combinations like $2$ is mapped ",(0,i.kt)("inlineCode",{parentName:"p"},'"abc"'),", How to get this from the number. "),(0,i.kt)("p",null,"Based on the input, we need to have a ",(0,i.kt)("strong",{parentName:"p"},"start and end range")," for each digit. To form ",(0,i.kt)("inlineCode",{parentName:"p"},"'a'")," from $2$, which number we can add to get ",(0,i.kt)("inlineCode",{parentName:"p"},"'a'"),", if we add $0$ with char ",(0,i.kt)("inlineCode",{parentName:"p"},"'a'")," then we will get the same char ",(0,i.kt)("inlineCode",{parentName:"p"},"'a'"),", like wise we need to form the range for other digits as well. "),(0,i.kt)("p",null,"For $7$ and $9$ key pads has 4 chars, so apply the logic by bit different as mentioned below in the program. "),(0,i.kt)("p",null,"Time and Space complexity is same as above."),(0,i.kt)(u,{mdxType:"Tabs"},(0,i.kt)(d,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)(m,{name:"@vigneshshiv",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    \n    public List<String> letterCombinations(String digits) {\n        if (digits.isEmpty()) {\n            return new ArrayList<>();\n        }\n        return letterCombinations(\"\", digits);\n    }\n    \n    public List<String> letterCombinations(String prefix, String digits) {\n        List<String> result = new ArrayList<>();\n        if (digits.isEmpty()) {\n            result.add(prefix);\n            return result;\n        }\n        // Transform char to number by subtracting '0' char (ASCII)\n        int digit = (int) digits.charAt(0) - '0';\n        // ASCII start range for the current digit\n        int start = digit > 7 ? (digit - 1) * 3 - 2 : (digit - 2) * 3;\n        // End range\n        int end = digit == 9 ? (digit * 3) - 1 : digit > 6 ? (digit * 3) - 2 : (digit - 1) * 3;\n        for (int i = start; i < end; i++) {\n            char ch = (char) ('a' + i);\n            result.addAll(letterCombinations(prefix + ch, digits.substring(1)));\n        }\n        return result;\n    }\n}\n")))),(0,i.kt)("h2",{id:"approach-3-iterative-backtracking"},"Approach 3: Iterative Backtracking"),(0,i.kt)("p",null,"We can utilize the same pricinple as above, just maintaining our own stack. At each step of our backtracking, we add to our stack, our current string plus 1 of the mapped letters and we do that for all mapped letters. When we run out of digits we can add to our return array the completed string."),(0,i.kt)("p",null,"Time Complexity: $$O(n * 4^n)$$ Where n is the length of the input string. In the worst case, (all 7s or 9s) we will have 4 choices of letters to choose from and for each output string we create will be of size $$n$$ and therefore take $$O(n)$$ time to create the string."),(0,i.kt)("p",null,"Space Complexity: $$O(4^n)$$. We will end up creating $$4^n$$ output strings to add to our return array."),(0,i.kt)(u,{mdxType:"Tabs"},(0,i.kt)(d,{value:"python",label:"Python",mdxType:"TabItem"},(0,i.kt)(m,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-py"},'class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        # base case, given empty input string, return early.\n        if not digits:\n            return []\n        # initialize our digit to letter map.\n        letter_map = {\n            "2": "abc",\n            "3": "def",\n            "4": "ghi",\n            "5": "jkl",\n            "6": "mno",\n            "7": "pqrs",\n            "8": "tuv",\n            "9": "wxyz"\n        }\n        # intiailize our return list, and stack.\n        letter_combos = []\n        # stack is formatted as (int, str)\n        # where the int is our index inside the digits string.\n        # and the str is the current string created so far.\n        stack = [(0, "")]\n\n        while stack:\n            # pop off the current index, and the current string.\n            idx, string = stack.pop()\n            # if we reached the end of the digits string.\n            if idx == len(digits):\n                # add to our return list, the string we created and continue.\n                letter_combos.append(string)\n                continue\n            # for each character that the current digit maps to:\n            for ch in letter_map[digits[idx]]:\n                # add to our backtracking stack\n                # the new index, which is idx + 1, and the new current\n                # string, which is the string + the character we mapped to.\n                stack.append((idx + 1, string + ch))\n        return letter_combos\n')))))}k.isMDXComponent=!0}}]);