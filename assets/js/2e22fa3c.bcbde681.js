"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[79324],{3905:function(n,t,e){e.d(t,{Zo:function(){return l},kt:function(){return m}});var a=e(67294);function i(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function r(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,a)}return e}function s(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?r(Object(e),!0).forEach((function(t){i(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}function o(n,t){if(null==n)return{};var e,a,i=function(n,t){if(null==n)return{};var e,a,i={},r=Object.keys(n);for(a=0;a<r.length;a++)e=r[a],t.indexOf(e)>=0||(i[e]=n[e]);return i}(n,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(a=0;a<r.length;a++)e=r[a],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(i[e]=n[e])}return i}var c=a.createContext({}),d=function(n){var t=a.useContext(c),e=t;return n&&(e="function"==typeof n?n(t):s(s({},t),n)),e},l=function(n){var t=d(n.components);return a.createElement(c.Provider,{value:t},n.children)},p={inlineCode:"code",wrapper:function(n){var t=n.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(n,t){var e=n.components,i=n.mdxType,r=n.originalType,c=n.parentName,l=o(n,["components","mdxType","originalType","parentName"]),u=d(e),m=i,g=u["".concat(c,".").concat(m)]||u[m]||p[m]||r;return e?a.createElement(g,s(s({ref:t},l),{},{components:e})):a.createElement(g,s({ref:t},l))}));function m(n,t){var e=arguments,i=t&&t.mdxType;if("string"==typeof n||i){var r=e.length,s=new Array(r);s[0]=u;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=n,o.mdxType="string"==typeof n?n:i,s[1]=o;for(var d=2;d<r;d++)s[d]=e[d];return a.createElement.apply(null,s)}return a.createElement.apply(null,e)}u.displayName="MDXCreateElement"},83612:function(n,t,e){e.r(t),e.d(t,{assets:function(){return l},contentTitle:function(){return c},default:function(){return f},frontMatter:function(){return o},metadata:function(){return d},toc:function(){return p}});var a=e(87462),i=e(63366),r=(e(67294),e(3905)),s=["components"],o={description:"Author: @wingkwong | https://leetcode.com/problems/palindrome-partitioning/",tags:["String","Dynamic Programming","Backtracking"]},c="0131 - Palindrome Partitioning (Medium)",d={unversionedId:"0100-0199/palindrome-partitioning-medium",id:"0100-0199/palindrome-partitioning-medium",title:"0131 - Palindrome Partitioning (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/palindrome-partitioning/",source:"@site/solutions/0100-0199/0131-palindrome-partitioning-medium.md",sourceDirName:"0100-0199",slug:"/0100-0199/palindrome-partitioning-medium",permalink:"/solutions/0100-0199/palindrome-partitioning-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0100-0199/0131-palindrome-partitioning-medium.md",tags:[{label:"String",permalink:"/solutions/tags/string"},{label:"Dynamic Programming",permalink:"/solutions/tags/dynamic-programming"},{label:"Backtracking",permalink:"/solutions/tags/backtracking"}],version:"current",sidebarPosition:131,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/palindrome-partitioning/",tags:["String","Dynamic Programming","Backtracking"]},sidebar:"tutorialSidebar",previous:{title:"0127 - Word Ladder (Hard)",permalink:"/solutions/0100-0199/word-ladder-hard"},next:{title:"0134 - Gas Station (Medium)",permalink:"/solutions/0100-0199/gas-station-medium"}},l={},p=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Backtracking",id:"approach-1-backtracking",level:2}],u=function(n){return function(t){return console.warn("Component "+n+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",t)}},m=u("Tabs"),g=u("TabItem"),k=u("SolutionAuthor"),b={toc:p};function f(n){var t=n.components,e=(0,i.Z)(n,s);return(0,r.kt)("wrapper",(0,a.Z)({},b,e,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"0131---palindrome-partitioning-medium"},"0131 - Palindrome Partitioning (Medium)"),(0,r.kt)("h2",{id:"problem-link"},"Problem Link"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/palindrome-partitioning/"},"https://leetcode.com/problems/palindrome-partitioning/")),(0,r.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.kt)("p",null,"Given a string ",(0,r.kt)("inlineCode",{parentName:"p"},"s"),", partition ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," such that every substring of the partition is a ",(0,r.kt)("strong",{parentName:"p"},"palindrome"),". Return ",(0,r.kt)("em",{parentName:"p"},"all possible palindrome partitioning of"),(0,r.kt)("inlineCode",{parentName:"p"},"s"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Input: s = "aab"\nOutput: [["a","a","b"],["aa","b"]]\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'Input: s = "a"\nOutput: [["a"]]\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Constraints:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"1 <= s.length <= 16")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"s")," contains only lowercase English letters.")),(0,r.kt)("h2",{id:"approach-1-backtracking"},"Approach 1: Backtracking"),(0,r.kt)(m,{mdxType:"Tabs"},(0,r.kt)(g,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)(k,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'class Solution {\npublic:\n    vector<vector<string>> partition(string s) {\n        // backtracking \n        // 1. define `ans` to hold `candidates`\n        vector<vector<string>> ans;\n        // 2. define `candidates` to hold all potential candidates (palindromic substring)\n        vector<string> candidates;\n        // 3. start backtrack from index 0\n        backtrack(s, ans, candidates, 0);\n        // 4. return ans\n        return ans;\n    }\n    \n     void backtrack(string s, vector<vector<string>>& ans, vector<string>& candidates, int start) {\n        // 1. check if the goal is fulfilled, \n        // i.e. reaching the end of string in this problem\n        if (start == s.size()) {\n            // if so, we push `candidates` to ans since we\'ve processed all characters\n            ans.push_back(candidates);\n            return;\n        }\n        // 2. find all potential candidates\n        for (int i = start; i < s.size(); i++) {\n            // we want to test all substrings, each substring is a potential candidate\n            // e.g. "aab" -> "a", "a", "b", "ab", "aa", "b", "aab"\n            string candidate = s.substr(start, i - start + 1);\n            // 3. check if the current candidate is palindrome or not \n            // if not, then we cannot push to `candidates`\n            if(!is_palindrome(candidate)) continue;\n            // 4. if so, push it to candidates\n            candidates.push_back(candidate);\n            // 5. backtrack with index + 1\n            backtrack(s, ans, candidates, i + 1);\n            // 6. remove the current substring from `candidates`\n            candidates.pop_back();\n        }\n    }\n    \n    \n    // there are different ways to check if `s` is palindrome \n    // here\'s my favourite one\n    bool is_palindrome(string s) {\n        return equal(s.begin(), s.begin() + s.size() / 2, s.rbegin());\n    }\n};\n'))),(0,r.kt)(g,{value:"java",label:"Java",mdxType:"TabItem"},(0,r.kt)(k,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'class Solution {\n    public List<List<String>> partition(String s) {\n        // backtracking \n        // 1. define `ans` to hold `candidates`\n        List<List<String>> ans = new ArrayList<>();\n        // 2. define `candidates` to hold all potential candidates (palindromic substring)\n        List<String> candidates = new ArrayList<>();\n        // 3. start backtrack from index 0\n        backtrack(s, ans, candidates, 0);\n        // 4. return ans\n        return ans;\n    }\n    \n    private void backtrack(String s, List<List<String>> ans, List<String> candidates, int start) {\n        // 1. check if the goal is fulfilled, \n        // i.e. reaching the end of string in this problem\n        if (start == s.length()) {\n            ans.add(new ArrayList<>(candidates));\n            return;\n        }\n        // 2. find all potential candidates\n        for (int i = start; i < s.length(); i++) {\n            // we want to test all substrings, each substring is a potential candidate\n            // e.g. "aab" -> "a", "a", "b", "ab", "aa", "b", "aab"\n            String candidate = s.substring(start, i + 1);\n            // 3. check if the current candidate is palindrome or not \n            // if not, then we cannot push to `candidates`\n            if (!isPalindrome(candidate)) continue;\n            // 4. if so, push it to candidates\n            candidates.add(candidate);\n            // 5. backtrack with index + 1\n            backtrack(s, ans, candidates, i + 1);\n            // 6. remove the current substring from `candidates`\n            candidates.remove(candidates.size() - 1);\n        }\n    }\n    \n    // there are different ways to check if `s` is palindrome \n    // here\'s one of the ways\n    private boolean isPalindrome(String s) {\n        return new StringBuilder(s).reverse().toString().equals(s);\n    }\n}\n'))),(0,r.kt)(g,{value:"py",label:"Python",mdxType:"TabItem"},(0,r.kt)(k,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        def is_palindrome(s):\n            return s == s[::-1]\n    \n        def backtrack(s, ans, candidates, start):\n            # 1. check if the goal is fulfilled, \n            # i.e. reaching the end of string in this problem\n            if start == len(s):\n                # if so, we push `candidates` to ans since we\'ve processed all characters\n                ans.append(list(candidates))\n                return\n            # 2. find all potential candidates\n            for i in range(start, len(s)):\n                # we want to test all substrings, each substring is a potential candidate\n                # e.g. "aab" -> "a", "a", "b", "ab", "aa", "b", "aab"\n                candidate = s[start:i+1]\n                # 3. check if the current candidate is palindrome or not \n                # if not, then we cannot push to `candidates`\n                if not is_palindrome(candidate):\n                    continue\n                # 4. if so, push it to candidates\n                candidates.append(candidate)\n                # 5. backtrack with index + 1\n                backtrack(s, ans, candidates, i + 1)\n                # 6. remove the current substring from `candidates`\n                candidates.pop()\n\n        # backtracking \n        # 1. define `ans` to hold `candidates`\n        ans = []\n        # 2. define `candidates` to hold all potential candidates (palindromic substring)\n        candidates = []\n        # 3. start backtrack from index 0\n        backtrack(s, ans, candidates, 0)\n        # 4. return ans\n        return ans\n'))),(0,r.kt)(g,{value:"rs",label:"Rust",mdxType:"TabItem"},(0,r.kt)(k,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rs"},'impl Solution {\n    fn partition(s: String) -> Vec<Vec<String>> {\n        // backtracking \n        // 1. define `ans` to hold `candidates`\n        let mut ans = Vec::new();\n        // 2. define `candidates` to hold all potential candidates (palindromic substring)\n        let mut candidates = Vec::new();\n        // 3. start backtrack from index 0\n        Solution::backtrack(&s, &mut ans, &mut candidates, 0);\n        // 4. return ans\n        ans\n    }\n\n    fn backtrack(s: &String, ans: &mut Vec<Vec<String>>, candidates: &mut Vec<String>, start: usize) {\n        // 1. check if the goal is fulfilled, \n        // i.e. reaching the end of string in this problem\n        if start == s.len() {\n            // if so, we push `candidates` to ans since we\'ve processed all characters\n            ans.push(candidates.clone());\n            return;\n        }\n        // 2. find all potential candidates\n        for i in start..s.len() {\n            // we want to test all substrings, each substring is a potential candidate\n            // e.g. "aab" -> "a", "a", "b", "ab", "aa", "b", "aab"\n            let candidate = &s[start .. i + 1];\n            // 3. check if the current candidate is palindrome or not \n            // if not, then we cannot push to `candidates`\n            if !Solution::is_palindrome(candidate) {\n                continue;\n            }\n            // 4. if so, push it to candidates\n            candidates.push(candidate.to_string());\n            // 5. backtrack with index + 1\n            Solution::backtrack(s, ans, candidates, i + 1);\n            // 6. remove the current substring from `candidates`\n            candidates.pop();\n        }\n    }\n\n    fn is_palindrome(s: &str) -> bool {\n        s.chars().eq(s.chars().rev())\n    }\n}\n\n')))))}f.isMDXComponent=!0}}]);