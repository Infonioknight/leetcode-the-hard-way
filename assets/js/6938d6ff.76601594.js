"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[48273],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>d});var a=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var m=a.createContext({}),u=function(e){var n=a.useContext(m),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=u(e.components);return a.createElement(m.Provider,{value:n},e.children)},p="mdxType",s={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,m=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=u(t),h=o,d=p["".concat(m,".").concat(h)]||p[h]||s[h]||r;return t?a.createElement(d,i(i({ref:n},c),{},{components:t})):a.createElement(d,i({ref:n},c))}));function d(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=h;var l={};for(var m in n)hasOwnProperty.call(n,m)&&(l[m]=n[m]);l.originalType=e,l[p]="string"==typeof e?e:o,i[1]=l;for(var u=2;u<r;u++)i[u]=t[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},35280:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>i,default:()=>g,frontMatter:()=>r,metadata:()=>l,toc:()=>u});var a=t(87462),o=(t(67294),t(3905));const r={description:"Author: @ColeB2 | https://leetcode.com/problems/coin-change/",tags:["Array","Dynamic Programming","Breadth-First Search"]},i="0322 - Coin Change (Medium)",l={unversionedId:"0300-0399/coin-change-medium",id:"0300-0399/coin-change-medium",title:"0322 - Coin Change (Medium)",description:"Author: @ColeB2 | https://leetcode.com/problems/coin-change/",source:"@site/solutions/0300-0399/0322-coin-change-medium.md",sourceDirName:"0300-0399",slug:"/0300-0399/coin-change-medium",permalink:"/solutions/0300-0399/coin-change-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0300-0399/0322-coin-change-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Dynamic Programming",permalink:"/solutions/tags/dynamic-programming"},{label:"Breadth-First Search",permalink:"/solutions/tags/breadth-first-search"}],version:"current",sidebarPosition:322,frontMatter:{description:"Author: @ColeB2 | https://leetcode.com/problems/coin-change/",tags:["Array","Dynamic Programming","Breadth-First Search"]},sidebar:"tutorialSidebar",previous:{title:"0312 - Burst Balloons (Hard)",permalink:"/solutions/0300-0399/burst-balloons-hard"},next:{title:"0323 - Number of Connected Components in an Undirected Graph (Medium)",permalink:"/solutions/0300-0399/number-of-connected-components-in-an-undirected-graph-medium"}},m={},u=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Dynamic Programming",id:"approach-1-dynamic-programming",level:2}],c=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",n)},p=c("Tabs"),s=c("TabItem"),h=c("SolutionAuthor"),d={toc:u},f="wrapper";function g(e){let{components:n,...t}=e;return(0,o.kt)(f,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"0322---coin-change-medium"},"0322 - Coin Change (Medium)"),(0,o.kt)("h2",{id:"problem-link"},"Problem Link"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/coin-change/"},"https://leetcode.com/problems/coin-change/")),(0,o.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,o.kt)("p",null,"You are given an integer array ",(0,o.kt)("inlineCode",{parentName:"p"},"coins")," representing coins of different denominations and an integer ",(0,o.kt)("inlineCode",{parentName:"p"},"amount")," representing a total amount of money."),(0,o.kt)("p",null,"Return ",(0,o.kt)("em",{parentName:"p"},"the fewest number of coins that you need to make up that amount"),". If that amount of money cannot be made up by any combination of the coins, return ",(0,o.kt)("inlineCode",{parentName:"p"},"-1"),"."),(0,o.kt)("p",null,"You may assume that you have an infinite number of each kind of coin."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 1:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 2:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: coins = [2], amount = 3\nOutput: -1\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 3:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Input: coins = [1], amount = 0\nOutput: 0\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Constraints:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"1 <= coins.length <= 12")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"1 <= coins[i] <= 2^31 - 1")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"0 <= amount <= 10^4"))),(0,o.kt)("h2",{id:"approach-1-dynamic-programming"},"Approach 1: Dynamic Programming"),(0,o.kt)("p",null,"We can create a $$dp$$ array of length $$amount + 1$$ to represent all the ways we can make change from $$0$$ to $$amount$$, then solve the ways we can make each amount. "),(0,o.kt)("p",null,"We can do this by initializing the array with a number larger than the amount ($$amount$$ using all $$1$$ coins would reach size $$amount$$), and give the $$0$$ position of the array a value of $$0$$."),(0,o.kt)("p",null,"Then we can loop through all amounts, and for each amount, loop through all the coins, and updating the amount at that position with either its current value, $$dp","[i]","$$ or the value from $$amount - coin$$ incremented by $$1$$."),(0,o.kt)("p",null,"Time Complexity: $$O(amount + len(coins))$$. We are going to iterate over each amount, and for each amount, iterate through each coin."),(0,o.kt)("p",null,"Space Complexity: $$O(amount)$$. We are going to create an array of size $$amount$$ to hold the number of ways we can create each amount."),(0,o.kt)(p,{mdxType:"Tabs"},(0,o.kt)(s,{value:"python",label:"Python",mdxType:"TabItem"},(0,o.kt)(h,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # initialize dp array, we will use float('inf') as an initial\n        # value, any value over the largest value of amount would work.\n        # The array shows the number of ways we can make coins for each\n        # value from 0 to amount + 1, which would be our amount.\n        dp = [float('inf')] * (amount + 1)\n        # The number of ways we can make change for 0.\n        dp[0] = 0\n        # loop over the dp array, we already handled 0.\n        for i in range(1, len(dp)):\n            # loop through each coin\n            for coin in coins:\n                # i - coin is >= 0, we can use it to determine amount\n                if i - coin >= 0:\n                    # the way to make coins will be either the min of\n                    # the current way to make coins, dp[i] or\n                    # the number of ways it took to make coins at the \n                    # current amount minus the coin we are using + 1.\n                    dp[i] = min(dp[i], 1 + dp[i-coin])\n        # return the last number in the array, which will be amount.\n        # do so iff that amount does not equal inf.\n        return dp[-1] if dp[-1] != float('inf') else -1\n")))))}g.isMDXComponent=!0}}]);