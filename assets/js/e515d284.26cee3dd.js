"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[93387],{3905:(n,a,e)=>{e.d(a,{Zo:()=>s,kt:()=>b});var r=e(67294);function t(n,a,e){return a in n?Object.defineProperty(n,a,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[a]=e,n}function u(n,a){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);a&&(r=r.filter((function(a){return Object.getOwnPropertyDescriptor(n,a).enumerable}))),e.push.apply(e,r)}return e}function m(n){for(var a=1;a<arguments.length;a++){var e=null!=arguments[a]?arguments[a]:{};a%2?u(Object(e),!0).forEach((function(a){t(n,a,e[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):u(Object(e)).forEach((function(a){Object.defineProperty(n,a,Object.getOwnPropertyDescriptor(e,a))}))}return n}function i(n,a){if(null==n)return{};var e,r,t=function(n,a){if(null==n)return{};var e,r,t={},u=Object.keys(n);for(r=0;r<u.length;r++)e=u[r],a.indexOf(e)>=0||(t[e]=n[e]);return t}(n,a);if(Object.getOwnPropertySymbols){var u=Object.getOwnPropertySymbols(n);for(r=0;r<u.length;r++)e=u[r],a.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(t[e]=n[e])}return t}var l=r.createContext({}),o=function(n){var a=r.useContext(l),e=a;return n&&(e="function"==typeof n?n(a):m(m({},a),n)),e},s=function(n){var a=o(n.components);return r.createElement(l.Provider,{value:a},n.children)},c="mdxType",p={inlineCode:"code",wrapper:function(n){var a=n.children;return r.createElement(r.Fragment,{},a)}},d=r.forwardRef((function(n,a){var e=n.components,t=n.mdxType,u=n.originalType,l=n.parentName,s=i(n,["components","mdxType","originalType","parentName"]),c=o(e),d=t,b=c["".concat(l,".").concat(d)]||c[d]||p[d]||u;return e?r.createElement(b,m(m({ref:a},s),{},{components:e})):r.createElement(b,m({ref:a},s))}));function b(n,a){var e=arguments,t=a&&a.mdxType;if("string"==typeof n||t){var u=e.length,m=new Array(u);m[0]=d;var i={};for(var l in a)hasOwnProperty.call(a,l)&&(i[l]=a[l]);i.originalType=n,i[c]="string"==typeof n?n:t,m[1]=i;for(var o=2;o<u;o++)m[o]=e[o];return r.createElement.apply(null,m)}return r.createElement.apply(null,e)}d.displayName="MDXCreateElement"},18052:(n,a,e)=>{e.r(a),e.d(a,{assets:()=>l,contentTitle:()=>m,default:()=>k,frontMatter:()=>u,metadata:()=>i,toc:()=>o});var r=e(87462),t=(e(67294),e(3905));const u={description:"Author: @wingkwong | https://leetcode.com/problems/maximum-sum-circular-subarray/",tags:["Array","Divide and Conquer","Dynamic Programming","Queue","Monotonic Queue"]},m="0918 - Maximum Sum Circular Subarray (Medium)",i={unversionedId:"0900-0999/maximum-sum-circular-subarray-medium",id:"0900-0999/maximum-sum-circular-subarray-medium",title:"0918 - Maximum Sum Circular Subarray (Medium)",description:"Author: @wingkwong | https://leetcode.com/problems/maximum-sum-circular-subarray/",source:"@site/solutions/0900-0999/0918-maximum-sum-circular-subarray-medium.md",sourceDirName:"0900-0999",slug:"/0900-0999/maximum-sum-circular-subarray-medium",permalink:"/solutions/0900-0999/maximum-sum-circular-subarray-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0900-0999/0918-maximum-sum-circular-subarray-medium.md",tags:[{label:"Array",permalink:"/solutions/tags/array"},{label:"Divide and Conquer",permalink:"/solutions/tags/divide-and-conquer"},{label:"Dynamic Programming",permalink:"/solutions/tags/dynamic-programming"},{label:"Queue",permalink:"/solutions/tags/queue"},{label:"Monotonic Queue",permalink:"/solutions/tags/monotonic-queue"}],version:"current",sidebarPosition:918,frontMatter:{description:"Author: @wingkwong | https://leetcode.com/problems/maximum-sum-circular-subarray/",tags:["Array","Divide and Conquer","Dynamic Programming","Queue","Monotonic Queue"]},sidebar:"tutorialSidebar",previous:{title:"0912 - Sort an Array (Medium)",permalink:"/solutions/0900-0999/sort-an-array-medium"},next:{title:"0926 - Flip String to Monotone Increasing (Medium)",permalink:"/solutions/0900-0999/flip-string-to-monotone-increasing-medium"}},l={},o=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Kadane&#39;s Algorithm",id:"approach-1-kadanes-algorithm",level:2}],s=n=>function(a){return console.warn("Component "+n+" was not imported, exported, or provided by MDXProvider as global scope"),(0,t.kt)("div",a)},c=s("Tabs"),p=s("TabItem"),d=s("SolutionAuthor"),b={toc:o},y="wrapper";function k(n){let{components:a,...e}=n;return(0,t.kt)(y,(0,r.Z)({},b,e,{components:a,mdxType:"MDXLayout"}),(0,t.kt)("h1",{id:"0918---maximum-sum-circular-subarray-medium"},"0918 - Maximum Sum Circular Subarray (Medium)"),(0,t.kt)("h2",{id:"problem-link"},"Problem Link"),(0,t.kt)("p",null,(0,t.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/maximum-sum-circular-subarray/"},"https://leetcode.com/problems/maximum-sum-circular-subarray/")),(0,t.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,t.kt)("p",null,"Given a ",(0,t.kt)("strong",{parentName:"p"},"circular integer array")," ",(0,t.kt)("inlineCode",{parentName:"p"},"nums")," of length ",(0,t.kt)("inlineCode",{parentName:"p"},"n"),", return ",(0,t.kt)("em",{parentName:"p"},"the maximum possible sum of a non-empty ",(0,t.kt)("strong",{parentName:"em"},"subarray")," of"),(0,t.kt)("inlineCode",{parentName:"p"},"nums"),"."),(0,t.kt)("p",null,"A ",(0,t.kt)("strong",{parentName:"p"},"circular array")," means the end of the array connects to the beginning of the array. Formally, the next element of ",(0,t.kt)("inlineCode",{parentName:"p"},"nums[i]")," is ",(0,t.kt)("inlineCode",{parentName:"p"},"nums[(i + 1) % n]")," and the previous element of ",(0,t.kt)("inlineCode",{parentName:"p"},"nums[i]")," is ",(0,t.kt)("inlineCode",{parentName:"p"},"nums[(i - 1 + n) % n]"),"."),(0,t.kt)("p",null,"A ",(0,t.kt)("strong",{parentName:"p"},"subarray")," may only include each element of the fixed buffer ",(0,t.kt)("inlineCode",{parentName:"p"},"nums")," at most once. Formally, for a subarray ",(0,t.kt)("inlineCode",{parentName:"p"},"nums[i], nums[i + 1], ..., nums[j]"),", there does not exist ",(0,t.kt)("inlineCode",{parentName:"p"},"i <= k1"),", ",(0,t.kt)("inlineCode",{parentName:"p"},"k2 <= j")," with ",(0,t.kt)("inlineCode",{parentName:"p"},"k1 % n == k2 % n"),"."),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Example 1:")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre"},"Input: nums = [1,-2,3,-2]\nOutput: 3\nExplanation: Subarray [3] has maximum sum 3.\n")),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Example 2:")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre"},"Input: nums = [5,-3,5]\nOutput: 10\nExplanation: Subarray [5,5] has maximum sum 5 + 5 = 10.\n")),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Example 3:")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre"},"Input: nums = [-3,-2,-3]\nOutput: -2\nExplanation: Subarray [-2] has maximum sum -2.\n")),(0,t.kt)("p",null,(0,t.kt)("strong",{parentName:"p"},"Constraints:")),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"n == nums.length")),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"1 <= n <= 3 * 10^4")),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("inlineCode",{parentName:"li"},"-3 * 10^4 <= nums[i] <= 3 * 10^4"))),(0,t.kt)("h2",{id:"approach-1-kadanes-algorithm"},"Approach 1: Kadane's Algorithm"),(0,t.kt)(c,{mdxType:"Tabs"},(0,t.kt)(p,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,t.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    // kadane's algo\n   int kadane(vector<int>& nums) {\n        int local = nums[0], global = nums[0];\n        for (int i = 1; i < nums.size(); i++) {\n            local = max(nums[i], local + nums[i]);\n            global = max(global, local);\n        }\n        return global;\n    }\n    \n    // case 1: max subarray sum in [0 .. n - 1]\n    // i.e. kadane's algo\n    // case 2. circular subarray in [0 .. |  n - 1 .. | .. 2 * n - 1]\n    // i.e. total sum - min subarray sum in [0 .. n - 1]\n    int maxSubarraySumCircular(vector<int>& nums) {\n        // use kadane's algo to find out max sub array sum (case 1)\n        int maxSubArraySum = kadane(nums);\n        // handle cases like [-3,-2,-3]\n        if (maxSubArraySum < 0) return maxSubArraySum;\n        // calculate the total sum\n        int totalSum = accumulate(nums.begin(), nums.end(), 0);\n        // in order to use the same kadane function, we flip the sign\n        for (auto &x : nums) x *= -1;\n        // use kadane's algo to find out min sub array sum\n        int minSubArraySum = kadane(nums) * -1;\n        // compare case 1 & case 2, take the max\n        return max(maxSubArraySum, totalSum - minSubArraySum);\n    }\n};\n"))),(0,t.kt)(p,{value:"java",label:"Java",mdxType:"TabItem"},(0,t.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-java"},"class Solution {\n    // kadane's algo\n    public int kadane(int[] nums) {\n        int local = nums[0];\n        int global = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            local = Math.max(nums[i], local + nums[i]);\n            global = Math.max(global, local);\n        }\n        return global;\n    }\n\n    // case 1: max subarray sum in [0 .. n - 1]\n    // i.e. kadane's algo\n    // case 2. circular subarray in [0 .. |  n - 1 .. | .. 2 * n - 1]\n    // i.e. total sum - min subarray sum in [0 .. n - 1]\n    public int maxSubarraySumCircular(int[] nums) {\n        int n = nums.length;\n        // use kadane's algo to find out max sub array sum (case 1)\n        int maxSubArraySum = kadane(nums);\n        // handle cases like [-3,-2,-3]\n        if (maxSubArraySum < 0) return maxSubArraySum;\n        // calculate the total sum\n        int totalSum = 0;\n        // in order to use the same kadane function, we flip the sign\n        for (int i = 0; i < n; i++) {\n            totalSum += nums[i];\n            nums[i] = -nums[i];\n        }\n        // use kadane's algo to find out min sub array sum\n        int minSubArraySum = kadane(nums);\n        // compare case 1 & case 2, take the max\n        return Math.max(maxSubArraySum, totalSum + minSubArraySum);\n    }\n}\n\n"))),(0,t.kt)(p,{value:"py",label:"Python",mdxType:"TabItem"},(0,t.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-py"},"class Solution:\n    def maxSubarraySumCircular(self, nums):\n        # kadane's algo\n        def kadane(nums):\n            local_sum = nums[0]\n            global_sum = nums[0]\n            for i in range(1, len(nums)):\n                local_sum = max(nums[i], local_sum + nums[i])\n                global_sum = max(global_sum, local_sum)\n            return global_sum\n        # case 1: max subarray sum in [0 .. n - 1]\n        # i.e. kadane's algo\n        # case 2. circular subarray in [0 .. |  n - 1 .. | .. 2 * n - 1]\n        # i.e. total sum - min subarray sum in [0 .. n - 1]\n        n = len(nums)\n        # use kadane's algo to find out max sub array sum (case 1)\n        max_sub_array_sum = kadane(nums)\n        # handle cases like [-3,-2,-3]\n        if max_sub_array_sum < 0:\n            return max_sub_array_sum\n        # calculate the total sum\n        total_sum = sum(nums)\n        # in order to use the same kadane function, we flip the sign\n        for i in range(n):\n            nums[i] *= -1\n        # use kadane's algo to find out min sub array sum\n        min_sub_array_sum = kadane(nums) * -1\n        # compare case 1 & case 2, take the max\n        return max(max_sub_array_sum, total_sum - min_sub_array_sum)\n\n"))),(0,t.kt)(p,{value:"rs",label:"Rust",mdxType:"TabItem"},(0,t.kt)(d,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-rs"},"use std::cmp::max;\n\nimpl Solution {\n    // kadane's algo\n    fn kadane(nums: &Vec<i32>) -> i32 {\n        let mut local = nums[0];\n        let mut global = nums[0];\n        for i in 1..nums.len() {\n            local = max(nums[i], local + nums[i]);\n            global = max(global, local);\n        }\n        return global;\n    }\n\n    // case 1: max subarray sum in [0 .. n - 1]\n    // i.e. kadane's algo\n    // case 2. circular subarray in [0 .. |  n - 1 .. | .. 2 * n - 1]\n    // i.e. total sum - min subarray sum in [0 .. n - 1]\n    fn max_subarray_sum_circular(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        // use kadane's algo to find out max sub array sum (case 1)\n        let max_sub_array_sum = Solution::kadane(&nums);\n        // handle cases like [-3,-2,-3]\n        if max_sub_array_sum < 0 {\n            return max_sub_array_sum;\n        }\n        // calculate the total sum\n        let total_sum: i32 = nums.iter().sum();\n        let mut nums = nums.clone();\n        for i in 0 .. n {\n            nums[i] = -nums[i];\n        }\n        // use kadane's algo to find out min sub array sum\n        let min_sub_array_sum = Solution::kadane(&nums);\n        // compare case 1 & case 2, take the max\n        return max(max_sub_array_sum, total_sum + min_sub_array_sum);\n    }\n\n}\n")))))}k.isMDXComponent=!0}}]);