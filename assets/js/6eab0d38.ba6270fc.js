"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[4640],{3905:function(e,t,n){n.d(t,{Zo:function(){return h},kt:function(){return p}});var l=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);t&&(l=l.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,l)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,l,o=function(e,t){if(null==e)return{};var n,l,o={},r=Object.keys(e);for(l=0;l<r.length;l++)n=r[l],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(l=0;l<r.length;l++)n=r[l],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=l.createContext({}),u=function(e){var t=l.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},h=function(e){var t=u(e.components);return l.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return l.createElement(l.Fragment,{},t)}},s=l.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,h=i(e,["components","mdxType","originalType","parentName"]),s=u(n),p=o,d=s["".concat(c,".").concat(p)]||s[p]||m[p]||r;return n?l.createElement(d,a(a({ref:t},h),{},{components:n})):l.createElement(d,a({ref:t},h))}));function p(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,a=new Array(r);a[0]=s;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:o,a[1]=i;for(var u=2;u<r;u++)a[u]=n[u];return l.createElement.apply(null,a)}return l.createElement.apply(null,n)}s.displayName="MDXCreateElement"},32433:function(e,t,n){n.r(t),n.d(t,{assets:function(){return h},contentTitle:function(){return c},default:function(){return g},frontMatter:function(){return i},metadata:function(){return u},toc:function(){return m}});var l=n(87462),o=n(63366),r=(n(67294),n(3905)),a=["components"],i={description:"Author: @TBC | https://leetcode.com/problems/where-will-the-ball-fall/",tags:["Array","Dynamic Programming","Depth-First Search","Matrix","Simulation"]},c="1706 - Where Will the Ball Fall (Medium)",u={unversionedId:"1700-1799/where-will-the-ball-fall-medium",id:"1700-1799/where-will-the-ball-fall-medium",title:"1706 - Where Will the Ball Fall (Medium)",description:"Author: @TBC | https://leetcode.com/problems/where-will-the-ball-fall/",source:"@site/solutions/1700-1799/1706-where-will-the-ball-fall-medium.md",sourceDirName:"1700-1799",slug:"/1700-1799/where-will-the-ball-fall-medium",permalink:"/leetcode-the-hard-way/solutions/1700-1799/where-will-the-ball-fall-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/1700-1799/1706-where-will-the-ball-fall-medium.md",tags:[{label:"Array",permalink:"/leetcode-the-hard-way/solutions/tags/array"},{label:"Dynamic Programming",permalink:"/leetcode-the-hard-way/solutions/tags/dynamic-programming"},{label:"Depth-First Search",permalink:"/leetcode-the-hard-way/solutions/tags/depth-first-search"},{label:"Matrix",permalink:"/leetcode-the-hard-way/solutions/tags/matrix"},{label:"Simulation",permalink:"/leetcode-the-hard-way/solutions/tags/simulation"}],version:"current",sidebarPosition:1706,frontMatter:{description:"Author: @TBC | https://leetcode.com/problems/where-will-the-ball-fall/",tags:["Array","Dynamic Programming","Depth-First Search","Matrix","Simulation"]},sidebar:"tutorialSidebar",previous:{title:"1700 - 1799",permalink:"/leetcode-the-hard-way/solutions/category/1700---1799"},next:{title:"1748 - Sum of Unique Elements (Easy)",permalink:"/leetcode-the-hard-way/solutions/1700-1799/sum-of-unique-elements-easy"}},h={},m=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Simulation",id:"approach-1-simulation",level:2}],s=function(e){return function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",t)}},p=s("Tabs"),d=s("TabItem"),b=s("SolutionAuthor"),f={toc:m};function g(e){var t=e.components,n=(0,o.Z)(e,a);return(0,r.kt)("wrapper",(0,l.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"1706---where-will-the-ball-fall-medium"},"1706 - Where Will the Ball Fall (Medium)"),(0,r.kt)("h2",{id:"problem-link"},"Problem Link"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/where-will-the-ball-fall/"},"https://leetcode.com/problems/where-will-the-ball-fall/")),(0,r.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,r.kt)("p",null,"You have a 2-D ",(0,r.kt)("inlineCode",{parentName:"p"},"grid")," of size ",(0,r.kt)("inlineCode",{parentName:"p"},"m x n")," representing a box, and you have ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," balls. The box is open on the top and bottom sides."),(0,r.kt)("p",null,"Each cell in the box has a diagonal board spanning two corners of the cell that can redirect a ball to the right or to the left."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A board that redirects the ball to the right spans the top-left corner to the bottom-right corner and is represented in the grid as ",(0,r.kt)("inlineCode",{parentName:"li"},"1"),"."),(0,r.kt)("li",{parentName:"ul"},"A board that redirects the ball to the left spans the top-right corner to the bottom-left corner and is represented in the grid as ",(0,r.kt)("inlineCode",{parentName:"li"},"-1"),".")),(0,r.kt)("p",null,'We drop one ball at the top of each column of the box. Each ball can get stuck in the box or fall out of the bottom. A ball gets stuck if it hits a "V" shaped pattern between two boards or if a board redirects the ball into either wall of the box.'),(0,r.kt)("p",null,"Return ",(0,r.kt)("em",{parentName:"p"},"an array"),(0,r.kt)("inlineCode",{parentName:"p"},"answer"),(0,r.kt)("em",{parentName:"p"},"of size"),(0,r.kt)("inlineCode",{parentName:"p"},"n"),(0,r.kt)("em",{parentName:"p"},"where"),(0,r.kt)("inlineCode",{parentName:"p"},"answer[i]"),(0,r.kt)("em",{parentName:"p"},"is the column that the ball falls out of at the bottom after dropping the ball from the"),(0,r.kt)("inlineCode",{parentName:"p"},"ith"),(0,r.kt)("em",{parentName:"p"},"column at the top, or -1 if the ball gets stuck in the box.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 1:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]\nOutput: [1,-1,-1,-1,-1]\nExplanation: This example is shown in the photo.\nBall b0 is dropped at column 0 and falls out of the box at column 1.\nBall b1 is dropped at column 1 and will get stuck in the box between column 2 and 3 and row 1.\nBall b2 is dropped at column 2 and will get stuck on the box between column 2 and 3 and row 0.\nBall b3 is dropped at column 3 and will get stuck on the box between column 2 and 3 and row 0.\nBall b4 is dropped at column 4 and will get stuck on the box between column 2 and 3 and row 1.\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 2:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: grid = [[-1]]\nOutput: [-1]\nExplanation: The ball gets stuck against the left wall.\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Example 3:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Input: grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]\nOutput: [0,1,2,3,4,-1]\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Constraints:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"m == grid.length")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"n == grid[i].length")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"1 <= m, n <= 100")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"grid[i][j]")," is ",(0,r.kt)("inlineCode",{parentName:"li"},"1")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"-1"),".")),(0,r.kt)("h2",{id:"approach-1-simulation"},"Approach 1: Simulation"),(0,r.kt)(p,{mdxType:"Tabs"},(0,r.kt)(d,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)(b,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// Time Complexity: O(m * n)\n// Space Complexity: O(n)\nclass Solution {\npublic:\n    // idea: we can simulate the movement of each ball\n    // if a ball is stuck at some point, then it would be -1\n    // otherwise, get the final destination column\n    vector<int> findBall(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        vector<int> ans;\n        // iterate each column\n        for (int col = 0; col < n; col++) {\n            int cur_col = col;\n            // iterate each row\n            for (int cur_row = 0; cur_row < m; cur_row++) {\n                // the next column would be the current column + the value of the current cell\n                // e.g. column 0 + 1 = column 1 (move to the right)\n                // e.g. column 3 - 1 = column 2 (move to the left)\n                int next_col = cur_col + grid[cur_row][cur_col];\n                // after that we need to check if the ball gets stuck at the same column\n                // and there are three cases\n                // 1. the ball on the leftmost column is moving to the left\n                // hence, we check `next_col < 0`\n                // 2. the ball on the rightmost column is moving to the right\n                // hence, we check `next_col >= n`\n                // 3. the ball is stuck at a V shape position\n                // e.g. ball 2 and ball 3 in column 2 and column 3 in row 0\n                // hence, we check if the if grid[cur_row][cur_col] is different than grid[cur_row][next_col]\n                if (next_col < 0 || next_col >= n || grid[cur_row][cur_col] ^ grid[cur_row][next_col]) {\n                    // the ball is stuck at some point, which means it couldn't reach to the end\n                    // hence, we can set -1 and break here\n                    cur_col = -1;\n                    break;\n                }\n                // continue the above process with the updated cur_col\n                cur_col = next_col;\n            }\n            // the ball reaches to the end,\n            // cur_col is the final destination\n            ans.push_back(cur_col);\n        }\n        return ans;\n    }\n};\n"))),(0,r.kt)(d,{value:"py",label:"Python",mdxType:"TabItem"},(0,r.kt)(b,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},"# Time Complexity: O(m * n)\n# Space Complexity: O(n)\nclass Solution:\n    # idea: we can simulate the movement of each ball\n    # if a ball is stuck at some point, then it would be -1\n    # otherwise, get the final destination column\n    def findBall(self, grid: List[List[int]]) -> List[int]:\n        m, n = len(grid), len(grid[0])\n        ans = []\n        # iterate each column\n        for col in range(n):\n            cur_col = col\n            # iterate each row\n            for cur_row in range(m):\n                # the next column would be the current column + the value of the current cell\n                # e.g. column 0 + 1 = column 1 (move to the right)\n                # e.g. column 3 - 1 = column 2 (move to the left)\n                next_col = cur_col + grid[cur_row][cur_col]\n                # after that we need to check if the ball gets stuck at the same column\n                # and there are three cases\n                # 1. the ball on the leftmost column is moving to the left\n                # hence, we check `next_col < 0`\n                # 2. the ball on the rightmost column is moving to the right\n                # hence, we check `next_col >= n`\n                # 3. the ball is stuck at a V shape position\n                # e.g. ball 2 and ball 3 in column 2 and column 3 in row 0\n                # hence, we check if the if grid[cur_row][cur_col] is different than grid[cur_row][next_col]\n                if next_col < 0 or next_col >= n or grid[cur_row][cur_col] ^ grid[cur_row][next_col]:\n                    # the ball is stuck at some point, which means it couldn't reach to the end\n                    # hence, we can set -1 and break here\n                    cur_col = -1\n                    break\n                # continue the above process with the updated cur_col\n                cur_col = next_col\n            # the ball reaches to the end,\n            # cur_col is the final destination\n            ans.append(cur_col)\n        return ans\n        \n"))),(0,r.kt)(d,{value:"go",label:"Go",mdxType:"TabItem"},(0,r.kt)(b,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"// Time Complexity: O(m * n)\n// Space Complexity: O(n)\n\n// idea: we can simulate the movement of each ball\n// if a ball is stuck at some point, then it would be -1\n// otherwise, get the final destination column\nfunc findBall(grid [][]int) []int {\n    m, n := len(grid), len(grid[0])\n    ans := []int{}\n    // iterate each column\n    for col := 0; col < n; col++ {\n        cur_col := col\n        // iterate each row\n        for cur_row := 0; cur_row < m; cur_row++ {\n            // the next column would be the current column + the value of the current cell\n            // e.g. column 0 + 1 = column 1 (move to the right)\n            // e.g. column 3 - 1 = column 2 (move to the left)\n            next_col := cur_col + grid[cur_row][cur_col]\n            // after that we need to check if the ball gets stuck at the same column\n            // and there are three cases\n            // 1. the ball on the leftmost column is moving to the left\n            // hence, we check `next_col < 0`\n            // 2. the ball on the rightmost column is moving to the right\n            // hence, we check `next_col >= n`\n            // 3. the ball is stuck at a V shape position\n            // e.g. ball 2 and ball 3 in column 2 and column 3 in row 0\n            // hence, we check if the if grid[cur_row][cur_col] is different than grid[cur_row][next_col]\n            if next_col < 0 || next_col >= n || grid[cur_row][cur_col] != grid[cur_row][next_col] {\n                // the ball is stuck at some point, which means it couldn't reach to the end\n                // hence, we can set -1 and break here\n                cur_col = -1\n                break;\n            }\n            // continue the above process with the updated cur_col\n            cur_col = next_col\n        }\n        // the ball reaches to the end,\n        // cur_col is the final destination\n        ans = append(ans, cur_col);\n    }\n    return ans\n}\n")))))}g.isMDXComponent=!0}}]);