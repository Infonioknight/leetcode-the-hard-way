"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[59905],{3905:(e,n,t)=>{t.d(n,{Zo:()=>h,kt:()=>d});var r=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=r.createContext({}),l=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},h=function(e){var n=l(e.components);return r.createElement(c.Provider,{value:n},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),u=l(t),p=o,d=u["".concat(c,".").concat(p)]||u[p]||m[p]||i;return t?r.createElement(d,a(a({ref:n},h),{},{components:t})):r.createElement(d,a({ref:n},h))}));function d(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,a=new Array(i);a[0]=p;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s[u]="string"==typeof e?e:o,a[1]=s;for(var l=2;l<i;l++)a[l]=t[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},55115:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>f,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var r=t(87462),o=(t(67294),t(3905));const i={description:"Author: @wingkwong, @ColeB2 | https://leetcode.com/problems/permutation-in-string/",tags:["Hash Table","Two Pointers","String","Sliding Window"]},a="0567 - Permutation in String (Medium)",s={unversionedId:"0500-0599/permutation-in-string-medium",id:"0500-0599/permutation-in-string-medium",title:"0567 - Permutation in String (Medium)",description:"Author: @wingkwong, @ColeB2 | https://leetcode.com/problems/permutation-in-string/",source:"@site/solutions/0500-0599/0567-permutation-in-string-medium.md",sourceDirName:"0500-0599",slug:"/0500-0599/permutation-in-string-medium",permalink:"/solutions/0500-0599/permutation-in-string-medium",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/solutions/0500-0599/0567-permutation-in-string-medium.md",tags:[{label:"Hash Table",permalink:"/solutions/tags/hash-table"},{label:"Two Pointers",permalink:"/solutions/tags/two-pointers"},{label:"String",permalink:"/solutions/tags/string"},{label:"Sliding Window",permalink:"/solutions/tags/sliding-window"}],version:"current",sidebarPosition:567,frontMatter:{description:"Author: @wingkwong, @ColeB2 | https://leetcode.com/problems/permutation-in-string/",tags:["Hash Table","Two Pointers","String","Sliding Window"]},sidebar:"tutorialSidebar",previous:{title:"0560 - Subarray Sum Equals K (Medium)",permalink:"/solutions/0500-0599/subarray-sum-equals-k-medium"},next:{title:"0572 - Subtree of Another Tree (Easy)",permalink:"/solutions/0500-0599/subtree-of-another-tree-easy"}},c={},l=[{value:"Problem Link",id:"problem-link",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Approach 1: Sliding Window",id:"approach-1-sliding-window",level:2},{value:"Approach 2: Sliding Window - Track Matches",id:"approach-2-sliding-window---track-matches",level:2}],h=e=>function(n){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,o.kt)("div",n)},u=h("Tabs"),m=h("TabItem"),p=h("SolutionAuthor"),d={toc:l},w="wrapper";function f(e){let{components:n,...t}=e;return(0,o.kt)(w,(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"0567---permutation-in-string-medium"},"0567 - Permutation in String (Medium)"),(0,o.kt)("h2",{id:"problem-link"},"Problem Link"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://leetcode.com/problems/permutation-in-string/"},"https://leetcode.com/problems/permutation-in-string/")),(0,o.kt)("h2",{id:"problem-statement"},"Problem Statement"),(0,o.kt)("p",null,"Given two strings ",(0,o.kt)("inlineCode",{parentName:"p"},"s1")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"s2"),", return ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," ",(0,o.kt)("em",{parentName:"p"},"if")," ",(0,o.kt)("inlineCode",{parentName:"p"},"s2")," ",(0,o.kt)("em",{parentName:"p"},"contains a permutation of")," ",(0,o.kt)("inlineCode",{parentName:"p"},"s1"),(0,o.kt)("em",{parentName:"p"},", or")," ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," ",(0,o.kt)("em",{parentName:"p"},"otherwise"),"."),(0,o.kt)("p",null,"In other words, return ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," if one of ",(0,o.kt)("inlineCode",{parentName:"p"},"s1"),"'s permutations is the substring of ",(0,o.kt)("inlineCode",{parentName:"p"},"s2"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 1:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'Input: s1 = "ab", s2 = "eidbaooo"\nOutput: true\nExplanation: s2 contains one permutation of s1 ("ba").\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example 2:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'Input: s1 = "ab", s2 = "eidboaoo"\nOutput: false \n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Constraints:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"1 <= s1.length, s2.length <= 10^4")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"s1")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"s2")," consist of lowercase English letters.")),(0,o.kt)("h2",{id:"approach-1-sliding-window"},"Approach 1: Sliding Window"),(0,o.kt)("p",null,"The solution is almost same as ",(0,o.kt)("a",{parentName:"p",href:"../0400-0499/find-all-anagrams-in-a-string-medium"},"0438 - Find All Anagrams in a String (Medium)"),". The general idea is to count the character occurrences as the string order doesn't matter, and check if there is a window with the same length as $$s1$$ contains the same set of occurrences."),(0,o.kt)("p",null,"We first use a hash map $$target$$ count the occurrences for each character in $$s1$$. Then we apply sliding window. We use a pointer $$i$$ to track the window starting point and use a pointer $$j$$ to track the window ending point in $$s2$$. We increase the pointer $$j$$ to count the occurrences in $$s2$$ and put the result in another hash map $$now$$ until the window size $$j - i + 1$$ is equal to the length of $$s1$$. Then we compare if both hash maps are identical. If so, return the answer immediately. If not, then we need to remove the leftmost element within this window. Continue the same process until the pointer $$i$$ reaches the end of the string."),(0,o.kt)(u,{mdxType:"Tabs"},(0,o.kt)(m,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,o.kt)(p,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    bool checkInclusion(string s1, string s2) {\n        // target for s1, now for s2\n        vector<int> target(26), now(26);\n        int n = (int) s1.size(), m = (int) s2.size(), j = 0;\n        // count the occurrences for characters in s1\n        for (auto x : s1) target[x - 'a']++;\n        // apply sliding window. pointer i is the starting position\n        for (int i = 0; i < m; i++) {\n          // pointer j is the ending position \n          // j - i + 1 = window size\n          // we count the occurrences for characters in s2 within the window\n          while (j < m && j - i + 1 <= n) now[s2[j++] - 'a']++;\n          // check if both hash maps are same or not\n          // if they are same, return true\n          if (now == target) return true;\n          // if they are not same, remove the leftmost element and move forward\n          now[s2[i] - 'a']--;\n      }\n      // no permutation is the substring of s2. return false here\n      return false;\n    }\n};\n")),(0,o.kt)("p",null,"We can also do it without pointer $$j$$."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},"class Solution {\npublic:\n    bool checkInclusion(string s1, string s2) {\n        // target for s1, now for s2\n        vector<int> target(26), now(26);\n        int n = (int) s1.size(), m = (int) s2.size();\n        // count the occurrences for characters in s1\n        for (auto x : s1) target[x - 'a']++;\n        for (int i = 0; i < m; i++) {\n            // count the occurrences for characters in s2\n            now[s2[i] - 'a']++;\n            // remove the leftmost element in the window\n            if (i >= n) now[s2[i - n] - 'a']--;\n            // check both hash maps are same\n            if (now == target) {\n                return true;\n            }\n        }\n        // no permutation is the substring of s2. return false here\n        return false;\n    }\n};\n")))),(0,o.kt)("h2",{id:"approach-2-sliding-window---track-matches"},"Approach 2: Sliding Window - Track Matches"),(0,o.kt)("p",null,"Similar to Approach 1 but with a slight improvement. We will still create a sliding window, and a hash map to count the characters in $$s1$$. But, instead of creating a second hash map to count the characters in $$s2$$, we will use the first hash map, and just decrement the count every time a character comes into our window, and increment a $$matches$$ variable when ever the counter's character count for that character reaches 0. (Must also then decrement $$matches$$ when the character count is no longer 0). Thus removing the need to do a worst case, $O(26)$ check of both counters on each iteration to check that they are equal."),(0,o.kt)("p",null,"Time Complexity: $O(n+m)$ where $$n$$ is the length of $$s2$$, and $$m$$ is the length of $$s1$$."),(0,o.kt)("p",null,"Space Complexity: $O(c)$ where $$c$$ is the unique number of characters in $$s1$$ to create our hash map."),(0,o.kt)(u,{mdxType:"Tabs"},(0,o.kt)(m,{value:"python",label:"Python",mdxType:"TabItem"},(0,o.kt)(p,{name:"@ColeB2",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-py"},'class Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        # We are going to create a counter to count the letters of s1, then\n        # as we come accross them in s2, decrement them. If we ever reach\n        # a point, where all out values in the counter reach 0, we know we\n        # have a window with all the proper character in it and can return True.\n        # 1. Build a hash map that contains count of all characters in s1.\n        # Note: we could also use collections.Counter(s1) as a python built\n        # in, both should take O(m) time, where m is the length of s1.\n        counter = {}\n        for ch in s1:\n            if ch not in counter:\n                counter[ch] = 0\n            counter[ch] += 1\n        # Initialize variables to track number of matches, that our window\n        # has with s1, and window_size, length of s1.\n        matches = 0\n        window_size = len(s1)\n        # Loop through all the letters in s2, tracking i, the index and ch\n        # which is the character directly coming into our sliding window.\n        for i, ch in enumerate(s2):\n            # check that the incoming character is a character in our counter.\n            if ch in counter:\n                # decrement the counter, as it matches with our window.\n                counter[ch] -= 1\n                # if number of characters reaches 0, we know we have the same amount\n                # of characters in s1, as we do our window sliding across s2. \n                if counter[ch] == 0:\n                    # So we increment matches.\n                    matches += 1\n            # Check that window we created is proper size to have letters start leaving window.\n            if i >= window_size:\n                # Set variable to left character, which is character leaving the window.\n                left_ch = s2[i-window_size]\n                # Check that the leaving character is in our counter, if not, we don\'t need to do anything.\n                if left_ch in counter:\n                    # Leaving character is in s1, so now we check if our count of characters is 0.\n                    # If it is 0, we know that the leaving character caused our\n                    # window to no longer have same number of ch as s1. \n                    if counter[left_ch] == 0:\n                        # So we decrement matches.\n                        matches -= 1\n                    # Increment counter, since the letter we needed, left the window.\n                    counter[left_ch] += 1\n            # check that the number of matches is equal to the size of our counter.\n            # Note we use len(counter) as string "aabbcc" produce a counter of size 3.\n            if matches == len(counter):\n                return True\n        # We made it through without triggering true, return False.\n        return False\n')),(0,o.kt)(p,{name:"@wingkwong",mdxType:"SolutionAuthor"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-py"},"# idea:\n# permutation -> same frequency of each character\n# e.g. ab & ba - they both have 1 `a` and 1 `b`\n# which implies we can count the frequency of s1\n# and check if there is a substring of length of `n` (window)\n# containing the same set of frequency of characters\n# which implies we can use sliding window\nclass Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        n, m = len(s1), len(s2)\n        # if s1 got more characters, \n        # then s2 can never contain a permutation of s1\n        if n > m: return False\n        # cnt_s1: frequency of character in s1\n        # cnt_s2: frequency of character in s2\n        cnt_s1, cnt_s2 = [0] * 26, [0] * 26\n        # count the frequency of characters in s1 first\n        for i in range(n):\n            cnt_s1[ord(s1[i]) - ord('a')] += 1\n        # for each character in s2\n        for i in range(m):\n            # we increase the frequency in cnt_s2\n            cnt_s2[ord(s2[i]) - ord('a')] += 1\n            # given the window size `n`,\n            # if the current index >= n, it means we need to pop the leftmost element out\n            # e.g. window size = 2 - now it includes `eid` - we need to pop `e` out\n            if i >= n: cnt_s2[ord(s2[i - n]) - ord('a')] -= 1\n            # check if both frequency count matches or not\n            if cnt_s1 == cnt_s2: return True\n        return False\n")))))}f.isMDXComponent=!0}}]);