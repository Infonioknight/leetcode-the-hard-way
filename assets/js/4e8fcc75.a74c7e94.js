"use strict";(self.webpackChunkleetcode_the_hard_way=self.webpackChunkleetcode_the_hard_way||[]).push([[24262],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var o=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),h=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=h(e.components);return o.createElement(l.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=h(n),u=r,m=p["".concat(l,".").concat(u)]||p[u]||c[u]||a;return n?o.createElement(m,i(i({ref:t},d),{},{components:n})):o.createElement(m,i({ref:t},d))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var h=2;h<a;h++)i[h]=n[h];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},68744:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>w,frontMatter:()=>a,metadata:()=>s,suggestedProblems:()=>d,toc:()=>h});var o=n(87462),r=(n(67294),n(3905));const a={title:"Lowest Common Ancestor(LCA)",description:"Lowest common ancestor (LCA) of two nodes x and y is the deepest(lowest) node that has both x and y as descendants",hide_table_of_contents:!1,keywords:["leetcode","tutorial","lowest common ancestor","algorithm"]},i=void 0,s={unversionedId:"graph-theory/lca",id:"graph-theory/lca",title:"Lowest Common Ancestor(LCA)",description:"Lowest common ancestor (LCA) of two nodes x and y is the deepest(lowest) node that has both x and y as descendants",source:"@site/tutorials/graph-theory/lca.md",sourceDirName:"graph-theory",slug:"/graph-theory/lca",permalink:"/tutorials/graph-theory/lca",draft:!1,editUrl:"https://github.com/wingkwong/leetcode-the-hard-way/tree/main/tutorials/graph-theory/lca.md",tags:[],version:"current",frontMatter:{title:"Lowest Common Ancestor(LCA)",description:"Lowest common ancestor (LCA) of two nodes x and y is the deepest(lowest) node that has both x and y as descendants",hide_table_of_contents:!1,keywords:["leetcode","tutorial","lowest common ancestor","algorithm"]},sidebar:"tutorialSidebar",previous:{title:"Kruskal's Algorithm",permalink:"/tutorials/graph-theory/kruskals-algorithm"},next:{title:"Minimum Spanning Tree",permalink:"/tutorials/graph-theory/minimum-spanning-tree"}},l={},h=[{value:"Overview",id:"overview",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Example: 0235 -Lowest Common Ancestor of a Binary Tree",id:"example-0235--lowest-common-ancestor-of-a-binary-tree",level:2},{value:"Example: 2096. Step-By-Step Directions From a Binary Tree Node to Another",id:"example-2096-step-by-step-directions-from-a-binary-tree-node-to-another",level:2}],d=[{problemName:"1123. Lowest Common Ancestor of Deepest Leaves",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/",solutionLink:""},{problemName:"235. Lowest Common Ancestor of a Binary Search Tree",difficulty:"Medium",leetCodeLink:"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",solutionLink:""}],p=e=>function(t){return console.warn("Component "+e+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",t)},c=p("TutorialAuthors"),u=p("Contributors"),m=p("Tabs"),f=p("TabItem"),b=p("SolutionAuthor"),y=p("Table"),$={toc:h,suggestedProblems:d},g="wrapper";function w(e){let{components:t,...n}=e;return(0,r.kt)(g,(0,o.Z)({},$,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)(c,{names:"@RohitTaparia",mdxType:"TutorialAuthors"}),(0,r.kt)(u,{names:"@wingkwong",mdxType:"Contributors"}),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"Lowest common ancestor (LCA) of two nodes $x$ and $y$ in a tree or directed acyclic graph (DAG) is the deepest(lowest) node that has both $x$ and $y$ as descendants. Hence, LCA is the ancestor of x and y which is the farthest from the root node in a tree. In most cases, we also consider a node to be a descendant of itself. We have assumed this fact for this article,i.e, $$LCA(x,x)=x$$. Also, the $$LCA(x,y)$$ is a node that surely lies on the shortest path between $$x$$ and $$y$$, since if there was a smaller path, there would surely be a node at a lower depth which is their mutual ancestor, and this cannot be possible as if it was, this node would have been the LCA."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://user-images.githubusercontent.com/79581359/196247356-4eba006f-8be1-44cb-a146-cb36ebaa44a4.png",alt:"image"})),(0,r.kt)("p",null,"In this example, for nodes $7$ and $4$, the LCA is $2$."),(0,r.kt)("p",null,"For nodes $6$ and $4$, the LCA is $5$."),(0,r.kt)("p",null,"For nodes $4$ and $8$, the LCA is the root itself, i.e. $3$. "),(0,r.kt)("p",null,"$$NOTE:$$ The LCA in a binary tree for the root with any other node will be the root itself."),(0,r.kt)("p",null,"One of the most common applications of LCA is to determine the distance between pairs of nodes in a binary tree(or any other tree for that matter).In the above example, the distance between $6$ and $4$ can be computed as can be computed as the distance from $6$ to $root(3)$, plus the distance from the $4$ to $root(3)$, minus twice the distance from the root to their lowest common ancestor(LCA), that is,"),(0,r.kt)("p",null,"$$\ndist(x,y) = dist(x, root) + dist(y, root)-  2 * dist(LCA, root)\n$$"),(0,r.kt)("h2",{id:"implementation"},"Implementation"),(0,r.kt)("p",null,"We can notice from the definition of LCA that the LCA of two nodes $$x$$ and $$y$$ is nothing but the node of the intersection of the paths from $$x$$ and $$y$$ to the root node. In the tree above, the paths from $7$ and $6$ to the root node have their first intersection at $5$. Hence, $$LCA(7, 6) = 5$$. We can calculate the paths using DFS and find the intersection using a stack based approach, or using a recursive approach. This is the general(naive) solution, and takes $$O(N)$$ time and $$O(N)$$ space. Below is the code for the iterative approach using stacks."),(0,r.kt)(m,{mdxType:"Tabs"},(0,r.kt)(f,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)(b,{name:"@RohitTaparia",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"\nint findingLCA(int x, int y, vector<int>& adj) {\n  // adj[i] represents parent node of i\n  int root = 0;\n  stack<int> x_path, y_path;\n\n  // find first path\n  while (x != root) {\n    x_path.push(x);\n    x = adj[x];\n  }\n  x_path.push(x);\n\n  // find second path\n  while (y != root) {\n    y_path.push(y);\n    y = adj[y];\n  }\n  y_path.push(y);\n\n  int lca = -1;\n  // find the last common node\n  while ((!x_path.empty() && !y_path.empty()) &&\n         (x_path.top() == y_path.top())) {\n    lca = x_path.top();\n    x_path.pop();\n    y_path.pop();\n  }\n  return lca;\n}\n")))),(0,r.kt)("p",null,"The same logic can be implemented using recursion, so that we do not need to use stacks explicitly. We store paths from root to node $$x$$ and from root to node $$y$$ and then check iterate to the last common node, which is the LCA. Explicitly, what we are trying to do here is to find which is the last common node while traversing both the paths. Obviously the root will be common in both paths, since we assume that both nodes are present. Then we need to go to the common node which is the farthest from the root node. This we can do if we traverse both the paths. The last common node gives us the LCA."),(0,r.kt)(m,{mdxType:"Tabs"},(0,r.kt)(f,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)(b,{name:"@RohitTaparia",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"// findLCA will return LCA only if both node x, y are present, else -1\nint findLCA(Node* root, int x, int y) {\n  vector<int> path_root_to_x, path_root_to_y;\n\n  // if either x or y is not present return -1\n  if (!findPath(root, path_root_to_x, x) || !findPath(root, path_root_to_y, y))\n    return -1;\n\n  // check for LCA now, which is farthest common node from root in both paths\n  for (int i = 0; i < path_root_to_x.size() && i < path_root_to_y.size(); i++)\n    if (path_root_to_x[i] != path_root_to_y[i]) break;\n  return path_root_to_x[i - 1];\n}\n\nbool findPath(Node* root, vector<int>& current_path, int value) {\n  // if root is NULL, then no paths\n  if (root == NULL) return false;\n\n  current_path.push_back(root->key);\n\n  if (root->key == value) return true;\n\n  // check if value is found in left or right sub-tree\n  if ((root->left && findPath(root->left, current_path, value)) ||\n      (root->right && findPath(root->right, current_path, value)))\n    return true;\n\n  // remove root since not found in subtree\n  current_path.pop_back();\n  return false;\n}\n\n")))),(0,r.kt)("h2",{id:"example-0235--lowest-common-ancestor-of-a-binary-tree"},"Example: ",(0,r.kt)("a",{parentName:"h2",href:"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/"},"0235 -Lowest Common Ancestor of a Binary Tree")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\nOutput: 3\nExplanation: The LCA of nodes 5 and 1 is 3.\n")),(0,r.kt)("p",null,"Let's start with a recursive solution. The idea is simple. We start from the root and start checking in the left and right subtree of every node(basically DFS). If the current subtree contains both p and q, i.e, neither of them is $$NULL$$, then the function will reuurn the root of this subtree which will be the LCA. If any one of them is $$NULL$$, then the function returns the other one. If both are $$NULL$$, then the result will also be $$NULL$$. The time complexity will be $$O(N)$$ and space somplexity would be $$O(N)$$, since maximum height for a binary tree(skewed) will be $$N$$."),(0,r.kt)(m,{mdxType:"Tabs"},(0,r.kt)(f,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)(b,{name:"@RohitTaparia",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"/**\n * definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\n public:\n  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    // base case to check if the root is null or\n    // one of the required nodes is the root itself\n    // used the recursive implementation discussed earlier\n    if (root == NULL) {\n      return root;\n    }\n    if (root == p || root == q) {\n      return root;\n    }\n    // recurse for the left subtree, basically dfs\n    TreeNode* left = lowestCommonAncestor(root->left, p, q);\n    // recurse for the right subtree\n    TreeNode* right = lowestCommonAncestor(root->right, p, q);\n\n    // if one of them is NULL means we need to return the other one\n    if (left == NULL) {\n      return right;\n    } else if (right == NULL) {\n      return left;\n    } else {\n      // when both left and right are not null, we can say that this is the LCA\n      return root;\n    }\n  }\n};\n")))),(0,r.kt)("h2",{id:"example-2096-step-by-step-directions-from-a-binary-tree-node-to-another"},"Example: ",(0,r.kt)("a",{parentName:"h2",href:"https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/"},"2096. Step-By-Step Directions From a Binary Tree Node to Another")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"You are given the root of a binary tree with n nodes. Each node is uniquely assigned a value from 1 to n. You are also given an integer startValue representing the value of the start node s, and a different integer destValue representing the value of the destination node t.\n\nFind the shortest path starting from node s and ending at node t. Generate step-by-step directions of such path as a string consisting of only the uppercase letters 'L', 'R', and 'U'. Each letter indicates a specific direction:\n\n'L' means to go from a node to its left child node.\n'R' means to go from a node to its right child node.\n'U' means to go from a node to its parent node.\nReturn the step-by-step directions of the shortest path from node s to node t.\nInput: root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6\nOutput: \"UURL\"\nExplanation: The shortest path is: 3 \u2192 1 \u2192 5 \u2192 2 \u2192 6.\n")),(0,r.kt)("p",null,"In this problem, we need to find the closest point(from nodes), where path from root to nodes intersect, which is LCA of both the nodes. Hence, we first find the LCA node of start and destination. Then we need to get path from LCA to the starting node($$lca_s$$) and from LCA to destination($$lca_d$$). This method has also been explained above. In this we simply do a simple DFS and first explore the left path, and then the right path. Whenever we find the node, we return true, otherwise we backtrack and explore the right path. Now that we have both paths, we will convert all chars in $$lca_s$$ to $$U$$, since we need to move upward."),(0,r.kt)("p",null,"At last, we concatenate both strings and return the combined path."),(0,r.kt)(m,{mdxType:"Tabs"},(0,r.kt)(f,{value:"cpp",label:"C++",mdxType:"TabItem"},(0,r.kt)(b,{name:"@RohitTaparia",mdxType:"SolutionAuthor"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"/**\n * definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Solution {\n public:\n  // function to get LCA of given two nodes\n  // used the recursive implementation discussed earlier\n  TreeNode* getLCA(TreeNode* root, int start, int dest) {\n    if (!root) return NULL;\n\n    if (root->val == start || root->val == dest) return root;\n\n    // recurse for left subtree\n    TreeNode* left = getLCA(root->left, start, dest);\n    // recurse for right subtree\n    TreeNode* right = getLCA(root->right, start, dest);\n\n    // if both are not null, this node is LCA\n    if (left && right) return root;\n\n    // else return the node which is not NULL\n    else if (left) {\n      return left;\n    }\n    return right;\n  }\n\n  bool findPath(TreeNode* root, string& path, int val) {\n    if (!root) return false;\n\n    // if node is found, we can return true\n    if (root->val == val) return true;\n\n    // try to find node for left\n    path.push_back('L');\n    if (findPath(root->left, path, val)) return true;\n    path.pop_back();\n\n    // try to find node for right\n    path.push_back('R');\n    if (findPath(root->right, path, val)) return true;\n    path.pop_back();\n\n    return false;\n  }\n\n  string getDirections(TreeNode* root, int initialValue, int finalValue) {\n    // get LCA of start and destination node\n    TreeNode* lca = getLCA(root, initialValue, finalValue);\n\n    string lcaS = \"\", lcaD = \"\";\n\n    // find both paths\n    findPath(lca, lcaS, initialValue);\n    findPath(lca, lcaD, finalValue);\n\n    for (auto& c : lcaS) c = 'U';\n\n    // merge both paths,\n    // i.e. start node -> destination node\n    return lcaS + lcaD;\n  }\n};\n")))),(0,r.kt)(y,{title:"Suggested Problems",data:d,mdxType:"Table"}))}w.isMDXComponent=!0}}]);